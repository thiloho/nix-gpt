[
  {
    "title": "NixOS 23.11 manual | Nix & NixOS",
    "url": "https://nixos.org/manual/nixos/unstable/",
    "html": "Table of Contents\n\nPreface\nInstallation\nObtaining NixOS\nInstalling NixOS\nChanging the Configuration\nUpgrading NixOS\nBuilding a NixOS (Live) ISO\nBuilding Images via systemd-repart\nConfiguration\nConfiguration Syntax\nPackage Management\nUser Management\nFile Systems\nX Window System\nWayland\nGPU acceleration\nXfce Desktop Environment\nNetworking\nLinux Kernel\nSubversion\nPantheon Desktop\nGNOME Desktop\nExternal Bootloader Backends\nGarage\nPlausible\nPict-rs\nNextcloud\nMatomo\nLemmy\nKeycloak\nJitsi Meet\nHonk\nGrocy\nGoToSocial\nDiscourse\nc2FmZQ\nAkkoma\nMeilisearch\nYggdrasil\nProsody\nPleroma\nMosquitto\nFirefox Sync server\nLitestream\nPrometheus exporters\nparsedmarc\nGoss\nCert Spotter\nWeeChat\nTaskserver\nSourcehut\nGitLab\nMatrix\nMjolnir (Matrix Moderation Tool)\nMailman\nTrezor\nEmacs\nLivebook\nBlackfire profiler\nFlatpak\nPostgreSQL\nFoundationDB\nBorgBackup\nCastopod\nSSL/TLS Certificates with ACME\nOh my ZSH\nPlotinus\nDigital Bitbox\nInput Methods\nProfiles\nKubernetes\nAdministration\nService Management\nRebooting and Shutting Down\nUser Sessions\nControl Groups\nLogging\nCleaning the Nix Store\nContainer Management\nTroubleshooting\nDevelopment\nGetting the Sources\nWriting NixOS Modules\nBuilding Specific Parts of NixOS\nExperimental feature: Bootspec\nWhat happens during a system switch?\nWriting NixOS Documentation\nNixOS Tests\nDeveloping the NixOS Test Driver\nTesting the Installer\nContributing to this manual\nA. Configuration Options\nB. Release Notes\nPreface \n\nThis manual describes how to install, use and extend NixOS, a Linux distribution based on the purely functional package management system Nix, that is composed using modules and packages defined in the Nixpkgs project.\n\nAdditional information regarding the Nix package manager and the Nixpkgs project can be found in respectively the Nix manual and the Nixpkgs manual.\n\nIf you encounter problems, please report them on the Discourse, the Matrix room, or on the #nixos channel on Libera.Chat. Alternatively, consider contributing to this manual. Bugs should be reported in NixOS’ GitHub issue tracker.\n\nNote\n\nCommands prefixed with # have to be run as root, either requiring to login as root user or temporarily switching to it using sudo for example.\n\nInstallation \n\nThis section describes how to obtain, install, and configure NixOS for first-time use.\n\nTable of Contents\n\nObtaining NixOS\nInstalling NixOS\nChanging the Configuration\nUpgrading NixOS\nBuilding a NixOS (Live) ISO\nBuilding Images via systemd-repart\nObtaining NixOS \n\nNixOS ISO images can be downloaded from the NixOS download page. Follow the instructions in the section called “Booting from a USB flash drive” to create a bootable USB flash drive.\n\nIf you have a very old system that can’t boot from USB, you can burn the image to an empty CD. NixOS might not work very well on such systems.\n\nAs an alternative to installing NixOS yourself, you can get a running NixOS system through several other means:\n\nUsing virtual appliances in Open Virtualization Format (OVF) that can be imported into VirtualBox. These are available from the NixOS download page.\n\nUsing AMIs for Amazon’s EC2. To find one for your region, please refer to the download page.\n\nUsing NixOps, the NixOS-based cloud deployment tool, which allows you to provision VirtualBox and EC2 NixOS instances from declarative specifications. Check out the NixOps homepage for details.\n\nInstalling NixOS \n\nTable of Contents\n\nBooting from the install medium\nGraphical Installation\nManual Installation\nAdditional installation notes\nBooting from the install medium \n\nTo begin the installation, you have to boot your computer from the install drive.\n\nPlug in the install drive. Then turn on or restart your computer.\n\nOpen the boot menu by pressing the appropriate key, which is usually shown on the display on early boot. Select the USB flash drive (the option usually contains the word “USB”). If you choose the incorrect drive, your computer will likely continue to boot as normal. In that case restart your computer and pick a different drive.\n\nNote\n\nThe key to open the boot menu is different across computer brands and even models. It can be F12, but also F1, F9, F10, Enter, Del, Esc or another function key. If you are unsure and don’t see it on the early boot screen, you can search online for your computers brand, model followed by “boot from usb”. The computer might not even have that feature, so you have to go into the BIOS/UEFI settings to change the boot order. Again, search online for details about your specific computer model.\n\nFor Apple computers with Intel processors press and hold the ⌥ (Option or Alt) key until you see the boot menu. On Apple silicon press and hold the power button.\n\nNote\n\nIf your computer supports both BIOS and UEFI boot, choose the UEFI option.\n\nNote\n\nIf you use a CD for the installation, the computer will probably boot from it automatically. If not, choose the option containing the word “CD” from the boot menu.\n\nShortly after selecting the appropriate boot drive, you should be presented with a menu with different installer options. Leave the default and wait (or press Enter to speed up).\n\nThe graphical images will start their corresponding desktop environment and the graphical installer, which can take some time. The minimal images will boot to a command line. You have to follow the instructions in the section called “Manual Installation” there.\n\nGraphical Installation \n\nThe graphical installer is recommended for desktop users and will guide you through the installation.\n\nIn the “Welcome” screen, you can select the language of the Installer and the installed system.\n\nTip\n\nLeaving the language as “American English” will make it easier to search for error messages in a search engine or to report an issue.\n\nNext you should choose your location to have the timezone set correctly. You can actually click on the map!\n\nNote\n\nThe installer will use an online service to guess your location based on your public IP address.\n\nThen you can select the keyboard layout. The default keyboard model should work well with most desktop keyboards. If you have a special keyboard or notebook, your model might be in the list. Select the language you are most comfortable typing in.\n\nOn the “Users” screen, you have to type in your display name, login name and password. You can also enable an option to automatically login to the desktop.\n\nThen you have the option to choose a desktop environment. If you want to create a custom setup with a window manager, you can select “No desktop”.\n\nTip\n\nIf you don’t have a favorite desktop and don’t know which one to choose, you can stick to either GNOME or Plasma. They have a quite different design, so you should choose whichever you like better. They are both popular choices and well tested on NixOS.\n\nYou have the option to allow unfree software in the next screen.\n\nThe easiest option in the “Partitioning” screen is “Erase disk”, which will delete all data from the selected disk and install the system on it. Also select “Swap (with Hibernation)” in the dropdown below it. You have the option to encrypt the whole disk with LUKS.\n\nNote\n\nAt the top left you see if the Installer was booted with BIOS or UEFI. If you know your system supports UEFI and it shows “BIOS”, reboot with the correct option.\n\nWarning\n\nMake sure you have selected the correct disk at the top and that no valuable data is still on the disk! It will be deleted when formatting the disk.\n\nCheck the choices you made in the “Summary” and click “Install”.\n\nNote\n\nThe installation takes about 15 minutes. The time varies based on the selected desktop environment, internet connection speed and disk write speed.\n\nWhen the install is complete, remove the USB flash drive and reboot into your new system!\n\nManual Installation \n\nNixOS can be installed on BIOS or UEFI systems. The procedure for a UEFI installation is broadly the same as for a BIOS installation. The differences are mentioned in the following steps.\n\nThe NixOS manual is available by running nixos-help in the command line or from the application menu in the desktop environment.\n\nTo have access to the command line on the graphical images, open Terminal (GNOME) or Konsole (Plasma) from the application menu.\n\nYou are logged-in automatically as nixos. The nixos user account has an empty password so you can use sudo without a password:\n\n$ sudo -i\n\n\nYou can use loadkeys to switch to your preferred keyboard layout. (We even provide neo2 via loadkeys de neo!)\n\nIf the text is too small to be legible, try setfont ter-v32n to increase the font size.\n\nTo install over a serial port connect with 115200n8 (e.g. picocom -b 115200 /dev/ttyUSB0). When the bootloader lists boot entries, select the serial console boot entry.\n\nNetworking in the installer \n\nThe boot process should have brought up networking (check ip a). Networking is necessary for the installer, since it will download lots of stuff (such as source tarballs or Nixpkgs channel binaries). It’s best if you have a DHCP server on your network. Otherwise configure networking manually using ifconfig.\n\nOn the graphical installer, you can configure the network, wifi included, through NetworkManager. Using the nmtui program, you can do so even in a non-graphical session. If you prefer to configure the network manually, disable NetworkManager with systemctl stop NetworkManager.\n\nOn the minimal installer, NetworkManager is not available, so configuration must be performed manually. To configure the wifi, first start wpa_supplicant with sudo systemctl start wpa_supplicant, then run wpa_cli. For most home networks, you need to type in the following commands:\n\n> add_network\n0\n> set_network 0 ssid \"myhomenetwork\"\nOK\n> set_network 0 psk \"mypassword\"\nOK\n> set_network 0 key_mgmt WPA-PSK\nOK\n> enable_network 0\nOK\n\n\nFor enterprise networks, for example eduroam, instead do:\n\n> add_network\n0\n> set_network 0 ssid \"eduroam\"\nOK\n> set_network 0 identity \"myname@example.com\"\nOK\n> set_network 0 password \"mypassword\"\nOK\n> set_network 0 key_mgmt WPA-EAP\nOK\n> enable_network 0\nOK\n\n\nWhen successfully connected, you should see a line such as this one\n\n<3>CTRL-EVENT-CONNECTED - Connection to 32:85:ab:ef:24:5c completed [id=0 id_str=]\n\n\nyou can now leave wpa_cli by typing quit.\n\nIf you would like to continue the installation from a different machine you can use activated SSH daemon. You need to copy your ssh key to either /home/nixos/.ssh/authorized_keys or /root/.ssh/authorized_keys (Tip: For installers with a modifiable filesystem such as the sd-card installer image a key can be manually placed by mounting the image on a different machine). Alternatively you must set a password for either root or nixos with passwd to be able to login.\n\nPartitioning and formatting \n\nThe NixOS installer doesn’t do any partitioning or formatting, so you need to do that yourself.\n\nThe NixOS installer ships with multiple partitioning tools. The examples below use parted, but also provides fdisk, gdisk, cfdisk, and cgdisk.\n\nThe recommended partition scheme differs depending if the computer uses Legacy Boot or UEFI.\n\nUEFI (GPT)\n\nHere’s an example partition scheme for UEFI, using /dev/sda as the device.\n\nNote\n\nYou can safely ignore parted’s informational message about needing to update /etc/fstab.\n\nCreate a GPT partition table.\n\n# parted /dev/sda -- mklabel gpt\n\n\nAdd the root partition. This will fill the disk except for the end part, where the swap will live, and the space left in front (512MiB) which will be used by the boot partition.\n\n# parted /dev/sda -- mkpart root ext4 512MB -8GB\n\n\nNext, add a swap partition. The size required will vary according to needs, here a 8GB one is created.\n\n# parted /dev/sda -- mkpart swap linux-swap -8GB 100%\n\nNote\n\nThe swap partition size rules are no different than for other Linux distributions.\n\nFinally, the boot partition. NixOS by default uses the ESP (EFI system partition) as its /boot partition. It uses the initially reserved 512MiB at the start of the disk.\n\n# parted /dev/sda -- mkpart ESP fat32 1MB 512MB\n# parted /dev/sda -- set 3 esp on\n\n\nOnce complete, you can follow with the section called “Formatting”.\n\nLegacy Boot (MBR)\n\nHere’s an example partition scheme for Legacy Boot, using /dev/sda as the device.\n\nNote\n\nYou can safely ignore parted’s informational message about needing to update /etc/fstab.\n\nCreate a MBR partition table.\n\n# parted /dev/sda -- mklabel msdos\n\n\nAdd the root partition. This will fill the the disk except for the end part, where the swap will live.\n\n# parted /dev/sda -- mkpart primary 1MB -8GB\n\n\nSet the root partition’s boot flag to on. This allows the disk to be booted from.\n\n# parted /dev/sda -- set 1 boot on\n\n\nFinally, add a swap partition. The size required will vary according to needs, here a 8GB one is created.\n\n# parted /dev/sda -- mkpart primary linux-swap -8GB 100%\n\nNote\n\nThe swap partition size rules are no different than for other Linux distributions.\n\nOnce complete, you can follow with the section called “Formatting”.\n\nFormatting\n\nUse the following commands:\n\nFor initialising Ext4 partitions: mkfs.ext4. It is recommended that you assign a unique symbolic label to the file system using the option -L label, since this makes the file system configuration independent from device changes. For example:\n\n# mkfs.ext4 -L nixos /dev/sda1\n\n\nFor creating swap partitions: mkswap. Again it’s recommended to assign a label to the swap partition: -L label. For example:\n\n# mkswap -L swap /dev/sda2\n\n\nUEFI systems\n\nFor creating boot partitions: mkfs.fat. Again it’s recommended to assign a label to the boot partition: -n label. For example:\n\n# mkfs.fat -F 32 -n boot /dev/sda3\n\n\nFor creating LVM volumes, the LVM commands, e.g., pvcreate, vgcreate, and lvcreate.\n\nFor creating software RAID devices, use mdadm.\n\nInstalling \n\nMount the target file system on which NixOS should be installed on /mnt, e.g.\n\n# mount /dev/disk/by-label/nixos /mnt\n\n\nUEFI systems\n\nMount the boot file system on /mnt/boot, e.g.\n\n# mkdir -p /mnt/boot\n# mount /dev/disk/by-label/boot /mnt/boot\n\n\nIf your machine has a limited amount of memory, you may want to activate swap devices now (swapon device). The installer (or rather, the build actions that it may spawn) may need quite a bit of RAM, depending on your configuration.\n\n# swapon /dev/sda2\n\n\nYou now need to create a file /mnt/etc/nixos/configuration.nix that specifies the intended configuration of the system. This is because NixOS has a declarative configuration model: you create or edit a description of the desired configuration of your system, and then NixOS takes care of making it happen. The syntax of the NixOS configuration file is described in Configuration Syntax, while a list of available configuration options appears in Appendix A. A minimal example is shown in Example: NixOS Configuration.\n\nThe command nixos-generate-config can generate an initial configuration file for you:\n\n# nixos-generate-config --root /mnt\n\n\nYou should then edit /mnt/etc/nixos/configuration.nix to suit your needs:\n\n# nano /mnt/etc/nixos/configuration.nix\n\n\nIf you’re using the graphical ISO image, other editors may be available (such as vim). If you have network access, you can also install other editors – for instance, you can install Emacs by running nix-env -f '<nixpkgs>' -iA emacs.\n\nBIOS systems\n\nYou must set the option boot.loader.grub.device to specify on which disk the GRUB boot loader is to be installed. Without it, NixOS cannot boot.\n\nIf there are other operating systems running on the machine before installing NixOS, the boot.loader.grub.useOSProber option can be set to true to automatically add them to the grub menu.\n\nUEFI systems\n\nYou must select a boot-loader, either systemd-boot or GRUB. The recommended option is systemd-boot: set the option boot.loader.systemd-boot.enable to true. nixos-generate-config should do this automatically for new configurations when booted in UEFI mode.\n\nYou may want to look at the options starting with boot.loader.efi and boot.loader.systemd-boot as well.\n\nIf you want to use GRUB, set boot.loader.grub.device to nodev and boot.loader.grub.efiSupport to true.\n\nWith systemd-boot, you should not need any special configuration to detect other installed systems. With GRUB, set boot.loader.grub.useOSProber to true, but this will only detect windows partitions, not other Linux distributions. If you dual boot another Linux distribution, use systemd-boot instead.\n\nIf you need to configure networking for your machine the configuration options are described in Networking. In particular, while wifi is supported on the installation image, it is not enabled by default in the configuration generated by nixos-generate-config.\n\nAnother critical option is fileSystems, specifying the file systems that need to be mounted by NixOS. However, you typically don’t need to set it yourself, because nixos-generate-config sets it automatically in /mnt/etc/nixos/hardware-configuration.nix from your currently mounted file systems. (The configuration file hardware-configuration.nix is included from configuration.nix and will be overwritten by future invocations of nixos-generate-config; thus, you generally should not modify it.) Additionally, you may want to look at Hardware configuration for known-hardware at this point or after installation.\n\nNote\n\nDepending on your hardware configuration or type of file system, you may need to set the option boot.initrd.kernelModules to include the kernel modules that are necessary for mounting the root file system, otherwise the installed system will not be able to boot. (If this happens, boot from the installation media again, mount the target file system on /mnt, fix /mnt/etc/nixos/configuration.nix and rerun nixos-install.) In most cases, nixos-generate-config will figure out the required modules.\n\nDo the installation:\n\n# nixos-install\n\n\nThis will install your system based on the configuration you provided. If anything fails due to a configuration problem or any other issue (such as a network outage while downloading binaries from the NixOS binary cache), you can re-run nixos-install after fixing your configuration.nix.\n\nAs the last step, nixos-install will ask you to set the password for the root user, e.g.\n\nsetting root password...\nNew password: ***\nRetype new password: ***\n\nNote\n\nFor unattended installations, it is possible to use nixos-install --no-root-passwd in order to disable the password prompt entirely.\n\nIf everything went well:\n\n# reboot\n\n\nYou should now be able to boot into the installed NixOS. The GRUB boot menu shows a list of available configurations (initially just one). Every time you change the NixOS configuration (see Changing Configuration), a new item is added to the menu. This allows you to easily roll back to a previous configuration if something goes wrong.\n\nYou should log in and change the root password with passwd.\n\nYou’ll probably want to create some user accounts as well, which can be done with useradd:\n\n$ useradd -c 'Eelco Dolstra' -m eelco\n$ passwd eelco\n\n\nYou may also want to install some software. This will be covered in Package Management.\n\nInstallation summary \n\nTo summarise, Example: Commands for Installing NixOS on /dev/sda shows a typical sequence of commands for installing NixOS on an empty hard drive (here /dev/sda). Example: NixOS Configuration shows a corresponding configuration Nix expression.\n\nExample 1. Example partition schemes for NixOS on /dev/sda (MBR)\n\n# parted /dev/sda -- mklabel msdos\n# parted /dev/sda -- mkpart primary 1MB -8GB\n# parted /dev/sda -- mkpart primary linux-swap -8GB 100%\n\n\n\n\nExample 2. Example partition schemes for NixOS on /dev/sda (UEFI)\n\n# parted /dev/sda -- mklabel gpt\n# parted /dev/sda -- mkpart root ext4 512MB -8GB\n# parted /dev/sda -- mkpart swap linux-swap -8GB 100%\n# parted /dev/sda -- mkpart ESP fat32 1MB 512MB\n# parted /dev/sda -- set 3 esp on\n\n\n\n\nExample 3. Commands for Installing NixOS on /dev/sda\n\nWith a partitioned disk.\n\n# mkfs.ext4 -L nixos /dev/sda1\n# mkswap -L swap /dev/sda2\n# swapon /dev/sda2\n# mkfs.fat -F 32 -n boot /dev/sda3        # (for UEFI systems only)\n# mount /dev/disk/by-label/nixos /mnt\n# mkdir -p /mnt/boot                      # (for UEFI systems only)\n# mount /dev/disk/by-label/boot /mnt/boot # (for UEFI systems only)\n# nixos-generate-config --root /mnt\n# nano /mnt/etc/nixos/configuration.nix\n# nixos-install\n# reboot\n\n\n\n\nExample 4. Example: NixOS Configuration\n\n{ config, pkgs, ... }: {\n  imports = [\n    # Include the results of the hardware scan.\n    ./hardware-configuration.nix\n  ];\n\n  boot.loader.grub.device = \"/dev/sda\";   # (for BIOS systems only)\n  boot.loader.systemd-boot.enable = true; # (for UEFI systems only)\n\n  # Note: setting fileSystems is generally not\n  # necessary, since nixos-generate-config figures them out\n  # automatically in hardware-configuration.nix.\n  #fileSystems.\"/\".device = \"/dev/disk/by-label/nixos\";\n\n  # Enable the OpenSSH server.\n  services.sshd.enable = true;\n}\n\n\n\nAdditional installation notes \nBooting from a USB flash drive \n\nThe image has to be written verbatim to the USB flash drive for it to be bootable on UEFI and BIOS systems. Here are the recommended tools to do that.\n\nCreating bootable USB flash drive with a graphical tool\n\nEtcher is a popular and user-friendly tool. It works on Linux, Windows and macOS.\n\nDownload it from balena.io, start the program, select the downloaded NixOS ISO, then select the USB flash drive and flash it.\n\nWarning\n\nEtcher reports errors and usage statistics by default, which can be disabled in the settings.\n\nAn alternative is USBImager, which is very simple and does not connect to the internet. Download the version with write-only (wo) interface for your system. Start the program, select the image, select the USB flash drive and click “Write”.\n\nCreating bootable USB flash drive from a Terminal on Linux\n\nPlug in the USB flash drive.\n\nFind the corresponding device with lsblk. You can distinguish them by their size.\n\nMake sure all partitions on the device are properly unmounted. Replace sdX with your device (e.g. sdb).\n\nsudo umount /dev/sdX*\n\n\nThen use the dd utility to write the image to the USB flash drive.\n\nsudo dd if=<path-to-image> of=/dev/sdX bs=4M conv=fsync\n\nCreating bootable USB flash drive from a Terminal on macOS\n\nPlug in the USB flash drive.\n\nFind the corresponding device with diskutil list. You can distinguish them by their size.\n\nMake sure all partitions on the device are properly unmounted. Replace diskX with your device (e.g. disk1).\n\ndiskutil unmountDisk diskX\n\n\nThen use the dd utility to write the image to the USB flash drive.\n\nsudo dd if=<path-to-image> of=/dev/rdiskX bs=4m\n\n\nAfter dd completes, a GUI dialog “The disk you inserted was not readable by this computer” will pop up, which can be ignored.\n\nNote\n\nUsing the ‘raw’ rdiskX device instead of diskX with dd completes in minutes instead of hours.\n\nEject the disk when it is finished.\n\ndiskutil eject /dev/diskX\n\nBooting from the “netboot” media (PXE) \n\nAdvanced users may wish to install NixOS using an existing PXE or iPXE setup.\n\nThese instructions assume that you have an existing PXE or iPXE infrastructure and want to add the NixOS installer as another option. To build the necessary files from your current version of nixpkgs, you can run:\n\nnix-build -A netboot.x86_64-linux '<nixpkgs/nixos/release.nix>'\n\n\nThis will create a result directory containing: * bzImage – the Linux kernel * initrd – the initrd file * netboot.ipxe – an example ipxe script demonstrating the appropriate kernel command line arguments for this image\n\nIf you’re using plain PXE, configure your boot loader to use the bzImage and initrd files and have it provide the same kernel command line arguments found in netboot.ipxe.\n\nIf you’re using iPXE, depending on how your HTTP/FTP/etc. server is configured you may be able to use netboot.ipxe unmodified, or you may need to update the paths to the files to match your server’s directory layout.\n\nIn the future we may begin making these files available as build products from hydra at which point we will update this documentation with instructions on how to obtain them either for placing on a dedicated TFTP server or to boot them directly over the internet.\n\n“Booting” into NixOS via kexec \n\nIn some cases, your system might already be booted into/preinstalled with another Linux distribution, and booting NixOS by attaching an installation image is quite a manual process.\n\nThis is particularly useful for (cloud) providers where you can’t boot a custom image, but get some Debian or Ubuntu installation.\n\nIn these cases, it might be easier to use kexec to “jump into NixOS” from the running system, which only assumes bash and kexec to be installed on the machine.\n\nNote that kexec may not work correctly on some hardware, as devices are not fully re-initialized in the process. In practice, this however is rarely the case.\n\nTo build the necessary files from your current version of nixpkgs, you can run:\n\nnix-build -A kexec.x86_64-linux '<nixpkgs/nixos/release.nix>'\n\n\nThis will create a result directory containing the following:\n\nbzImage (the Linux kernel)\n\ninitrd (the initrd file)\n\nkexec-boot (a shellscript invoking kexec)\n\nThese three files are meant to be copied over to the other already running Linux Distribution.\n\nNote its symlinks pointing elsewhere, so cd in, and use scp * root@$destination to copy it over, rather than rsync.\n\nOnce you finished copying, execute kexec-boot on the destination, and after some seconds, the machine should be booting into an (ephemeral) NixOS installation medium.\n\nIn case you want to describe your own system closure to kexec into, instead of the default installer image, you can build your own configuration.nix:\n\n{ modulesPath, ... }: {\n  imports = [\n    (modulesPath + \"/installer/netboot/netboot-minimal.nix\")\n  ];\n\n  services.openssh.enable = true;\n  users.users.root.openssh.authorizedKeys.keys = [\n    \"my-ssh-pubkey\"\n  ];\n}\n\nnix-build '<nixpkgs/nixos>' \\\n  --arg configuration ./configuration.nix\n  --attr config.system.build.kexecTree\n\n\nMake sure your configuration.nix does still import netboot-minimal.nix (or netboot-base.nix).\n\nInstalling in a VirtualBox guest \n\nInstalling NixOS into a VirtualBox guest is convenient for users who want to try NixOS without installing it on bare metal. If you want to use a pre-made VirtualBox appliance, it is available at the downloads page. If you want to set up a VirtualBox guest manually, follow these instructions:\n\nAdd a New Machine in VirtualBox with OS Type “Linux / Other Linux”\n\nBase Memory Size: 768 MB or higher.\n\nNew Hard Disk of 8 GB or higher.\n\nMount the CD-ROM with the NixOS ISO (by clicking on CD/DVD-ROM)\n\nClick on Settings / System / Processor and enable PAE/NX\n\nClick on Settings / System / Acceleration and enable “VT-x/AMD-V” acceleration\n\nClick on Settings / Display / Screen and select VMSVGA as Graphics Controller\n\nSave the settings, start the virtual machine, and continue installation like normal\n\nThere are a few modifications you should make in configuration.nix. Enable booting:\n\nboot.loader.grub.device = \"/dev/sda\";\n\n\nAlso remove the fsck that runs at startup. It will always fail to run, stopping your boot until you press *.\n\nboot.initrd.checkJournalingFS = false;\n\n\nShared folders can be given a name and a path in the host system in the VirtualBox settings (Machine / Settings / Shared Folders, then click on the “Add” icon). Add the following to the /etc/nixos/configuration.nix to auto-mount them. If you do not add \"nofail\", the system will not boot properly.\n\n{ config, pkgs, ...} :\n{\n  fileSystems.\"/virtualboxshare\" = {\n    fsType = \"vboxsf\";\n    device = \"nameofthesharedfolder\";\n    options = [ \"rw\" \"nofail\" ];\n  };\n}\n\n\nThe folder will be available directly under the root directory.\n\nInstalling from another Linux distribution \n\nBecause Nix (the package manager) & Nixpkgs (the Nix packages collection) can both be installed on any (most?) Linux distributions, they can be used to install NixOS in various creative ways. You can, for instance:\n\nInstall NixOS on another partition, from your existing Linux distribution (without the use of a USB or optical device!)\n\nInstall NixOS on the same partition (in place!), from your existing non-NixOS Linux distribution using NIXOS_LUSTRATE.\n\nInstall NixOS on your hard drive from the Live CD of any Linux distribution.\n\nThe first steps to all these are the same:\n\nInstall the Nix package manager:\n\nShort version:\n\n$ curl -L https://nixos.org/nix/install | sh\n$ . $HOME/.nix-profile/etc/profile.d/nix.sh # …or open a fresh shell\n\n\nMore details in the Nix manual\n\nSwitch to the NixOS channel:\n\nIf you’ve just installed Nix on a non-NixOS distribution, you will be on the nixpkgs channel by default.\n\n$ nix-channel --list\nnixpkgs https://nixos.org/channels/nixpkgs-unstable\n\n\nAs that channel gets released without running the NixOS tests, it will be safer to use the nixos-* channels instead:\n\n$ nix-channel --add https://nixos.org/channels/nixos-version nixpkgs\n\n\nYou may want to throw in a nix-channel --update for good measure.\n\nInstall the NixOS installation tools:\n\nYou’ll need nixos-generate-config and nixos-install, but this also makes some man pages and nixos-enter available, just in case you want to chroot into your NixOS partition. NixOS installs these by default, but you don’t have NixOS yet…\n\n$ nix-env -f '<nixpkgs>' -iA nixos-install-tools\n\nNote\n\nThe following 5 steps are only for installing NixOS to another partition. For installing NixOS in place using NIXOS_LUSTRATE, skip ahead.\n\nPrepare your target partition:\n\nAt this point it is time to prepare your target partition. Please refer to the partitioning, file-system creation, and mounting steps of Installing NixOS\n\nIf you’re about to install NixOS in place using NIXOS_LUSTRATE there is nothing to do for this step.\n\nGenerate your NixOS configuration:\n\n$ sudo `which nixos-generate-config` --root /mnt\n\n\nYou’ll probably want to edit the configuration files. Refer to the nixos-generate-config step in Installing NixOS for more information.\n\nConsider setting up the NixOS bootloader to give you the ability to boot on your existing Linux partition. For instance, if you’re using GRUB and your existing distribution is running Ubuntu, you may want to add something like this to your configuration.nix:\n\nboot.loader.grub.extraEntries = ''\n  menuentry \"Ubuntu\" {\n    search --set=ubuntu --fs-uuid 3cc3e652-0c1f-4800-8451-033754f68e6e\n    configfile \"($ubuntu)/boot/grub/grub.cfg\"\n  }\n'';\n\n\n(You can find the appropriate UUID for your partition in /dev/disk/by-uuid)\n\nCreate the nixbld group and user on your original distribution:\n\n$ sudo groupadd -g 30000 nixbld\n$ sudo useradd -u 30000 -g nixbld -G nixbld nixbld\n\n\nDownload/build/install NixOS:\n\nWarning\n\nOnce you complete this step, you might no longer be able to boot on existing systems without the help of a rescue USB drive or similar.\n\nNote\n\nOn some distributions there are separate PATHS for programs intended only for root. In order for the installation to succeed, you might have to use PATH=\"$PATH:/usr/sbin:/sbin\" in the following command.\n\n$ sudo PATH=\"$PATH\" NIX_PATH=\"$NIX_PATH\" `which nixos-install` --root /mnt\n\n\nAgain, please refer to the nixos-install step in Installing NixOS for more information.\n\nThat should be it for installation to another partition!\n\nOptionally, you may want to clean up your non-NixOS distribution:\n\n$ sudo userdel nixbld\n$ sudo groupdel nixbld\n\n\nIf you do not wish to keep the Nix package manager installed either, run something like sudo rm -rv ~/.nix-* /nix and remove the line that the Nix installer added to your ~/.profile.\n\nNote\n\nThe following steps are only for installing NixOS in place using NIXOS_LUSTRATE:\n\nGenerate your NixOS configuration:\n\n$ sudo `which nixos-generate-config`\n\n\nNote that this will place the generated configuration files in /etc/nixos. You’ll probably want to edit the configuration files. Refer to the nixos-generate-config step in Installing NixOS for more information.\n\nYou’ll likely want to set a root password for your first boot using the configuration files because you won’t have a chance to enter a password until after you reboot. You can initialize the root password to an empty one with this line: (and of course don’t forget to set one once you’ve rebooted or to lock the account with sudo passwd -l root if you use sudo)\n\nusers.users.root.initialHashedPassword = \"\";\n\n\nBuild the NixOS closure and install it in the system profile:\n\n$ nix-env -p /nix/var/nix/profiles/system -f '<nixpkgs/nixos>' -I nixos-config=/etc/nixos/configuration.nix -iA system\n\n\nChange ownership of the /nix tree to root (since your Nix install was probably single user):\n\n$ sudo chown -R 0:0 /nix\n\n\nSet up the /etc/NIXOS and /etc/NIXOS_LUSTRATE files:\n\n/etc/NIXOS officializes that this is now a NixOS partition (the bootup scripts require its presence).\n\n/etc/NIXOS_LUSTRATE tells the NixOS bootup scripts to move everything that’s in the root partition to /old-root. This will move your existing distribution out of the way in the very early stages of the NixOS bootup. There are exceptions (we do need to keep NixOS there after all), so the NixOS lustrate process will not touch:\n\nThe /nix directory\n\nThe /boot directory\n\nAny file or directory listed in /etc/NIXOS_LUSTRATE (one per line)\n\nNote\n\nSupport for NIXOS_LUSTRATE was added in NixOS 16.09. The act of “lustrating” refers to the wiping of the existing distribution. Creating /etc/NIXOS_LUSTRATE can also be used on NixOS to remove all mutable files from your root partition (anything that’s not in /nix or /boot gets “lustrated” on the next boot.\n\nlustrate /ˈlʌstreɪt/ verb.\n\npurify by expiatory sacrifice, ceremonial washing, or some other ritual action.\n\nLet’s create the files:\n\n$ sudo touch /etc/NIXOS\n$ sudo touch /etc/NIXOS_LUSTRATE\n\n\nLet’s also make sure the NixOS configuration files are kept once we reboot on NixOS:\n\n$ echo etc/nixos | sudo tee -a /etc/NIXOS_LUSTRATE\n\n\nFinally, move the /boot directory of your current distribution out of the way (the lustrate process will take care of the rest once you reboot, but this one must be moved out now because NixOS needs to install its own boot files:\n\nWarning\n\nOnce you complete this step, your current distribution will no longer be bootable! If you didn’t get all the NixOS configuration right, especially those settings pertaining to boot loading and root partition, NixOS may not be bootable either. Have a USB rescue device ready in case this happens.\n\n$ sudo mv -v /boot /boot.bak &&\nsudo /nix/var/nix/profiles/system/bin/switch-to-configuration boot\n\n\nCross your fingers, reboot, hopefully you should get a NixOS prompt!\n\nIf for some reason you want to revert to the old distribution, you’ll need to boot on a USB rescue disk and do something along these lines:\n\n# mkdir root\n# mount /dev/sdaX root\n# mkdir root/nixos-root\n# mv -v root/* root/nixos-root/\n# mv -v root/nixos-root/old-root/* root/\n# mv -v root/boot.bak root/boot  # We had renamed this by hand earlier\n# umount root\n# reboot\n\n\nThis may work as is or you might also need to reinstall the boot loader.\n\nAnd of course, if you’re happy with NixOS and no longer need the old distribution:\n\nsudo rm -rf /old-root\n\n\nIt’s also worth noting that this whole process can be automated. This is especially useful for Cloud VMs, where provider do not provide NixOS. For instance, nixos-infect uses the lustrate process to convert Digital Ocean droplets to NixOS from other distributions automatically.\n\nInstalling behind a proxy \n\nTo install NixOS behind a proxy, do the following before running nixos-install.\n\nUpdate proxy configuration in /mnt/etc/nixos/configuration.nix to keep the internet accessible after reboot.\n\nnetworking.proxy.default = \"http://user:password@proxy:port/\";\nnetworking.proxy.noProxy = \"127.0.0.1,localhost,internal.domain\";\n\n\nSetup the proxy environment variables in the shell where you are running nixos-install.\n\n# proxy_url=\"http://user:password@proxy:port/\"\n# export http_proxy=\"$proxy_url\"\n# export HTTP_PROXY=\"$proxy_url\"\n# export https_proxy=\"$proxy_url\"\n# export HTTPS_PROXY=\"$proxy_url\"\n\nNote\n\nIf you are switching networks with different proxy configurations, use the specialisation option in configuration.nix to switch proxies at runtime. Refer to Appendix A for more information.\n\nChanging the Configuration \n\nThe file /etc/nixos/configuration.nix contains the current configuration of your machine. Whenever you’ve changed something in that file, you should do\n\n# nixos-rebuild switch\n\n\nto build the new configuration, make it the default configuration for booting, and try to realise the configuration in the running system (e.g., by restarting system services).\n\nWarning\n\nThis command doesn’t start/stop user services automatically. nixos-rebuild only runs a daemon-reload for each user with running user services.\n\nWarning\n\nThese commands must be executed as root, so you should either run them from a root shell or by prefixing them with sudo -i.\n\nYou can also do\n\n# nixos-rebuild test\n\n\nto build the configuration and switch the running system to it, but without making it the boot default. So if (say) the configuration locks up your machine, you can just reboot to get back to a working configuration.\n\nThere is also\n\n# nixos-rebuild boot\n\n\nto build the configuration and make it the boot default, but not switch to it now (so it will only take effect after the next reboot).\n\nYou can make your configuration show up in a different submenu of the GRUB 2 boot screen by giving it a different profile name, e.g.\n\n# nixos-rebuild switch -p test\n\n\nwhich causes the new configuration (and previous ones created using -p test) to show up in the GRUB submenu “NixOS - Profile ‘test’”. This can be useful to separate test configurations from “stable” configurations.\n\nFinally, you can do\n\n$ nixos-rebuild build\n\n\nto build the configuration but nothing more. This is useful to see whether everything compiles cleanly.\n\nIf you have a machine that supports hardware virtualisation, you can also test the new configuration in a sandbox by building and running a QEMU virtual machine that contains the desired configuration. Just do\n\n$ nixos-rebuild build-vm\n$ ./result/bin/run-*-vm\n\n\nThe VM does not have any data from your host system, so your existing user accounts and home directories will not be available unless you have set mutableUsers = false. Another way is to temporarily add the following to your configuration:\n\nusers.users.your-user.initialHashedPassword = \"test\";\n\n\nImportant: delete the $hostname.qcow2 file if you have started the virtual machine at least once without the right users, otherwise the changes will not get picked up. You can forward ports on the host to the guest. For instance, the following will forward host port 2222 to guest port 22 (SSH):\n\n$ QEMU_NET_OPTS=\"hostfwd=tcp:127.0.0.1:2222-:22\" ./result/bin/run-*-vm\n\n\nallowing you to log in via SSH (assuming you have set the appropriate passwords or SSH authorized keys):\n\n$ ssh -p 2222 localhost\n\n\nSuch port forwardings connect via the VM’s virtual network interface. Thus they cannot connect to ports that are only bound to the VM’s loopback interface (127.0.0.1), and the VM’s NixOS firewall must be configured to allow these connections.\n\nUpgrading NixOS \n\nTable of Contents\n\nAutomatic Upgrades\n\nThe best way to keep your NixOS installation up to date is to use one of the NixOS channels. A channel is a Nix mechanism for distributing Nix expressions and associated binaries. The NixOS channels are updated automatically from NixOS’s Git repository after certain tests have passed and all packages have been built. These channels are:\n\nStable channels, such as nixos-23.05. These only get conservative bug fixes and package upgrades. For instance, a channel update may cause the Linux kernel on your system to be upgraded from 4.19.34 to 4.19.38 (a minor bug fix), but not from 4.19.x to 4.20.x (a major change that has the potential to break things). Stable channels are generally maintained until the next stable branch is created.\n\nThe unstable channel, nixos-unstable. This corresponds to NixOS’s main development branch, and may thus see radical changes between channel updates. It’s not recommended for production systems.\n\nSmall channels, such as nixos-23.05-small or nixos-unstable-small. These are identical to the stable and unstable channels described above, except that they contain fewer binary packages. This means they get updated faster than the regular channels (for instance, when a critical security patch is committed to NixOS’s source tree), but may require more packages to be built from source than usual. They’re mostly intended for server environments and as such contain few GUI applications.\n\nTo see what channels are available, go to https://channels.nixos.org. (Note that the URIs of the various channels redirect to a directory that contains the channel’s latest version and includes ISO images and VirtualBox appliances.) Please note that during the release process, channels that are not yet released will be present here as well. See the Getting NixOS page https://nixos.org/nixos/download.html to find the newest supported stable release.\n\nWhen you first install NixOS, you’re automatically subscribed to the NixOS channel that corresponds to your installation source. For instance, if you installed from a 23.05 ISO, you will be subscribed to the nixos-23.05 channel. To see which NixOS channel you’re subscribed to, run the following as root:\n\n# nix-channel --list | grep nixos\nnixos https://channels.nixos.org/nixos-unstable\n\n\nTo switch to a different NixOS channel, do\n\n# nix-channel --add https://channels.nixos.org/channel-name nixos\n\n\n(Be sure to include the nixos parameter at the end.) For instance, to use the NixOS 23.05 stable channel:\n\n# nix-channel --add https://channels.nixos.org/nixos-23.05 nixos\n\n\nIf you have a server, you may want to use the “small” channel instead:\n\n# nix-channel --add https://channels.nixos.org/nixos-23.05-small nixos\n\n\nAnd if you want to live on the bleeding edge:\n\n# nix-channel --add https://channels.nixos.org/nixos-unstable nixos\n\n\nYou can then upgrade NixOS to the latest version in your chosen channel by running\n\n# nixos-rebuild switch --upgrade\n\n\nwhich is equivalent to the more verbose nix-channel --update nixos; nixos-rebuild switch.\n\nNote\n\nChannels are set per user. This means that running nix-channel --add as a non root user (or without sudo) will not affect configuration in /etc/nixos/configuration.nix\n\nWarning\n\nIt is generally safe to switch back and forth between channels. The only exception is that a newer NixOS may also have a newer Nix version, which may involve an upgrade of Nix’s database schema. This cannot be undone easily, so in that case you will not be able to go back to your original channel.\n\nAutomatic Upgrades \n\nYou can keep a NixOS system up-to-date automatically by adding the following to configuration.nix:\n\nsystem.autoUpgrade.enable = true;\nsystem.autoUpgrade.allowReboot = true;\n\n\nThis enables a periodically executed systemd service named nixos-upgrade.service. If the allowReboot option is false, it runs nixos-rebuild switch --upgrade to upgrade NixOS to the latest version in the current channel. (To see when the service runs, see systemctl list-timers.) If allowReboot is true, then the system will automatically reboot if the new generation contains a different kernel, initrd or kernel modules. You can also specify a channel explicitly, e.g.\n\nsystem.autoUpgrade.channel = \"https://channels.nixos.org/nixos-23.05\";\n\nBuilding a NixOS (Live) ISO \n\nTable of Contents\n\nPractical Instructions\nAdditional drivers or firmware\nTechnical Notes\n\nDefault live installer configurations are available inside nixos/modules/installer/cd-dvd. For building other system images, nixos-generators is a good place to start looking at.\n\nYou have two options:\n\nUse any of those default configurations as is\n\nCombine them with (any of) your host config(s)\n\nSystem images, such as the live installer ones, know how to enforce configuration settings on which they immediately depend in order to work correctly.\n\nHowever, if you are confident, you can opt to override those enforced values with mkForce.\n\nPractical Instructions \n\nTo build an ISO image for the channel nixos-unstable:\n\n$ git clone https://github.com/NixOS/nixpkgs.git\n$ cd nixpkgs/nixos\n$ git switch nixos-unstable\n$ nix-build -A config.system.build.isoImage -I nixos-config=modules/installer/cd-dvd/installation-cd-minimal.nix default.nix\n\n\nTo check the content of an ISO image, mount it like so:\n\n# mount -o loop -t iso9660 ./result/iso/cd.iso /mnt/iso\n\nAdditional drivers or firmware \n\nIf you need additional (non-distributable) drivers or firmware in the installer, you might want to extend these configurations.\n\nFor example, to build the GNOME graphical installer ISO, but with support for certain WiFi adapters present in some MacBooks, you can create the following file at modules/installer/cd-dvd/installation-cd-graphical-gnome-macbook.nix:\n\n{ config, ... }:\n\n{\n  imports = [ ./installation-cd-graphical-gnome.nix ];\n\n  boot.initrd.kernelModules = [ \"wl\" ];\n\n  boot.kernelModules = [ \"kvm-intel\" \"wl\" ];\n  boot.extraModulePackages = [ config.boot.kernelPackages.broadcom_sta ];\n}\n\n\nThen build it like in the example above:\n\n$ git clone https://github.com/NixOS/nixpkgs.git\n$ cd nixpkgs/nixos\n$ export NIXPKGS_ALLOW_UNFREE=1\n$ nix-build -A config.system.build.isoImage -I nixos-config=modules/installer/cd-dvd/installation-cd-graphical-gnome-macbook.nix default.nix\n\nTechnical Notes \n\nThe config value enforcement is implemented via mkImageMediaOverride = mkOverride 60; and therefore primes over simple value assignments, but also yields to mkForce.\n\nThis property allows image designers to implement in semantically correct ways those configuration values upon which the correct functioning of the image depends.\n\nFor example, the iso base image overrides those file systems which it needs at a minimum for correct functioning, while the installer base image overrides the entire file system layout because there can’t be any other guarantees on a live medium than those given by the live medium itself. The latter is especially true before formatting the target block device(s). On the other hand, the netboot iso only overrides its minimum dependencies since netboot images are always made-to-target.\n\nBuilding Images via systemd-repart \n\nTable of Contents\n\nNix Store Partition\nAppliance Image\n\nYou can build disk images in NixOS with the image.repart option provided by the module image/repart.nix. This module uses systemd-repart to build the images and exposes it’s entire interface via the repartConfig option.\n\nAn example of how to build an image:\n\n{ config, modulesPath, ... }: {\n\n  imports = [ \"${modulesPath}/image/repart.nix\" ];\n\n  image.repart = {\n    name = \"image\";\n    partitions = {\n      \"esp\" = {\n        contents = {\n          ...\n        };\n        repartConfig = {\n          Type = \"esp\";\n          ...\n        };\n      };\n      \"root\" = {\n        storePaths = [ config.system.build.toplevel ];\n        repartConfig = {\n          Type = \"root\";\n          Label = \"nixos\";\n          ...\n        };\n      };\n    };\n  };\n\n}\n\nNix Store Partition \n\nYou can define a partition that only contains the Nix store and then mount it under /nix/store. Because the /nix/store part of the paths is already determined by the mount point, you have to set stripNixStorePrefix = true; so that the prefix is stripped from the paths before copying them into the image.\n\nfileSystems.\"/nix/store\".device = \"/dev/disk/by-partlabel/nix-store\"\n\nimage.repart.partitions = {\n  \"store\" = {\n    storePaths = [ config.system.build.toplevel ];\n    stripNixStorePrefix = true;\n    repartConfig = {\n      Type = \"linux-generic\";\n      Label = \"nix-store\";\n      ...\n    };\n  };\n};\n\nAppliance Image \n\nThe image/repart.nix module can also be used to build self-contained software appliances.\n\nThe generation based update mechanism of NixOS is not suited for appliances. Updates of appliances are usually either performed by replacing the entire image with a new one or by updating partitions via an A/B scheme. See the Chrome OS update process for an example of how to achieve this. The appliance image built in the following example does not contain a configuration.nix and thus you will not be able to call nixos-rebuild from this system.\n\nlet\n  pkgs = import <nixpkgs> { };\n  efiArch = pkgs.stdenv.hostPlatform.efiArch;\nin\n(pkgs.nixos [\n  ({ config, lib, pkgs, modulesPath, ... }: {\n\n    imports = [ \"${modulesPath}/image/repart.nix\" ];\n\n    boot.loader.grub.enable = false;\n\n    fileSystems.\"/\".device = \"/dev/disk/by-label/nixos\";\n\n    image.repart = {\n      name = \"image\";\n      partitions = {\n        \"esp\" = {\n          contents = {\n            \"/EFI/BOOT/BOOT${lib.toUpper efiArch}.EFI\".source =\n              \"${pkgs.systemd}/lib/systemd/boot/efi/systemd-boot${efiArch}.efi\";\n\n            \"/loader/entries/nixos.conf\".source = pkgs.writeText \"nixos.conf\" ''\n              title NixOS\n              linux /EFI/nixos/kernel.efi\n              initrd /EFI/nixos/initrd.efi\n              options init=${config.system.build.toplevel}/init ${toString config.boot.kernelParams}\n            '';\n\n            \"/EFI/nixos/kernel.efi\".source =\n              \"${config.boot.kernelPackages.kernel}/${config.system.boot.loader.kernelFile}\";\n\n            \"/EFI/nixos/initrd.efi\".source =\n              \"${config.system.build.initialRamdisk}/${config.system.boot.loader.initrdFile}\";\n          };\n          repartConfig = {\n            Type = \"esp\";\n            Format = \"vfat\";\n            SizeMinBytes = \"96M\";\n          };\n        };\n        \"root\" = {\n          storePaths = [ config.system.build.toplevel ];\n          repartConfig = {\n            Type = \"root\";\n            Format = \"ext4\";\n            Label = \"nixos\";\n            Minimize = \"guess\";\n          };\n        };\n      };\n    };\n\n  })\n]).image\n\nConfiguration \n\nThis chapter describes how to configure various aspects of a NixOS machine through the configuration file /etc/nixos/configuration.nix. As described in Changing the Configuration, changes to this file only take effect after you run nixos-rebuild.\n\nTable of Contents\n\nConfiguration Syntax\nPackage Management\nUser Management\nFile Systems\nX Window System\nWayland\nGPU acceleration\nXfce Desktop Environment\nNetworking\nLinux Kernel\nSubversion\nPantheon Desktop\nGNOME Desktop\nExternal Bootloader Backends\nGarage\nPlausible\nPict-rs\nNextcloud\nMatomo\nLemmy\nKeycloak\nJitsi Meet\nHonk\nGrocy\nGoToSocial\nDiscourse\nc2FmZQ\nAkkoma\nMeilisearch\nYggdrasil\nProsody\nPleroma\nMosquitto\nFirefox Sync server\nLitestream\nPrometheus exporters\nparsedmarc\nGoss\nCert Spotter\nWeeChat\nTaskserver\nSourcehut\nGitLab\nMatrix\nMjolnir (Matrix Moderation Tool)\nMailman\nTrezor\nEmacs\nLivebook\nBlackfire profiler\nFlatpak\nPostgreSQL\nFoundationDB\nBorgBackup\nCastopod\nSSL/TLS Certificates with ACME\nOh my ZSH\nPlotinus\nDigital Bitbox\nInput Methods\nProfiles\nKubernetes\nConfiguration Syntax \n\nTable of Contents\n\nNixOS Configuration File\nAbstractions\nModularity\n\nThe NixOS configuration file /etc/nixos/configuration.nix is actually a Nix expression, which is the Nix package manager’s purely functional language for describing how to build packages and configurations. This means you have all the expressive power of that language at your disposal, including the ability to abstract over common patterns, which is very useful when managing complex systems. The syntax and semantics of the Nix language are fully described in the Nix manual, but here we give a short overview of the most important constructs useful in NixOS configuration files.\n\nNixOS Configuration File \n\nThe NixOS configuration file generally looks like this:\n\n{ config, pkgs, ... }:\n\n{ option definitions\n}\n\n\nThe first line ({ config, pkgs, ... }:) denotes that this is actually a function that takes at least the two arguments config and pkgs. (These are explained later, in chapter Writing NixOS Modules) The function returns a set of option definitions ({ ... }). These definitions have the form name = value, where name is the name of an option and value is its value. For example,\n\n{ config, pkgs, ... }:\n\n{ services.httpd.enable = true;\n  services.httpd.adminAddr = \"alice@example.org\";\n  services.httpd.virtualHosts.localhost.documentRoot = \"/webroot\";\n}\n\n\ndefines a configuration with three option definitions that together enable the Apache HTTP Server with /webroot as the document root.\n\nSets can be nested, and in fact dots in option names are shorthand for defining a set containing another set. For instance, services.httpd.enable defines a set named services that contains a set named httpd, which in turn contains an option definition named enable with value true. This means that the example above can also be written as:\n\n{ config, pkgs, ... }:\n\n{ services = {\n    httpd = {\n      enable = true;\n      adminAddr = \"alice@example.org\";\n      virtualHosts = {\n        localhost = {\n          documentRoot = \"/webroot\";\n        };\n      };\n    };\n  };\n}\n\n\nwhich may be more convenient if you have lots of option definitions that share the same prefix (such as services.httpd).\n\nNixOS checks your option definitions for correctness. For instance, if you try to define an option that doesn’t exist (that is, doesn’t have a corresponding option declaration), nixos-rebuild will give an error like:\n\nThe option `services.httpd.enable' defined in `/etc/nixos/configuration.nix' does not exist.\n\n\nLikewise, values in option definitions must have a correct type. For instance, services.httpd.enable must be a Boolean (true or false). Trying to give it a value of another type, such as a string, will cause an error:\n\nThe option value `services.httpd.enable' in `/etc/nixos/configuration.nix' is not a boolean.\n\n\nOptions have various types of values. The most important are:\n\nStrings\n\nStrings are enclosed in double quotes, e.g.\n\nnetworking.hostName = \"dexter\";\n\n\nSpecial characters can be escaped by prefixing them with a backslash (e.g. \\\").\n\nMulti-line strings can be enclosed in double single quotes, e.g.\n\nnetworking.extraHosts =\n  ''\n    127.0.0.2 other-localhost\n    10.0.0.1 server\n  '';\n\n\nThe main difference is that it strips from each line a number of spaces equal to the minimal indentation of the string as a whole (disregarding the indentation of empty lines), and that characters like \" and \\ are not special (making it more convenient for including things like shell code). See more info about this in the Nix manual here.\n\nBooleans\n\nThese can be true or false, e.g.\n\nnetworking.firewall.enable = true;\nnetworking.firewall.allowPing = false;\n\nIntegers\n\nFor example,\n\nboot.kernel.sysctl.\"net.ipv4.tcp_keepalive_time\" = 60;\n\n\n(Note that here the attribute name net.ipv4.tcp_keepalive_time is enclosed in quotes to prevent it from being interpreted as a set named net containing a set named ipv4, and so on. This is because it’s not a NixOS option but the literal name of a Linux kernel setting.)\n\nSets\n\nSets were introduced above. They are name/value pairs enclosed in braces, as in the option definition\n\nfileSystems.\"/boot\" =\n  { device = \"/dev/sda1\";\n    fsType = \"ext4\";\n    options = [ \"rw\" \"data=ordered\" \"relatime\" ];\n  };\n\nLists\n\nThe important thing to note about lists is that list elements are separated by whitespace, like this:\n\nboot.kernelModules = [ \"fuse\" \"kvm-intel\" \"coretemp\" ];\n\n\nList elements can be any other type, e.g. sets:\n\nswapDevices = [ { device = \"/dev/disk/by-label/swap\"; } ];\n\nPackages\n\nUsually, the packages you need are already part of the Nix Packages collection, which is a set that can be accessed through the function argument pkgs. Typical uses:\n\nenvironment.systemPackages =\n  [ pkgs.thunderbird\n    pkgs.emacs\n  ];\n\nservices.postgresql.package = pkgs.postgresql_14;\n\n\nThe latter option definition changes the default PostgreSQL package used by NixOS’s PostgreSQL service to 14.x. For more information on packages, including how to add new ones, see the section called “Adding Custom Packages”.\n\nAbstractions \n\nIf you find yourself repeating yourself over and over, it’s time to abstract. Take, for instance, this Apache HTTP Server configuration:\n\n{\n  services.httpd.virtualHosts =\n    { \"blog.example.org\" = {\n        documentRoot = \"/webroot/blog.example.org\";\n        adminAddr = \"alice@example.org\";\n        forceSSL = true;\n        enableACME = true;\n        enablePHP = true;\n      };\n      \"wiki.example.org\" = {\n        documentRoot = \"/webroot/wiki.example.org\";\n        adminAddr = \"alice@example.org\";\n        forceSSL = true;\n        enableACME = true;\n        enablePHP = true;\n      };\n    };\n}\n\n\nIt defines two virtual hosts with nearly identical configuration; the only difference is the document root directories. To prevent this duplication, we can use a let:\n\nlet\n  commonConfig =\n    { adminAddr = \"alice@example.org\";\n      forceSSL = true;\n      enableACME = true;\n    };\nin\n{\n  services.httpd.virtualHosts =\n    { \"blog.example.org\" = (commonConfig // { documentRoot = \"/webroot/blog.example.org\"; });\n      \"wiki.example.org\" = (commonConfig // { documentRoot = \"/webroot/wiki.example.com\"; });\n    };\n}\n\n\nThe let commonConfig = ... defines a variable named commonConfig. The // operator merges two attribute sets, so the configuration of the second virtual host is the set commonConfig extended with the document root option.\n\nYou can write a let wherever an expression is allowed. Thus, you also could have written:\n\n{\n  services.httpd.virtualHosts =\n    let commonConfig = ...; in\n    { \"blog.example.org\" = (commonConfig // { ... })\n      \"wiki.example.org\" = (commonConfig // { ... })\n    };\n}\n\n\nbut not { let commonConfig = ...; in ...; } since attributes (as opposed to attribute values) are not expressions.\n\nFunctions provide another method of abstraction. For instance, suppose that we want to generate lots of different virtual hosts, all with identical configuration except for the document root. This can be done as follows:\n\n{\n  services.httpd.virtualHosts =\n    let\n      makeVirtualHost = webroot:\n        { documentRoot = webroot;\n          adminAddr = \"alice@example.org\";\n          forceSSL = true;\n          enableACME = true;\n        };\n    in\n      { \"example.org\" = (makeVirtualHost \"/webroot/example.org\");\n        \"example.com\" = (makeVirtualHost \"/webroot/example.com\");\n        \"example.gov\" = (makeVirtualHost \"/webroot/example.gov\");\n        \"example.nl\" = (makeVirtualHost \"/webroot/example.nl\");\n      };\n}\n\n\nHere, makeVirtualHost is a function that takes a single argument webroot and returns the configuration for a virtual host. That function is then called for several names to produce the list of virtual host configurations.\n\nModularity \n\nThe NixOS configuration mechanism is modular. If your configuration.nix becomes too big, you can split it into multiple files. Likewise, if you have multiple NixOS configurations (e.g. for different computers) with some commonality, you can move the common configuration into a shared file.\n\nModules have exactly the same syntax as configuration.nix. In fact, configuration.nix is itself a module. You can use other modules by including them from configuration.nix, e.g.:\n\n{ config, pkgs, ... }:\n\n{ imports = [ ./vpn.nix ./kde.nix ];\n  services.httpd.enable = true;\n  environment.systemPackages = [ pkgs.emacs ];\n  ...\n}\n\n\nHere, we include two modules from the same directory, vpn.nix and kde.nix. The latter might look like this:\n\n{ config, pkgs, ... }:\n\n{ services.xserver.enable = true;\n  services.xserver.displayManager.sddm.enable = true;\n  services.xserver.desktopManager.plasma5.enable = true;\n  environment.systemPackages = [ pkgs.vim ];\n}\n\n\nNote that both configuration.nix and kde.nix define the option environment.systemPackages. When multiple modules define an option, NixOS will try to merge the definitions. In the case of environment.systemPackages the lists of packages will be concatenated. The value in configuration.nix is merged last, so for list-type options, it will appear at the end of the merged list. If you want it to appear first, you can use mkBefore:\n\nboot.kernelModules = mkBefore [ \"kvm-intel\" ];\n\n\nThis causes the kvm-intel kernel module to be loaded before any other kernel modules.\n\nFor other types of options, a merge may not be possible. For instance, if two modules define services.httpd.adminAddr, nixos-rebuild will give an error:\n\nThe unique option `services.httpd.adminAddr' is defined multiple times, in `/etc/nixos/httpd.nix' and `/etc/nixos/configuration.nix'.\n\n\nWhen that happens, it’s possible to force one definition take precedence over the others:\n\nservices.httpd.adminAddr = pkgs.lib.mkForce \"bob@example.org\";\n\n\nWhen using multiple modules, you may need to access configuration values defined in other modules. This is what the config function argument is for: it contains the complete, merged system configuration. That is, config is the result of combining the configurations returned by every module. (If you’re wondering how it’s possible that the (indirect) result of a function is passed as an input to that same function: that’s because Nix is a “lazy” language — it only computes values when they are needed. This works as long as no individual configuration value depends on itself.)\n\nFor example, here is a module that adds some packages to environment.systemPackages only if services.xserver.enable is set to true somewhere else:\n\n{ config, pkgs, ... }:\n\n{ environment.systemPackages =\n    if config.services.xserver.enable then\n      [ pkgs.firefox\n        pkgs.thunderbird\n      ]\n    else\n      [ ];\n}\n\n\nWith multiple modules, it may not be obvious what the final value of a configuration option is. The command nixos-option allows you to find out:\n\n$ nixos-option services.xserver.enable\ntrue\n\n$ nixos-option boot.kernelModules\n[ \"tun\" \"ipv6\" \"loop\" ... ]\n\n\nInteractive exploration of the configuration is possible using nix repl, a read-eval-print loop for Nix expressions. A typical use:\n\n$ nix repl '<nixpkgs/nixos>'\n\nnix-repl> config.networking.hostName\n\"mandark\"\n\nnix-repl> map (x: x.hostName) config.services.httpd.virtualHosts\n[ \"example.org\" \"example.gov\" ]\n\n\nWhile abstracting your configuration, you may find it useful to generate modules using code, instead of writing files. The example below would have the same effect as importing a file which sets those options.\n\n{ config, pkgs, ... }:\n\nlet netConfig = hostName: {\n  networking.hostName = hostName;\n  networking.useDHCP = false;\n};\n\nin\n\n{ imports = [ (netConfig \"nixos.localdomain\") ]; }\n\nPackage Management \n\nTable of Contents\n\nDeclarative Package Management\nAd-Hoc Package Management\n\nThis section describes how to add additional packages to your system. NixOS has two distinct styles of package management:\n\nDeclarative, where you declare what packages you want in your configuration.nix. Every time you run nixos-rebuild, NixOS will ensure that you get a consistent set of binaries corresponding to your specification.\n\nAd hoc, where you install, upgrade and uninstall packages via the nix-env command. This style allows mixing packages from different Nixpkgs versions. It’s the only choice for non-root users.\n\nDeclarative Package Management \n\nWith declarative package management, you specify which packages you want on your system by setting the option environment.systemPackages. For instance, adding the following line to configuration.nix enables the Mozilla Thunderbird email application:\n\nenvironment.systemPackages = [ pkgs.thunderbird ];\n\n\nThe effect of this specification is that the Thunderbird package from Nixpkgs will be built or downloaded as part of the system when you run nixos-rebuild switch.\n\nNote\n\nSome packages require additional global configuration such as D-Bus or systemd service registration so adding them to environment.systemPackages might not be sufficient. You are advised to check the list of options whether a NixOS module for the package does not exist.\n\nYou can get a list of the available packages as follows:\n\n$ nix-env -qaP '*' --description\nnixos.firefox   firefox-23.0   Mozilla Firefox - the browser, reloaded\n...\n\n\nThe first column in the output is the attribute name, such as nixos.thunderbird.\n\nNote: the nixos prefix tells us that we want to get the package from the nixos channel and works only in CLI tools. In declarative configuration use pkgs prefix (variable).\n\nTo “uninstall” a package, remove it from environment.systemPackages and run nixos-rebuild switch.\n\nCustomising Packages \n\nSome packages in Nixpkgs have options to enable or disable optional functionality or change other aspects of the package.\n\nWarning\n\nUnfortunately, Nixpkgs currently lacks a way to query available configuration options.\n\nNote\n\nFor example, many packages come with extensions one might add. Examples include:\n\npassExtensions.pass-otp\n\npython310Packages.requests\n\nYou can use them like this:\n\nenvironment.systemPackages = with pkgs; [\n  sl\n  (pass.withExtensions (subpkgs: with subpkgs; [\n    pass-audit\n    pass-otp\n    pass-genphrase\n  ]))\n  (python3.withPackages (subpkgs: with subpkgs; [\n      requests\n  ]))\n  cowsay\n];\n\n\nApart from high-level options, it’s possible to tweak a package in almost arbitrary ways, such as changing or disabling dependencies of a package. For instance, the Emacs package in Nixpkgs by default has a dependency on GTK 2. If you want to build it against GTK 3, you can specify that as follows:\n\nenvironment.systemPackages = [ (pkgs.emacs.override { gtk = pkgs.gtk3; }) ];\n\n\nThe function override performs the call to the Nix function that produces Emacs, with the original arguments amended by the set of arguments specified by you. So here the function argument gtk gets the value pkgs.gtk3, causing Emacs to depend on GTK 3. (The parentheses are necessary because in Nix, function application binds more weakly than list construction, so without them, environment.systemPackages would be a list with two elements.)\n\nEven greater customisation is possible using the function overrideAttrs. While the override mechanism above overrides the arguments of a package function, overrideAttrs allows changing the attributes passed to mkDerivation. This permits changing any aspect of the package, such as the source code. For instance, if you want to override the source code of Emacs, you can say:\n\nenvironment.systemPackages = [\n  (pkgs.emacs.overrideAttrs (oldAttrs: {\n    name = \"emacs-25.0-pre\";\n    src = /path/to/my/emacs/tree;\n  }))\n];\n\n\nHere, overrideAttrs takes the Nix derivation specified by pkgs.emacs and produces a new derivation in which the original’s name and src attribute have been replaced by the given values by re-calling stdenv.mkDerivation. The original attributes are accessible via the function argument, which is conventionally named oldAttrs.\n\nThe overrides shown above are not global. They do not affect the original package; other packages in Nixpkgs continue to depend on the original rather than the customised package. This means that if another package in your system depends on the original package, you end up with two instances of the package. If you want to have everything depend on your customised instance, you can apply a global override as follows:\n\nnixpkgs.config.packageOverrides = pkgs:\n  { emacs = pkgs.emacs.override { gtk = pkgs.gtk3; };\n  };\n\n\nThe effect of this definition is essentially equivalent to modifying the emacs attribute in the Nixpkgs source tree. Any package in Nixpkgs that depends on emacs will be passed your customised instance. (However, the value pkgs.emacs in nixpkgs.config.packageOverrides refers to the original rather than overridden instance, to prevent an infinite recursion.)\n\nAdding Custom Packages \n\nIt’s possible that a package you need is not available in NixOS. In that case, you can do two things. Either you can package it with Nix, or you can try to use prebuilt packages from upstream. Due to the peculiarities of NixOS, it is important to note that building software from source is often easier than using pre-built executables.\n\nBuilding with Nix\n\nThis can be done either in-tree or out-of-tree. For an in-tree build, you can clone the Nixpkgs repository, add the package to your clone, and (optionally) submit a patch or pull request to have it accepted into the main Nixpkgs repository. This is described in detail in the Nixpkgs manual. In short, you clone Nixpkgs:\n\n$ git clone https://github.com/NixOS/nixpkgs\n$ cd nixpkgs\n\n\nThen you write and test the package as described in the Nixpkgs manual. Finally, you add it to environment.systemPackages, e.g.\n\nenvironment.systemPackages = [ pkgs.my-package ];\n\n\nand you run nixos-rebuild, specifying your own Nixpkgs tree:\n\n# nixos-rebuild switch -I nixpkgs=/path/to/my/nixpkgs\n\n\nThe second possibility is to add the package outside of the Nixpkgs tree. For instance, here is how you specify a build of the GNU Hello package directly in configuration.nix:\n\nenvironment.systemPackages =\n  let\n    my-hello = with pkgs; stdenv.mkDerivation rec {\n      name = \"hello-2.8\";\n      src = fetchurl {\n        url = \"mirror://gnu/hello/${name}.tar.gz\";\n        hash = \"sha256-5rd/gffPfa761Kn1tl3myunD8TuM+66oy1O7XqVGDXM=\";\n      };\n    };\n  in\n  [ my-hello ];\n\n\nOf course, you can also move the definition of my-hello into a separate Nix expression, e.g.\n\nenvironment.systemPackages = [ (import ./my-hello.nix) ];\n\n\nwhere my-hello.nix contains:\n\nwith import <nixpkgs> {}; # bring all of Nixpkgs into scope\n\nstdenv.mkDerivation rec {\n  name = \"hello-2.8\";\n  src = fetchurl {\n    url = \"mirror://gnu/hello/${name}.tar.gz\";\n    hash = \"sha256-5rd/gffPfa761Kn1tl3myunD8TuM+66oy1O7XqVGDXM=\";\n  };\n}\n\n\nThis allows testing the package easily:\n\n$ nix-build my-hello.nix\n$ ./result/bin/hello\nHello, world!\n\nUsing pre-built executables\n\nMost pre-built executables will not work on NixOS. There are two notable exceptions: flatpaks and AppImages. For flatpaks see the dedicated section. AppImages will not run “as-is” on NixOS. First you need to install appimage-run: add to /etc/nixos/configuration.nix\n\nenvironment.systemPackages = [ pkgs.appimage-run ];\n\n\nThen instead of running the AppImage “as-is”, run appimage-run foo.appimage.\n\nTo make other pre-built executables work on NixOS, you need to package them with Nix and special helpers like autoPatchelfHook or buildFHSEnv. See the Nixpkgs manual for details. This is complex and often doing a source build is easier.\n\nAd-Hoc Package Management \n\nWith the command nix-env, you can install and uninstall packages from the command line. For instance, to install Mozilla Thunderbird:\n\n$ nix-env -iA nixos.thunderbird\n\n\nIf you invoke this as root, the package is installed in the Nix profile /nix/var/nix/profiles/default and visible to all users of the system; otherwise, the package ends up in /nix/var/nix/profiles/per-user/username/profile and is not visible to other users. The -A flag specifies the package by its attribute name; without it, the package is installed by matching against its package name (e.g. thunderbird). The latter is slower because it requires matching against all available Nix packages, and is ambiguous if there are multiple matching packages.\n\nPackages come from the NixOS channel. You typically upgrade a package by updating to the latest version of the NixOS channel:\n\n$ nix-channel --update nixos\n\n\nand then running nix-env -i again. Other packages in the profile are not affected; this is the crucial difference with the declarative style of package management, where running nixos-rebuild switch causes all packages to be updated to their current versions in the NixOS channel. You can however upgrade all packages for which there is a newer version by doing:\n\n$ nix-env -u '*'\n\n\nA package can be uninstalled using the -e flag:\n\n$ nix-env -e thunderbird\n\n\nFinally, you can roll back an undesirable nix-env action:\n\n$ nix-env --rollback\n\n\nnix-env has many more flags. For details, see the nix-env(1) manpage or the Nix manual.\n\nUser Management \n\nNixOS supports both declarative and imperative styles of user management. In the declarative style, users are specified in configuration.nix. For instance, the following states that a user account named alice shall exist:\n\nusers.users.alice = {\n  isNormalUser = true;\n  home = \"/home/alice\";\n  description = \"Alice Foobar\";\n  extraGroups = [ \"wheel\" \"networkmanager\" ];\n  openssh.authorizedKeys.keys = [ \"ssh-dss AAAAB3Nza... alice@foobar\" ];\n};\n\n\nNote that alice is a member of the wheel and networkmanager groups, which allows her to use sudo to execute commands as root and to configure the network, respectively. Also note the SSH public key that allows remote logins with the corresponding private key. Users created in this way do not have a password by default, so they cannot log in via mechanisms that require a password. However, you can use the passwd program to set a password, which is retained across invocations of nixos-rebuild.\n\nIf you set users.mutableUsers to false, then the contents of /etc/passwd and /etc/group will be congruent to your NixOS configuration. For instance, if you remove a user from users.users and run nixos-rebuild, the user account will cease to exist. Also, imperative commands for managing users and groups, such as useradd, are no longer available. Passwords may still be assigned by setting the user’s hashedPassword option. A hashed password can be generated using mkpasswd.\n\nA user ID (uid) is assigned automatically. You can also specify a uid manually by adding\n\nuid = 1000;\n\n\nto the user specification.\n\nGroups can be specified similarly. The following states that a group named students shall exist:\n\nusers.groups.students.gid = 1000;\n\n\nAs with users, the group ID (gid) is optional and will be assigned automatically if it’s missing.\n\nIn the imperative style, users and groups are managed by commands such as useradd, groupmod and so on. For instance, to create a user account named alice:\n\n# useradd -m alice\n\n\nTo make all nix tools available to this new user use `su - USER` which opens a login shell (==shell that loads the profile) for given user. This will create the ~/.nix-defexpr symlink. So run:\n\n# su - alice -c \"true\"\n\n\nThe flag -m causes the creation of a home directory for the new user, which is generally what you want. The user does not have an initial password and therefore cannot log in. A password can be set using the passwd utility:\n\n# passwd alice\nEnter new UNIX password: ***\nRetype new UNIX password: ***\n\n\nA user can be deleted using userdel:\n\n# userdel -r alice\n\n\nThe flag -r deletes the user’s home directory. Accounts can be modified using usermod. Unix groups can be managed using groupadd, groupmod and groupdel.\n\nFile Systems \n\nTable of Contents\n\nLUKS-Encrypted File Systems\nSSHFS File Systems\n\nYou can define file systems using the fileSystems configuration option. For instance, the following definition causes NixOS to mount the Ext4 file system on device /dev/disk/by-label/data onto the mount point /data:\n\nfileSystems.\"/data\" =\n  { device = \"/dev/disk/by-label/data\";\n    fsType = \"ext4\";\n  };\n\n\nThis will create an entry in /etc/fstab, which will generate a corresponding systemd.mount unit via systemd-fstab-generator. The filesystem will be mounted automatically unless \"noauto\" is present in options. \"noauto\" filesystems can be mounted explicitly using systemctl e.g. systemctl start data.mount. Mount points are created automatically if they don’t already exist. For device, it’s best to use the topology-independent device aliases in /dev/disk/by-label and /dev/disk/by-uuid, as these don’t change if the topology changes (e.g. if a disk is moved to another IDE controller).\n\nYou can usually omit the file system type (fsType), since mount can usually detect the type and load the necessary kernel module automatically. However, if the file system is needed at early boot (in the initial ramdisk) and is not ext2, ext3 or ext4, then it’s best to specify fsType to ensure that the kernel module is available.\n\nNote\n\nSystem startup will fail if any of the filesystems fails to mount, dropping you to the emergency shell. You can make a mount asynchronous and non-critical by adding options = [ \"nofail\" ];.\n\nLUKS-Encrypted File Systems \n\nNixOS supports file systems that are encrypted using LUKS (Linux Unified Key Setup). For example, here is how you create an encrypted Ext4 file system on the device /dev/disk/by-uuid/3f6b0024-3a44-4fde-a43a-767b872abe5d:\n\n# cryptsetup luksFormat /dev/disk/by-uuid/3f6b0024-3a44-4fde-a43a-767b872abe5d\n\nWARNING!\n========\nThis will overwrite data on /dev/disk/by-uuid/3f6b0024-3a44-4fde-a43a-767b872abe5d irrevocably.\n\nAre you sure? (Type uppercase yes): YES\nEnter LUKS passphrase: ***\nVerify passphrase: ***\n\n# cryptsetup luksOpen /dev/disk/by-uuid/3f6b0024-3a44-4fde-a43a-767b872abe5d crypted\nEnter passphrase for /dev/disk/by-uuid/3f6b0024-3a44-4fde-a43a-767b872abe5d: ***\n\n# mkfs.ext4 /dev/mapper/crypted\n\n\nThe LUKS volume should be automatically picked up by nixos-generate-config, but you might want to verify that your hardware-configuration.nix looks correct. To manually ensure that the system is automatically mounted at boot time as /, add the following to configuration.nix:\n\nboot.initrd.luks.devices.crypted.device = \"/dev/disk/by-uuid/3f6b0024-3a44-4fde-a43a-767b872abe5d\";\nfileSystems.\"/\".device = \"/dev/mapper/crypted\";\n\n\nShould grub be used as bootloader, and /boot is located on an encrypted partition, it is necessary to add the following grub option:\n\nboot.loader.grub.enableCryptodisk = true;\n\nFIDO2 \n\nNixOS also supports unlocking your LUKS-Encrypted file system using a FIDO2 compatible token. In the following example, we will create a new FIDO2 credential and add it as a new key to our existing device /dev/sda2:\n\n# export FIDO2_LABEL=\"/dev/sda2 @ $HOSTNAME\"\n# fido2luks credential \"$FIDO2_LABEL\"\nf1d00200108b9d6e849a8b388da457688e3dd653b4e53770012d8f28e5d3b269865038c346802f36f3da7278b13ad6a3bb6a1452e24ebeeaa24ba40eef559b1b287d2a2f80b7\n\n# fido2luks -i add-key /dev/sda2 f1d00200108b9d6e849a8b388da457688e3dd653b4e53770012d8f28e5d3b269865038c346802f36f3da7278b13ad6a3bb6a1452e24ebeeaa24ba40eef559b1b287d2a2f80b7\nPassword:\nPassword (again):\nOld password:\nOld password (again):\nAdded to key to device /dev/sda2, slot: 2\n\n\nTo ensure that this file system is decrypted using the FIDO2 compatible key, add the following to configuration.nix:\n\nboot.initrd.luks.fido2Support = true;\nboot.initrd.luks.devices.\"/dev/sda2\".fido2.credential = \"f1d00200108b9d6e849a8b388da457688e3dd653b4e53770012d8f28e5d3b269865038c346802f36f3da7278b13ad6a3bb6a1452e24ebeeaa24ba40eef559b1b287d2a2f80b7\";\n\n\nYou can also use the FIDO2 passwordless setup, but for security reasons, you might want to enable it only when your device is PIN protected, such as Trezor.\n\nboot.initrd.luks.devices.\"/dev/sda2\".fido2.passwordLess = true;\n\nSSHFS File Systems \n\nSSHFS is a FUSE filesystem that allows easy access to directories on a remote machine using the SSH File Transfer Protocol (SFTP). It means that if you have SSH access to a machine, no additional setup is needed to mount a directory.\n\nInteractive mounting \n\nIn NixOS, SSHFS is packaged as sshfs. Once installed, mounting a directory interactively is simple as running:\n\n$ sshfs my-user@example.com:/my-dir /mnt/my-dir\n\n\nLike any other FUSE file system, the directory is unmounted using:\n\n$ fusermount -u /mnt/my-dir\n\nNon-interactive mounting \n\nMounting non-interactively requires some precautions because sshfs will run at boot and under a different user (root). For obvious reason, you can’t input a password, so public key authentication using an unencrypted key is needed. To create a new key without a passphrase you can do:\n\n$ ssh-keygen -t ed25519 -P '' -f example-key\nGenerating public/private ed25519 key pair.\nYour identification has been saved in test-key\nYour public key has been saved in test-key.pub\nThe key fingerprint is:\nSHA256:yjxl3UbTn31fLWeyLYTAKYJPRmzknjQZoyG8gSNEoIE my-user@workstation\n\n\nTo keep the key safe, change the ownership to root:root and make sure the permissions are 600: OpenSSH normally refuses to use the key if it’s not well-protected.\n\nThe file system can be configured in NixOS via the usual fileSystems option. Here’s a typical setup:\n\n{\n  system.fsPackages = [ pkgs.sshfs ];\n\n  fileSystems.\"/mnt/my-dir\" = {\n    device = \"my-user@example.com:/my-dir/\";\n    fsType = \"sshfs\";\n    options =\n      [ # Filesystem options\n        \"allow_other\"          # for non-root access\n        \"_netdev\"              # this is a network fs\n        \"x-systemd.automount\"  # mount on demand\n\n        # SSH options\n        \"reconnect\"              # handle connection drops\n        \"ServerAliveInterval=15\" # keep connections alive\n        \"IdentityFile=/var/secrets/example-key\"\n      ];\n  };\n}\n\n\nMore options from ssh_config(5) can be given as well, for example you can change the default SSH port or specify a jump proxy:\n\n{\n  options =\n    [ \"ProxyJump=bastion@example.com\"\n      \"Port=22\"\n    ];\n}\n\n\nIt’s also possible to change the ssh command used by SSHFS to connect to the server. For example:\n\n{\n  options =\n    [ (builtins.replaceStrings [\" \"] [\"\\\\040\"]\n        \"ssh_command=${pkgs.openssh}/bin/ssh -v -L 8080:localhost:80\")\n    ];\n\n}\n\nNote\n\nThe escaping of spaces is needed because every option is written to the /etc/fstab file, which is a space-separated table.\n\nTroubleshooting\n\nIf you’re having a hard time figuring out why mounting is failing, you can add the option \"debug\". This enables a verbose log in SSHFS that you can access via:\n\n$ journalctl -u $(systemd-escape -p /mnt/my-dir/).mount\nJun 22 11:41:18 workstation mount[87790]: SSHFS version 3.7.1\nJun 22 11:41:18 workstation mount[87793]: executing <ssh> <-x> <-a> <-oClearAllForwardings=yes> <-oServerAliveInterval=15> <-oIdentityFile=/var/secrets/wrong-key> <-2> <my-user@example.com> <-s> <sftp>\nJun 22 11:41:19 workstation mount[87793]: my-user@example.com: Permission denied (publickey).\nJun 22 11:41:19 workstation mount[87790]: read: Connection reset by peer\nJun 22 11:41:19 workstation systemd[1]: mnt-my\\x2ddir.mount: Mount process exited, code=exited, status=1/FAILURE\nJun 22 11:41:19 workstation systemd[1]: mnt-my\\x2ddir.mount: Failed with result 'exit-code'.\nJun 22 11:41:19 workstation systemd[1]: Failed to mount /mnt/my-dir.\nJun 22 11:41:19 workstation systemd[1]: mnt-my\\x2ddir.mount: Consumed 54ms CPU time, received 2.3K IP traffic, sent 2.7K IP traffic.\n\nNote\n\nIf the mount point contains special characters it needs to be escaped using systemd-escape. This is due to the way systemd converts paths into unit names.\n\nX Window System \n\nTable of Contents\n\nAuto-login\nIntel Graphics drivers\nProprietary NVIDIA drivers\nProprietary AMD drivers\nTouchpads\nGTK/Qt themes\nCustom XKB layouts\n\nThe X Window System (X11) provides the basis of NixOS’ graphical user interface. It can be enabled as follows:\n\nservices.xserver.enable = true;\n\n\nThe X server will automatically detect and use the appropriate video driver from a set of X.org drivers (such as vesa and intel). You can also specify a driver manually, e.g.\n\nservices.xserver.videoDrivers = [ \"r128\" ];\n\n\nto enable X.org’s xf86-video-r128 driver.\n\nYou also need to enable at least one desktop or window manager. Otherwise, you can only log into a plain undecorated xterm window. Thus you should pick one or more of the following lines:\n\nservices.xserver.desktopManager.plasma5.enable = true;\nservices.xserver.desktopManager.xfce.enable = true;\nservices.xserver.desktopManager.gnome.enable = true;\nservices.xserver.desktopManager.mate.enable = true;\nservices.xserver.windowManager.xmonad.enable = true;\nservices.xserver.windowManager.twm.enable = true;\nservices.xserver.windowManager.icewm.enable = true;\nservices.xserver.windowManager.i3.enable = true;\nservices.xserver.windowManager.herbstluftwm.enable = true;\n\n\nNixOS’s default display manager (the program that provides a graphical login prompt and manages the X server) is LightDM. You can select an alternative one by picking one of the following lines:\n\nservices.xserver.displayManager.sddm.enable = true;\nservices.xserver.displayManager.gdm.enable = true;\n\n\nYou can set the keyboard layout (and optionally the layout variant):\n\nservices.xserver.xkb.layout = \"de\";\nservices.xserver.xkb.variant = \"neo\";\n\n\nThe X server is started automatically at boot time. If you don’t want this to happen, you can set:\n\nservices.xserver.autorun = false;\n\n\nThe X server can then be started manually:\n\n# systemctl start display-manager.service\n\n\nOn 64-bit systems, if you want OpenGL for 32-bit programs such as in Wine, you should also set the following:\n\nhardware.opengl.driSupport32Bit = true;\n\nAuto-login \n\nThe x11 login screen can be skipped entirely, automatically logging you into your window manager and desktop environment when you boot your computer.\n\nThis is especially helpful if you have disk encryption enabled. Since you already have to provide a password to decrypt your disk, entering a second password to login can be redundant.\n\nTo enable auto-login, you need to define your default window manager and desktop environment. If you wanted no desktop environment and i3 as your your window manager, you’d define:\n\nservices.xserver.displayManager.defaultSession = \"none+i3\";\n\n\nEvery display manager in NixOS supports auto-login, here is an example using lightdm for a user alice:\n\nservices.xserver.displayManager.lightdm.enable = true;\nservices.xserver.displayManager.autoLogin.enable = true;\nservices.xserver.displayManager.autoLogin.user = \"alice\";\n\nIntel Graphics drivers \n\nThere are two choices for Intel Graphics drivers in X.org: modesetting (included in the xorg-server itself) and intel (provided by the package xf86-video-intel).\n\nThe default and recommended is modesetting. It is a generic driver which uses the kernel mode setting (KMS) mechanism. It supports Glamor (2D graphics acceleration via OpenGL) and is actively maintained but may perform worse in some cases (like in old chipsets).\n\nThe second driver, intel, is specific to Intel GPUs, but not recommended by most distributions: it lacks several modern features (for example, it doesn’t support Glamor) and the package hasn’t been officially updated since 2015.\n\nThe results vary depending on the hardware, so you may have to try both drivers. Use the option services.xserver.videoDrivers to set one. The recommended configuration for modern systems is:\n\nservices.xserver.videoDrivers = [ \"modesetting\" ];\n\n\nIf you experience screen tearing no matter what, this configuration was reported to resolve the issue:\n\nservices.xserver.videoDrivers = [ \"intel\" ];\nservices.xserver.deviceSection = ''\n  Option \"DRI\" \"2\"\n  Option \"TearFree\" \"true\"\n'';\n\n\nNote that this will likely downgrade the performance compared to modesetting or intel with DRI 3 (default).\n\nProprietary NVIDIA drivers \n\nNVIDIA provides a proprietary driver for its graphics cards that has better 3D performance than the X.org drivers. It is not enabled by default because it’s not free software. You can enable it as follows:\n\nservices.xserver.videoDrivers = [ \"nvidia\" ];\n\n\nOr if you have an older card, you may have to use one of the legacy drivers:\n\nservices.xserver.videoDrivers = [ \"nvidiaLegacy390\" ];\nservices.xserver.videoDrivers = [ \"nvidiaLegacy340\" ];\nservices.xserver.videoDrivers = [ \"nvidiaLegacy304\" ];\n\n\nYou may need to reboot after enabling this driver to prevent a clash with other kernel modules.\n\nProprietary AMD drivers \n\nAMD provides a proprietary driver for its graphics cards that is not enabled by default because it’s not Free Software, is often broken in nixpkgs and as of this writing doesn’t offer more features or performance. If you still want to use it anyway, you need to explicitly set:\n\nservices.xserver.videoDrivers = [ \"amdgpu-pro\" ];\n\n\nYou will need to reboot after enabling this driver to prevent a clash with other kernel modules.\n\nTouchpads \n\nSupport for Synaptics touchpads (found in many laptops such as the Dell Latitude series) can be enabled as follows:\n\nservices.xserver.libinput.enable = true;\n\n\nThe driver has many options (see Appendix A). For instance, the following disables tap-to-click behavior:\n\nservices.xserver.libinput.touchpad.tapping = false;\n\n\nNote: the use of services.xserver.synaptics is deprecated since NixOS 17.09.\n\nGTK/Qt themes \n\nGTK themes can be installed either to user profile or system-wide (via environment.systemPackages). To make Qt 5 applications look similar to GTK ones, you can use the following configuration:\n\nqt.enable = true;\nqt.platformTheme = \"gtk2\";\nqt.style = \"gtk2\";\n\nCustom XKB layouts \n\nIt is possible to install custom XKB keyboard layouts using the option services.xserver.xkb.extraLayouts.\n\nAs a first example, we are going to create a layout based on the basic US layout, with an additional layer to type some greek symbols by pressing the right-alt key.\n\nCreate a file called us-greek with the following content (under a directory called symbols; it’s an XKB peculiarity that will help with testing):\n\nxkb_symbols \"us-greek\"\n{\n  include \"us(basic)\"            // includes the base US keys\n  include \"level3(ralt_switch)\"  // configures right alt as a third level switch\n\n  key <LatA> { [ a, A, Greek_alpha ] };\n  key <LatB> { [ b, B, Greek_beta  ] };\n  key <LatG> { [ g, G, Greek_gamma ] };\n  key <LatD> { [ d, D, Greek_delta ] };\n  key <LatZ> { [ z, Z, Greek_zeta  ] };\n};\n\n\nA minimal layout specification must include the following:\n\nservices.xserver.xkb.extraLayouts.us-greek = {\n  description = \"US layout with alt-gr greek\";\n  languages   = [ \"eng\" ];\n  symbolsFile = /yourpath/symbols/us-greek;\n};\n\nNote\n\nThe name (after extraLayouts.) should match the one given to the xkb_symbols block.\n\nApplying this customization requires rebuilding several packages, and a broken XKB file can lead to the X session crashing at login. Therefore, you’re strongly advised to test your layout before applying it:\n\n$ nix-shell -p xorg.xkbcomp\n$ setxkbmap -I/yourpath us-greek -print | xkbcomp -I/yourpath - $DISPLAY\n\n\nYou can inspect the predefined XKB files for examples:\n\n$ echo \"$(nix-build --no-out-link '<nixpkgs>' -A xorg.xkeyboardconfig)/etc/X11/xkb/\"\n\n\nOnce the configuration is applied, and you did a logout/login cycle, the layout should be ready to use. You can try it by e.g. running setxkbmap us-greek and then type <alt>+a (it may not get applied in your terminal straight away). To change the default, the usual services.xserver.xkb.layout option can still be used.\n\nA layout can have several other components besides xkb_symbols, for example we will define new keycodes for some multimedia key and bind these to some symbol.\n\nUse the xev utility from pkgs.xorg.xev to find the codes of the keys of interest, then create a media-key file to hold the keycodes definitions\n\nxkb_keycodes \"media\"\n{\n <volUp>   = 123;\n <volDown> = 456;\n}\n\n\nNow use the newly define keycodes in media-sym:\n\nxkb_symbols \"media\"\n{\n key.type = \"ONE_LEVEL\";\n key <volUp>   { [ XF86AudioLowerVolume ] };\n key <volDown> { [ XF86AudioRaiseVolume ] };\n}\n\n\nAs before, to install the layout do\n\nservices.xserver.xkb.extraLayouts.media = {\n  description  = \"Multimedia keys remapping\";\n  languages    = [ \"eng\" ];\n  symbolsFile  = /path/to/media-key;\n  keycodesFile = /path/to/media-sym;\n};\n\nNote\n\nThe function pkgs.writeText <filename> <content> can be useful if you prefer to keep the layout definitions inside the NixOS configuration.\n\nUnfortunately, the Xorg server does not (currently) support setting a keymap directly but relies instead on XKB rules to select the matching components (keycodes, types, …) of a layout. This means that components other than symbols won’t be loaded by default. As a workaround, you can set the keymap using setxkbmap at the start of the session with:\n\nservices.xserver.displayManager.sessionCommands = \"setxkbmap -keycodes media\";\n\n\nIf you are manually starting the X server, you should set the argument -xkbdir /etc/X11/xkb, otherwise X won’t find your layout files. For example with xinit run\n\n$ xinit -- -xkbdir /etc/X11/xkb\n\n\nTo learn how to write layouts take a look at the XKB documentation . More example layouts can also be found here .\n\nWayland \n\nWhile X11 (see X Window System) is still the primary display technology on NixOS, Wayland support is steadily improving. Where X11 separates the X Server and the window manager, on Wayland those are combined: a Wayland Compositor is like an X11 window manager, but also embeds the Wayland ‘Server’ functionality. This means it is sufficient to install a Wayland Compositor such as sway without separately enabling a Wayland server:\n\nprograms.sway.enable = true;\n\n\nThis installs the sway compositor along with some essential utilities. Now you can start sway from the TTY console.\n\nIf you are using a wlroots-based compositor, like sway, and want to be able to share your screen, you might want to activate this option:\n\nxdg.portal.wlr.enable = true;\n\n\nand configure Pipewire using services.pipewire.enable and related options.\n\nGPU acceleration \n\nTable of Contents\n\nOpenCL\nVulkan\nVA-API\nCommon issues\n\nNixOS provides various APIs that benefit from GPU hardware acceleration, such as VA-API and VDPAU for video playback; OpenGL and Vulkan for 3D graphics; and OpenCL for general-purpose computing. This chapter describes how to set up GPU hardware acceleration (as far as this is not done automatically) and how to verify that hardware acceleration is indeed used.\n\nMost of the aforementioned APIs are agnostic with regards to which display server is used. Consequently, these instructions should apply both to the X Window System and Wayland compositors.\n\nOpenCL \n\nOpenCL is a general compute API. It is used by various applications such as Blender and Darktable to accelerate certain operations.\n\nOpenCL applications load drivers through the Installable Client Driver (ICD) mechanism. In this mechanism, an ICD file specifies the path to the OpenCL driver for a particular GPU family. In NixOS, there are two ways to make ICD files visible to the ICD loader. The first is through the OCL_ICD_VENDORS environment variable. This variable can contain a directory which is scanned by the ICL loader for ICD files. For example:\n\n$ export \\\n  OCL_ICD_VENDORS=`nix-build '<nixpkgs>' --no-out-link -A rocmPackages.clr.icd`/etc/OpenCL/vendors/\n\n\nThe second mechanism is to add the OpenCL driver package to hardware.opengl.extraPackages. This links the ICD file under /run/opengl-driver, where it will be visible to the ICD loader.\n\nThe proper installation of OpenCL drivers can be verified through the clinfo command of the clinfo package. This command will report the number of hardware devices that is found and give detailed information for each device:\n\n$ clinfo | head -n3\nNumber of platforms  1\nPlatform Name        AMD Accelerated Parallel Processing\nPlatform Vendor      Advanced Micro Devices, Inc.\n\nAMD \n\nModern AMD Graphics Core Next (GCN) GPUs are supported through the rocmPackages.clr.icd package. Adding this package to hardware.opengl.extraPackages enables OpenCL support:\n\nhardware.opengl.extraPackages = [\n  rocmPackages.clr.icd\n];\n\nIntel \n\nIntel Gen8 and later GPUs are supported by the Intel NEO OpenCL runtime that is provided by the intel-compute-runtime package. For Gen7 GPUs, the deprecated Beignet runtime can be used, which is provided by the beignet package. The proprietary Intel OpenCL runtime, in the intel-ocl package, is an alternative for Gen7 GPUs.\n\nThe intel-compute-runtime, beignet, or intel-ocl package can be added to hardware.opengl.extraPackages to enable OpenCL support. For example, for Gen8 and later GPUs, the following configuration can be used:\n\nhardware.opengl.extraPackages = [\n  intel-compute-runtime\n];\n\nVulkan \n\nVulkan is a graphics and compute API for GPUs. It is used directly by games or indirectly though compatibility layers like DXVK.\n\nBy default, if hardware.opengl.driSupport is enabled, mesa is installed and provides Vulkan for supported hardware.\n\nSimilar to OpenCL, Vulkan drivers are loaded through the Installable Client Driver (ICD) mechanism. ICD files for Vulkan are JSON files that specify the path to the driver library and the supported Vulkan version. All successfully loaded drivers are exposed to the application as different GPUs. In NixOS, there are two ways to make ICD files visible to Vulkan applications: an environment variable and a module option.\n\nThe first option is through the VK_ICD_FILENAMES environment variable. This variable can contain multiple JSON files, separated by :. For example:\n\n$ export \\\n  VK_ICD_FILENAMES=`nix-build '<nixpkgs>' --no-out-link -A amdvlk`/share/vulkan/icd.d/amd_icd64.json\n\n\nThe second mechanism is to add the Vulkan driver package to hardware.opengl.extraPackages. This links the ICD file under /run/opengl-driver, where it will be visible to the ICD loader.\n\nThe proper installation of Vulkan drivers can be verified through the vulkaninfo command of the vulkan-tools package. This command will report the hardware devices and drivers found, in this example output amdvlk and radv:\n\n$ vulkaninfo | grep GPU\n                GPU id  : 0 (Unknown AMD GPU)\n                GPU id  : 1 (AMD RADV NAVI10 (LLVM 9.0.1))\n     ...\nGPU0:\n        deviceType     = PHYSICAL_DEVICE_TYPE_DISCRETE_GPU\n        deviceName     = Unknown AMD GPU\nGPU1:\n        deviceType     = PHYSICAL_DEVICE_TYPE_DISCRETE_GPU\n\n\nA simple graphical application that uses Vulkan is vkcube from the vulkan-tools package.\n\nAMD \n\nModern AMD Graphics Core Next (GCN) GPUs are supported through either radv, which is part of mesa, or the amdvlk package. Adding the amdvlk package to hardware.opengl.extraPackages makes amdvlk the default driver and hides radv and lavapipe from the device list. A specific driver can be forced as follows:\n\nhardware.opengl.extraPackages = [\n  pkgs.amdvlk\n];\n\n# To enable Vulkan support for 32-bit applications, also add:\nhardware.opengl.extraPackages32 = [\n  pkgs.driversi686Linux.amdvlk\n];\n\n# Force radv\nenvironment.variables.AMD_VULKAN_ICD = \"RADV\";\n# Or\nenvironment.variables.VK_ICD_FILENAMES =\n  \"/run/opengl-driver/share/vulkan/icd.d/radeon_icd.x86_64.json\";\n\nVA-API \n\nVA-API (Video Acceleration API) is an open-source library and API specification, which provides access to graphics hardware acceleration capabilities for video processing.\n\nVA-API drivers are loaded by libva. The version in nixpkgs is built to search the opengl driver path, so drivers can be installed in hardware.opengl.extraPackages.\n\nVA-API can be tested using:\n\n$ nix-shell -p libva-utils --run vainfo\n\nIntel \n\nModern Intel GPUs use the iHD driver, which can be installed with:\n\nhardware.opengl.extraPackages = [\n  intel-media-driver\n];\n\n\nOlder Intel GPUs use the i965 driver, which can be installed with:\n\nhardware.opengl.extraPackages = [\n  intel-vaapi-driver\n];\n\nCommon issues \nUser permissions \n\nExcept where noted explicitly, it should not be necessary to adjust user permissions to use these acceleration APIs. In the default configuration, GPU devices have world-read/write permissions (/dev/dri/renderD*) or are tagged as uaccess (/dev/dri/card*). The access control lists of devices with the uaccess tag will be updated automatically when a user logs in through systemd-logind. For example, if the user alice is logged in, the access control list should look as follows:\n\n$ getfacl /dev/dri/card0\n# file: dev/dri/card0\n# owner: root\n# group: video\nuser::rw-\nuser:alice:rw-\ngroup::rw-\nmask::rw-\nother::---\n\n\nIf you disabled (this functionality of) systemd-logind, you may need to add the user to the video group and log in again.\n\nMixing different versions of nixpkgs \n\nThe Installable Client Driver (ICD) mechanism used by OpenCL and Vulkan loads runtimes into its address space using dlopen. Mixing an ICD loader mechanism and runtimes from different version of nixpkgs may not work. For example, if the ICD loader uses an older version of glibc than the runtime, the runtime may not be loadable due to missing symbols. Unfortunately, the loader will generally be quiet about such issues.\n\nIf you suspect that you are running into library version mismatches between an ICL loader and a runtime, you could run an application with the LD_DEBUG variable set to get more diagnostic information. For example, OpenCL can be tested with LD_DEBUG=files clinfo, which should report missing symbols.\n\nXfce Desktop Environment \n\nTable of Contents\n\nThunar\nTroubleshooting\n\nTo enable the Xfce Desktop Environment, set\n\nservices.xserver.desktopManager.xfce.enable = true;\nservices.xserver.displayManager.defaultSession = \"xfce\";\n\n\nOptionally, picom can be enabled for nice graphical effects, some example settings:\n\nservices.picom = {\n  enable = true;\n  fade = true;\n  inactiveOpacity = 0.9;\n  shadow = true;\n  fadeDelta = 4;\n};\n\n\nSome Xfce programs are not installed automatically. To install them manually (system wide), put them into your environment.systemPackages from pkgs.xfce.\n\nThunar \n\nThunar (the Xfce file manager) is automatically enabled when Xfce is enabled. To enable Thunar without enabling Xfce, use the configuration option programs.thunar.enable instead of adding pkgs.xfce.thunar to environment.systemPackages.\n\nIf you’d like to add extra plugins to Thunar, add them to programs.thunar.plugins. You shouldn’t just add them to environment.systemPackages.\n\nTroubleshooting \n\nEven after enabling udisks2, volume management might not work. Thunar and/or the desktop takes time to show up. Thunar will spit out this kind of message on start (look at journalctl --user -b).\n\nThunar:2410): GVFS-RemoteVolumeMonitor-WARNING **: remote volume monitor with dbus name org.gtk.Private.UDisks2VolumeMonitor is not supported\n\n\nThis is caused by some needed GNOME services not running. This is all fixed by enabling “Launch GNOME services on startup” in the Advanced tab of the Session and Startup settings panel. Alternatively, you can run this command to do the same thing.\n\n$ xfconf-query -c xfce4-session -p /compat/LaunchGNOME -s true\n\n\nIt is necessary to log out and log in again for this to take effect.\n\nNetworking \n\nTable of Contents\n\nNetworkManager\nSecure Shell Access\nIPv4 Configuration\nIPv6 Configuration\nFirewall\nWireless Networks\nAd-Hoc Configuration\nRenaming network interfaces\n\nThis section describes how to configure networking components on your NixOS machine.\n\nNetworkManager \n\nTo facilitate network configuration, some desktop environments use NetworkManager. You can enable NetworkManager by setting:\n\nnetworking.networkmanager.enable = true;\n\n\nsome desktop managers (e.g., GNOME) enable NetworkManager automatically for you.\n\nAll users that should have permission to change network settings must belong to the networkmanager group:\n\nusers.users.alice.extraGroups = [ \"networkmanager\" ];\n\n\nNetworkManager is controlled using either nmcli or nmtui (curses-based terminal user interface). See their manual pages for details on their usage. Some desktop environments (GNOME, KDE) have their own configuration tools for NetworkManager. On XFCE, there is no configuration tool for NetworkManager by default: by enabling programs.nm-applet.enable, the graphical applet will be installed and will launch automatically when the graphical session is started.\n\nNote\n\nnetworking.networkmanager and networking.wireless (WPA Supplicant) can be used together if desired. To do this you need to instruct NetworkManager to ignore those interfaces like:\n\nnetworking.networkmanager.unmanaged = [\n   \"*\" \"except:type:wwan\" \"except:type:gsm\"\n];\n\n\nRefer to the option description for the exact syntax and references to external documentation.\n\nSecure Shell Access \n\nSecure shell (SSH) access to your machine can be enabled by setting:\n\nservices.openssh.enable = true;\n\n\nBy default, root logins using a password are disallowed. They can be disabled entirely by setting services.openssh.settings.PermitRootLogin to \"no\".\n\nYou can declaratively specify authorised RSA/DSA public keys for a user as follows:\n\nusers.users.alice.openssh.authorizedKeys.keys =\n  [ \"ssh-dss AAAAB3NzaC1kc3MAAACBAPIkGWVEt4...\" ];\n\nIPv4 Configuration \n\nBy default, NixOS uses DHCP (specifically, dhcpcd) to automatically configure network interfaces. However, you can configure an interface manually as follows:\n\nnetworking.interfaces.eth0.ipv4.addresses = [ {\n  address = \"192.168.1.2\";\n  prefixLength = 24;\n} ];\n\n\nTypically you’ll also want to set a default gateway and set of name servers:\n\nnetworking.defaultGateway = \"192.168.1.1\";\nnetworking.nameservers = [ \"8.8.8.8\" ];\n\nNote\n\nStatically configured interfaces are set up by the systemd service interface-name-cfg.service. The default gateway and name server configuration is performed by network-setup.service.\n\nThe host name is set using networking.hostName:\n\nnetworking.hostName = \"cartman\";\n\n\nThe default host name is nixos. Set it to the empty string (\"\") to allow the DHCP server to provide the host name.\n\nIPv6 Configuration \n\nIPv6 is enabled by default. Stateless address autoconfiguration is used to automatically assign IPv6 addresses to all interfaces, and Privacy Extensions (RFC 4946) are enabled by default. You can adjust the default for this by setting networking.tempAddresses. This option may be overridden on a per-interface basis by networking.interfaces.<name>.tempAddress. You can disable IPv6 support globally by setting:\n\nnetworking.enableIPv6 = false;\n\n\nYou can disable IPv6 on a single interface using a normal sysctl (in this example, we use interface eth0):\n\nboot.kernel.sysctl.\"net.ipv6.conf.eth0.disable_ipv6\" = true;\n\n\nAs with IPv4 networking interfaces are automatically configured via DHCPv6. You can configure an interface manually:\n\nnetworking.interfaces.eth0.ipv6.addresses = [ {\n  address = \"fe00:aa:bb:cc::2\";\n  prefixLength = 64;\n} ];\n\n\nFor configuring a gateway, optionally with explicitly specified interface:\n\nnetworking.defaultGateway6 = {\n  address = \"fe00::1\";\n  interface = \"enp0s3\";\n};\n\n\nSee the section called “IPv4 Configuration” for similar examples and additional information.\n\nFirewall \n\nNixOS has a simple stateful firewall that blocks incoming connections and other unexpected packets. The firewall applies to both IPv4 and IPv6 traffic. It is enabled by default. It can be disabled as follows:\n\nnetworking.firewall.enable = false;\n\n\nIf the firewall is enabled, you can open specific TCP ports to the outside world:\n\nnetworking.firewall.allowedTCPPorts = [ 80 443 ];\n\n\nNote that TCP port 22 (ssh) is opened automatically if the SSH daemon is enabled (services.openssh.enable = true). UDP ports can be opened through networking.firewall.allowedUDPPorts.\n\nTo open ranges of TCP ports:\n\nnetworking.firewall.allowedTCPPortRanges = [\n  { from = 4000; to = 4007; }\n  { from = 8000; to = 8010; }\n];\n\n\nSimilarly, UDP port ranges can be opened through networking.firewall.allowedUDPPortRanges.\n\nWireless Networks \n\nFor a desktop installation using NetworkManager (e.g., GNOME), you just have to make sure the user is in the networkmanager group and you can skip the rest of this section on wireless networks.\n\nNixOS will start wpa_supplicant for you if you enable this setting:\n\nnetworking.wireless.enable = true;\n\n\nNixOS lets you specify networks for wpa_supplicant declaratively:\n\nnetworking.wireless.networks = {\n  echelon = {                # SSID with no spaces or special characters\n    psk = \"abcdefgh\";\n  };\n  \"echelon's AP\" = {         # SSID with spaces and/or special characters\n    psk = \"ijklmnop\";\n  };\n  echelon = {                # Hidden SSID\n    hidden = true;\n    psk = \"qrstuvwx\";\n  };\n  free.wifi = {};            # Public wireless network\n};\n\n\nBe aware that keys will be written to the nix store in plaintext! When no networks are set, it will default to using a configuration file at /etc/wpa_supplicant.conf. You should edit this file yourself to define wireless networks, WPA keys and so on (see wpa_supplicant.conf(5)).\n\nIf you are using WPA2 you can generate pskRaw key using wpa_passphrase:\n\n$ wpa_passphrase ESSID PSK\nnetwork={\n        ssid=\"echelon\"\n        #psk=\"abcdefgh\"\n        psk=dca6d6ed41f4ab5a984c9f55f6f66d4efdc720ebf66959810f4329bb391c5435\n}\n\nnetworking.wireless.networks = {\n  echelon = {\n    pskRaw = \"dca6d6ed41f4ab5a984c9f55f6f66d4efdc720ebf66959810f4329bb391c5435\";\n  };\n};\n\n\nor you can use it to directly generate the wpa_supplicant.conf:\n\n# wpa_passphrase ESSID PSK > /etc/wpa_supplicant.conf\n\n\nAfter you have edited the wpa_supplicant.conf, you need to restart the wpa_supplicant service.\n\n# systemctl restart wpa_supplicant.service\n\nAd-Hoc Configuration \n\nYou can use networking.localCommands to specify shell commands to be run at the end of network-setup.service. This is useful for doing network configuration not covered by the existing NixOS modules. For instance, to statically configure an IPv6 address:\n\nnetworking.localCommands =\n  ''\n    ip -6 addr add 2001:610:685:1::1/64 dev eth0\n  '';\n\nRenaming network interfaces \n\nNixOS uses the udev predictable naming scheme to assign names to network interfaces. This means that by default cards are not given the traditional names like eth0 or eth1, whose order can change unpredictably across reboots. Instead, relying on physical locations and firmware information, the scheme produces names like ens1, enp2s0, etc.\n\nThese names are predictable but less memorable and not necessarily stable: for example installing new hardware or changing firmware settings can result in a name change. If this is undesirable, for example if you have a single ethernet card, you can revert to the traditional scheme by setting networking.usePredictableInterfaceNames to false.\n\nAssigning custom names \n\nIn case there are multiple interfaces of the same type, it’s better to assign custom names based on the device hardware address. For example, we assign the name wan to the interface with MAC address 52:54:00:12:01:01 using a netword link unit:\n\nsystemd.network.links.\"10-wan\" = {\n  matchConfig.PermanentMACAddress = \"52:54:00:12:01:01\";\n  linkConfig.Name = \"wan\";\n};\n\n\nNote that links are directly read by udev, not networkd, and will work even if networkd is disabled.\n\nAlternatively, we can use a plain old udev rule:\n\nboot.initrd.services.udev.rules = ''\n  SUBSYSTEM==\"net\", ACTION==\"add\", DRIVERS==\"?*\", \\\n  ATTR{address}==\"52:54:00:12:01:01\", KERNEL==\"eth*\", NAME=\"wan\"\n'';\n\nWarning\n\nThe rule must be installed in the initrd using boot.initrd.services.udev.rules, not the usual services.udev.extraRules option. This is to avoid race conditions with other programs controlling the interface.\n\nLinux Kernel \n\nTable of Contents\n\nBuilding a custom kernel\nDeveloping kernel modules\nZFS\n\nYou can override the Linux kernel and associated packages using the option boot.kernelPackages. For instance, this selects the Linux 3.10 kernel:\n\nboot.kernelPackages = pkgs.linuxKernel.packages.linux_3_10;\n\n\nNote that this not only replaces the kernel, but also packages that are specific to the kernel version, such as the NVIDIA video drivers. This ensures that driver packages are consistent with the kernel.\n\nWhile pkgs.linuxKernel.packages contains all available kernel packages, you may want to use one of the unversioned pkgs.linuxPackages_* aliases such as pkgs.linuxPackages_latest, that are kept up to date with new versions.\n\nPlease note that the current convention in NixOS is to only keep actively maintained kernel versions on both unstable and the currently supported stable release(s) of NixOS. This means that a non-longterm kernel will be removed after it’s abandoned by the kernel developers, even on stable NixOS versions. If you pin your kernel onto a non-longterm version, expect your evaluation to fail as soon as the version is out of maintenance.\n\nLongterm versions of kernels will be removed before the next stable NixOS that will exceed the maintenance period of the kernel version.\n\nThe default Linux kernel configuration should be fine for most users. You can see the configuration of your current kernel with the following command:\n\nzcat /proc/config.gz\n\n\nIf you want to change the kernel configuration, you can use the packageOverrides feature (see the section called “Customising Packages”). For instance, to enable support for the kernel debugger KGDB:\n\nnixpkgs.config.packageOverrides = pkgs: pkgs.lib.recursiveUpdate pkgs {\n  linuxKernel.kernels.linux_5_10 = pkgs.linuxKernel.kernels.linux_5_10.override {\n    extraConfig = ''\n      KGDB y\n    '';\n  };\n};\n\n\nextraConfig takes a list of Linux kernel configuration options, one per line. The name of the option should not include the prefix CONFIG_. The option value is typically y, n or m (to build something as a kernel module).\n\nKernel modules for hardware devices are generally loaded automatically by udev. You can force a module to be loaded via boot.kernelModules, e.g.\n\nboot.kernelModules = [ \"fuse\" \"kvm-intel\" \"coretemp\" ];\n\n\nIf the module is required early during the boot (e.g. to mount the root file system), you can use boot.initrd.kernelModules:\n\nboot.initrd.kernelModules = [ \"cifs\" ];\n\n\nThis causes the specified modules and their dependencies to be added to the initial ramdisk.\n\nKernel runtime parameters can be set through boot.kernel.sysctl, e.g.\n\nboot.kernel.sysctl.\"net.ipv4.tcp_keepalive_time\" = 120;\n\n\nsets the kernel’s TCP keepalive time to 120 seconds. To see the available parameters, run sysctl -a.\n\nBuilding a custom kernel \n\nYou can customize the default kernel configuration by overriding the arguments for your kernel package:\n\npkgs.linux_latest.override {\n  ignoreConfigErrors = true;\n  autoModules = false;\n  kernelPreferBuiltin = true;\n  extraStructuredConfig = with lib.kernel; {\n    DEBUG_KERNEL = yes;\n    FRAME_POINTER = yes;\n    KGDB = yes;\n    KGDB_SERIAL_CONSOLE = yes;\n    DEBUG_INFO = yes;\n  };\n}\n\n\nSee pkgs/os-specific/linux/kernel/generic.nix for details on how these arguments affect the generated configuration. You can also build a custom version of Linux by calling pkgs.buildLinux directly, which requires the src and version arguments to be specified.\n\nTo use your custom kernel package in your NixOS configuration, set\n\nboot.kernelPackages = pkgs.linuxPackagesFor yourCustomKernel;\n\n\nNote that this method will use the common configuration defined in pkgs/os-specific/linux/kernel/common-config.nix, which is suitable for a NixOS system.\n\nIf you already have a generated configuration file, you can build a kernel that uses it with pkgs.linuxManualConfig:\n\nlet\n  baseKernel = pkgs.linux_latest;\nin pkgs.linuxManualConfig {\n  inherit (baseKernel) src modDirVersion;\n  version = \"${baseKernel.version}-custom\";\n  configfile = ./my_kernel_config;\n  allowImportFromDerivation = true;\n}\n\nNote\n\nThe build will fail if modDirVersion does not match the source’s kernel.release file, so modDirVersion should remain tied to src.\n\nTo edit the .config file for Linux X.Y, proceed as follows:\n\n$ nix-shell '<nixpkgs>' -A linuxKernel.kernels.linux_X_Y.configEnv\n$ unpackPhase\n$ cd linux-*\n$ make nconfig\n\nDeveloping kernel modules \n\nWhen developing kernel modules it’s often convenient to run edit-compile-run loop as quickly as possible. See below snippet as an example of developing mellanox drivers.\n\n$ nix-build '<nixpkgs>' -A linuxPackages.kernel.dev\n$ nix-shell '<nixpkgs>' -A linuxPackages.kernel\n$ unpackPhase\n$ cd linux-*\n$ make -C $dev/lib/modules/*/build M=$(pwd)/drivers/net/ethernet/mellanox modules\n# insmod ./drivers/net/ethernet/mellanox/mlx5/core/mlx5_core.ko\n\nZFS \n\nIt’s a common issue that the latest stable version of ZFS doesn’t support the latest available Linux kernel. It is recommended to use the latest available LTS that’s compatible with ZFS. Usually this is the default kernel provided by nixpkgs (i.e. pkgs.linuxPackages).\n\nAlternatively, it’s possible to pin the system to the latest available kernel version that is supported by ZFS like this:\n\n{\n  boot.kernelPackages = pkgs.zfs.latestCompatibleLinuxPackages;\n}\n\n\nPlease note that the version this attribute points to isn’t monotonic because the latest kernel version only refers to kernel versions supported by the Linux developers. In other words, the latest kernel version that ZFS is compatible with may decrease over time.\n\nAn example: the latest version ZFS is compatible with is 5.19 which is a non-longterm version. When 5.19 is out of maintenance, the latest supported kernel version is 5.15 because it’s longterm and the versions 5.16, 5.17 and 5.18 are already out of maintenance because they’re non-longterm.\n\nSubversion \n\nTable of Contents\n\nSubversion inside Apache HTTP\n\nSubversion is a centralized version-control system. It can use a variety of protocols for communication between client and server.\n\nSubversion inside Apache HTTP \n\nThis section focuses on configuring a web-based server on top of the Apache HTTP server, which uses WebDAV/DeltaV for communication.\n\nFor more information on the general setup, please refer to the the appropriate section of the Subversion book.\n\nTo configure, include in /etc/nixos/configuration.nix code to activate Apache HTTP, setting services.httpd.adminAddr appropriately:\n\nservices.httpd.enable = true;\nservices.httpd.adminAddr = ...;\nnetworking.firewall.allowedTCPPorts = [ 80 443 ];\n\n\nFor a simple Subversion server with basic authentication, configure the Subversion module for Apache as follows, setting hostName and documentRoot appropriately, and SVNParentPath to the parent directory of the repositories, AuthzSVNAccessFile to the location of the .authz file describing access permission, and AuthUserFile to the password file.\n\nservices.httpd.extraModules = [\n    # note that order is *super* important here\n    { name = \"dav_svn\"; path = \"${pkgs.apacheHttpdPackages.subversion}/modules/mod_dav_svn.so\"; }\n    { name = \"authz_svn\"; path = \"${pkgs.apacheHttpdPackages.subversion}/modules/mod_authz_svn.so\"; }\n  ];\n  services.httpd.virtualHosts = {\n    \"svn\" = {\n       hostName = HOSTNAME;\n       documentRoot = DOCUMENTROOT;\n       locations.\"/svn\".extraConfig = ''\n           DAV svn\n           SVNParentPath REPO_PARENT\n           AuthzSVNAccessFile ACCESS_FILE\n           AuthName \"SVN Repositories\"\n           AuthType Basic\n           AuthUserFile PASSWORD_FILE\n           Require valid-user\n      '';\n    }\n\n\nThe key \"svn\" is just a symbolic name identifying the virtual host. The \"/svn\" in locations.\"/svn\".extraConfig is the path underneath which the repositories will be served.\n\nThis page explains how to set up the Subversion configuration itself. This boils down to the following:\n\nUnderneath REPO_PARENT repositories can be set up as follows:\n\n$ svn create REPO_NAME\n\n\nRepository files need to be accessible by wwwrun:\n\n$ chown -R wwwrun:wwwrun REPO_PARENT\n\n\nThe password file PASSWORD_FILE can be created as follows:\n\n$ htpasswd -cs PASSWORD_FILE USER_NAME\n\n\nAdditional users can be set up similarly, omitting the c flag:\n\n$ htpasswd -s PASSWORD_FILE USER_NAME\n\n\nThe file describing access permissions ACCESS_FILE will look something like the following:\n\n[/]\n* = r\n\n[REPO_NAME:/]\nUSER_NAME = rw\n\n\nThe Subversion repositories will be accessible as http://HOSTNAME/svn/REPO_NAME.\n\nPantheon Desktop \n\nTable of Contents\n\nEnabling Pantheon\nWingpanel and Switchboard plugins\nFAQ\n\nPantheon is the desktop environment created for the elementary OS distribution. It is written from scratch in Vala, utilizing GNOME technologies with GTK and Granite.\n\nEnabling Pantheon \n\nAll of Pantheon is working in NixOS and the applications should be available, aside from a few exceptions. To enable Pantheon, set\n\nservices.xserver.desktopManager.pantheon.enable = true;\n\n\nThis automatically enables LightDM and Pantheon’s LightDM greeter. If you’d like to disable this, set\n\nservices.xserver.displayManager.lightdm.greeters.pantheon.enable = false;\nservices.xserver.displayManager.lightdm.enable = false;\n\n\nbut please be aware using Pantheon without LightDM as a display manager will break screenlocking from the UI. The NixOS module for Pantheon installs all of Pantheon’s default applications. If you’d like to not install Pantheon’s apps, set\n\nservices.pantheon.apps.enable = false;\n\n\nYou can also use environment.pantheon.excludePackages to remove any other app (like elementary-mail).\n\nWingpanel and Switchboard plugins \n\nWingpanel and Switchboard work differently than they do in other distributions, as far as using plugins. You cannot install a plugin globally (like with environment.systemPackages) to start using it. You should instead be using the following options:\n\nservices.xserver.desktopManager.pantheon.extraWingpanelIndicators\n\nservices.xserver.desktopManager.pantheon.extraSwitchboardPlugs\n\nto configure the programs with plugs or indicators.\n\nThe difference in NixOS is both these programs are patched to load plugins from a directory that is the value of an environment variable. All of which is controlled in Nix. If you need to configure the particular packages manually you can override the packages like:\n\nwingpanel-with-indicators.override {\n  indicators = [\n    pkgs.some-special-indicator\n  ];\n};\n\nswitchboard-with-plugs.override {\n  plugs = [\n    pkgs.some-special-plug\n  ];\n};\n\n\nplease note that, like how the NixOS options describe these as extra plugins, this would only add to the default plugins included with the programs. If for some reason you’d like to configure which plugins to use exactly, both packages have an argument for this:\n\nwingpanel-with-indicators.override {\n  useDefaultIndicators = false;\n  indicators = specialListOfIndicators;\n};\n\nswitchboard-with-plugs.override {\n  useDefaultPlugs = false;\n  plugs = specialListOfPlugs;\n};\n\n\nthis could be most useful for testing a particular plug-in in isolation.\n\nFAQ \nI have switched from a different desktop and Pantheon’s theming looks messed up.\n\nOpen Switchboard and go to: Administration → About → Restore Default Settings → Restore Settings. This will reset any dconf settings to their Pantheon defaults. Note this could reset certain GNOME specific preferences if that desktop was used prior.\n\nI cannot enable both GNOME and Pantheon.\n\nThis is a known issue and there is no known workaround.\n\nDoes AppCenter work, or is it available?\n\nAppCenter has been available since 20.03. Starting from 21.11, the Flatpak backend should work so you can install some Flatpak applications using it. However, due to missing appstream metadata, the Packagekit backend does not function currently. See this issue.\n\nIf you are using Pantheon, AppCenter should be installed by default if you have Flatpak support enabled. If you also wish to add the appcenter Flatpak remote:\n\n$ flatpak remote-add --if-not-exists appcenter https://flatpak.elementary.io/repo.flatpakrepo\n\nGNOME Desktop \n\nTable of Contents\n\nEnabling GNOME\nEnabling GNOME Flashback\nIcons and GTK Themes\nShell Extensions\nGSettings Overrides\nFrequently Asked Questions\n\nGNOME provides a simple, yet full-featured desktop environment with a focus on productivity. Its Mutter compositor supports both Wayland and X server, and the GNOME Shell user interface is fully customizable by extensions.\n\nEnabling GNOME \n\nAll of the core apps, optional apps, games, and core developer tools from GNOME are available.\n\nTo enable the GNOME desktop use:\n\nservices.xserver.desktopManager.gnome.enable = true;\nservices.xserver.displayManager.gdm.enable = true;\n\nNote\n\nWhile it is not strictly necessary to use GDM as the display manager with GNOME, it is recommended, as some features such as screen lock might not work without it.\n\nThe default applications used in NixOS are very minimal, inspired by the defaults used in gnome-build-meta.\n\nGNOME without the apps \n\nIf you’d like to only use the GNOME desktop and not the apps, you can disable them with:\n\nservices.gnome.core-utilities.enable = false;\n\n\nand none of them will be installed.\n\nIf you’d only like to omit a subset of the core utilities, you can use environment.gnome.excludePackages. Note that this mechanism can only exclude core utilities, games and core developer tools.\n\nDisabling GNOME services \n\nIt is also possible to disable many of the core services. For example, if you do not need indexing files, you can disable Tracker with:\n\nservices.gnome.tracker-miners.enable = false;\nservices.gnome.tracker.enable = false;\n\n\nNote, however, that doing so is not supported and might break some applications. Notably, GNOME Music cannot work without Tracker.\n\nGNOME games \n\nYou can install all of the GNOME games with:\n\nservices.gnome.games.enable = true;\n\nGNOME core developer tools \n\nYou can install GNOME core developer tools with:\n\nservices.gnome.core-developer-tools.enable = true;\n\nEnabling GNOME Flashback \n\nGNOME Flashback provides a desktop environment based on the classic GNOME 2 architecture. You can enable the default GNOME Flashback session, which uses the Metacity window manager, with:\n\nservices.xserver.desktopManager.gnome.flashback.enableMetacity = true;\n\n\nIt is also possible to create custom sessions that replace Metacity with a different window manager using services.xserver.desktopManager.gnome.flashback.customSessions.\n\nThe following example uses xmonad window manager:\n\nservices.xserver.desktopManager.gnome.flashback.customSessions = [\n  {\n    wmName = \"xmonad\";\n    wmLabel = \"XMonad\";\n    wmCommand = \"${pkgs.haskellPackages.xmonad}/bin/xmonad\";\n    enableGnomePanel = false;\n  }\n];\n\nIcons and GTK Themes \n\nIcon themes and GTK themes don’t require any special option to install in NixOS.\n\nYou can add them to environment.systemPackages and switch to them with GNOME Tweaks. If you’d like to do this manually in dconf, change the values of the following keys:\n\n/org/gnome/desktop/interface/gtk-theme\n/org/gnome/desktop/interface/icon-theme\n\n\nin dconf-editor\n\nShell Extensions \n\nMost Shell extensions are packaged under the gnomeExtensions attribute. Some packages that include Shell extensions, like gnome.gpaste, don’t have their extension decoupled under this attribute.\n\nYou can install them like any other package:\n\nenvironment.systemPackages = [\n  gnomeExtensions.dash-to-dock\n  gnomeExtensions.gsconnect\n  gnomeExtensions.mpris-indicator-button\n];\n\n\nUnfortunately, we lack a way for these to be managed in a completely declarative way. So you have to enable them manually with an Extensions application. It is possible to use a GSettings override for this on org.gnome.shell.enabled-extensions, but that will only influence the default value.\n\nGSettings Overrides \n\nMajority of software building on the GNOME platform use GLib’s GSettings system to manage runtime configuration. For our purposes, the system consists of XML schemas describing the individual configuration options, stored in the package, and a settings backend, where the values of the settings are stored. On NixOS, like on most Linux distributions, dconf database is used as the backend.\n\nGSettings vendor overrides can be used to adjust the default values for settings of the GNOME desktop and apps by replacing the default values specified in the XML schemas. Using overrides will allow you to pre-seed user settings before you even start the session.\n\nWarning\n\nOverrides really only change the default values for GSettings keys so if you or an application changes the setting value, the value set by the override will be ignored. Until NixOS’s dconf module implements changing values, you will either need to keep that in mind and clear the setting from the backend using dconf reset command when that happens, or use the module from home-manager.\n\nYou can override the default GSettings values using the services.xserver.desktopManager.gnome.extraGSettingsOverrides option.\n\nTake note that whatever packages you want to override GSettings for, you need to add them to services.xserver.desktopManager.gnome.extraGSettingsOverridePackages.\n\nYou can use dconf-editor tool to explore which GSettings you can set.\n\nExample \nservices.xserver.desktopManager.gnome = {\n  extraGSettingsOverrides = ''\n    # Change default background\n    [org.gnome.desktop.background]\n    picture-uri='file://${pkgs.nixos-artwork.wallpapers.mosaic-blue.gnomeFilePath}'\n\n    # Favorite apps in gnome-shell\n    [org.gnome.shell]\n    favorite-apps=['org.gnome.Photos.desktop', 'org.gnome.Nautilus.desktop']\n  '';\n\n  extraGSettingsOverridePackages = [\n    pkgs.gsettings-desktop-schemas # for org.gnome.desktop\n    pkgs.gnome.gnome-shell # for org.gnome.shell\n  ];\n};\n\nFrequently Asked Questions \nCan I use LightDM with GNOME? \n\nYes you can, and any other display-manager in NixOS.\n\nHowever, it doesn’t work correctly for the Wayland session of GNOME Shell yet, and won’t be able to lock your screen.\n\nSee this issue.\n\nExternal Bootloader Backends \n\nTable of Contents\n\nDeveloping Custom Bootloader Backends\n\nNixOS has support for several bootloader backends by default: systemd-boot, grub, uboot, etc. The built-in bootloader backend support is generic and supports most use cases. Some users may prefer to create advanced workflows around managing the bootloader and bootable entries.\n\nYou can replace the built-in bootloader support with your own tooling using the “external” bootloader option.\n\nImagine you have created a new package called FooBoot. FooBoot provides a program at ${pkgs.fooboot}/bin/fooboot-install which takes the system closure’s path as its only argument and configures the system’s bootloader.\n\nYou can enable FooBoot like this:\n\n{ pkgs, ... }: {\n  boot.loader.external = {\n    enable = true;\n    installHook = \"${pkgs.fooboot}/bin/fooboot-install\";\n  };\n}\n\nDeveloping Custom Bootloader Backends \n\nBootloaders should use RFC-0125’s Bootspec format and synthesis tools to identify the key properties for bootable system generations.\n\nGarage \n\nTable of Contents\n\nGeneral considerations on upgrades\nAdvanced upgrades (minor/major version upgrades)\nMaintainer information\n\nGarage is an open-source, self-hostable S3 store, simpler than MinIO, for geodistributed stores. The server setup can be automated using services.garage. A client configured to your local Garage instance is available in the global environment as garage-manage.\n\nThe current default by NixOS is garage_0_8 which is also the latest major version available.\n\nGeneral considerations on upgrades \n\nGarage provides a cookbook documentation on how to upgrade: https://garagehq.deuxfleurs.fr/documentation/cookbook/upgrading/\n\nWarning\n\nGarage has two types of upgrades: patch-level upgrades and minor/major version upgrades.\n\nIn all cases, you should read the changelog and ideally test the upgrade on a staging cluster.\n\nChecking the health of your cluster can be achieved using garage-manage repair.\n\nWarning\n\nUntil 1.0 is released, patch-level upgrades are considered as minor version upgrades. Minor version upgrades are considered as major version upgrades. i.e. 0.6 to 0.7 is a major version upgrade.\n\nStraightforward upgrades (patch-level upgrades). Upgrades must be performed one by one, i.e. for each node, stop it, upgrade it : change stateVersion or services.garage.package, restart it if it was not already by switching.\n\nMultiple version upgrades. Garage do not provide any guarantee on moving more than one major-version forward. E.g., if you’re on 0.7, you cannot upgrade to 0.9. You need to upgrade to 0.8 first. As long as stateVersion is declared properly, this is enforced automatically. The module will issue a warning to remind the user to upgrade to latest Garage after that deploy.\n\nAdvanced upgrades (minor/major version upgrades) \n\nHere are some baseline instructions to handle advanced upgrades in Garage, when in doubt, please refer to upstream instructions.\n\nDisable API and web access to Garage.\n\nPerform garage-manage repair --all-nodes --yes tables and garage-manage repair --all-nodes --yes blocks.\n\nVerify the resulting logs and check that data is synced properly between all nodes. If you have time, do additional checks (scrub, block_refs, etc.).\n\nCheck if queues are empty by garage-manage stats or through monitoring tools.\n\nRun systemctl stop garage to stop the actual Garage version.\n\nBackup the metadata folder of ALL your nodes, e.g. for a metadata directory (the default one) in /var/lib/garage/meta, you can run pushd /var/lib/garage; tar -acf meta-v0.7.tar.zst meta/; popd.\n\nRun the offline migration: nix-shell -p garage_0_8 --run \"garage offline-repair --yes\", this can take some time depending on how many objects are stored in your cluster.\n\nBump Garage version in your NixOS configuration, either by changing stateVersion or bumping services.garage.package, this should restart Garage automatically.\n\nPerform garage-manage repair --all-nodes --yes tables and garage-manage repair --all-nodes --yes blocks.\n\nWait for a full table sync to run.\n\nYour upgraded cluster should be in a working state, re-enable API and web access.\n\nMaintainer information \n\nAs stated in the previous paragraph, we must provide a clean upgrade-path for Garage since it cannot move more than one major version forward on a single upgrade. This chapter adds some notes how Garage updates should be rolled out in the future. This is inspired from how Nextcloud does it.\n\nWhile patch-level updates are no problem and can be done directly in the package-expression (and should be backported to supported stable branches after that), major-releases should be added in a new attribute (e.g. Garage v0.8.0 should be available in nixpkgs as pkgs.garage_0_8_0). To provide simple upgrade paths it’s generally useful to backport those as well to stable branches. As long as the package-default isn’t altered, this won’t break existing setups. After that, the versioning-warning in the garage-module should be updated to make sure that the package-option selects the latest version on fresh setups.\n\nIf major-releases will be abandoned by upstream, we should check first if those are needed in NixOS for a safe upgrade-path before removing those. In that case we should keep those packages, but mark them as insecure in an expression like this (in <nixpkgs/pkgs/tools/filesystem/garage/default.nix>):\n\n/* ... */\n{\n  garage_0_7_3 = generic {\n    version = \"0.7.3\";\n    sha256 = \"0000000000000000000000000000000000000000000000000000\";\n    eol = true;\n  };\n}\n\n\nIdeally we should make sure that it’s possible to jump two NixOS versions forward: i.e. the warnings and the logic in the module should guard a user to upgrade from a Garage on e.g. 22.11 to a Garage on 23.11.\n\nPlausible \n\nTable of Contents\n\nBasic Usage\n\nPlausible is a privacy-friendly alternative to Google analytics.\n\nBasic Usage \n\nAt first, a secret key is needed to be generated. This can be done with e.g.\n\n$ openssl rand -base64 64\n\n\nAfter that, plausible can be deployed like this:\n\n{\n  services.plausible = {\n    enable = true;\n    adminUser = {\n      # activate is used to skip the email verification of the admin-user that's\n      # automatically created by plausible. This is only supported if\n      # postgresql is configured by the module. This is done by default, but\n      # can be turned off with services.plausible.database.postgres.setup.\n      activate = true;\n      email = \"admin@localhost\";\n      passwordFile = \"/run/secrets/plausible-admin-pwd\";\n    };\n    server = {\n      baseUrl = \"http://analytics.example.org\";\n      # secretKeybaseFile is a path to the file which contains the secret generated\n      # with openssl as described above.\n      secretKeybaseFile = \"/run/secrets/plausible-secret-key-base\";\n    };\n  };\n}\n\nPict-rs \n\nTable of Contents\n\nQuickstart\nUsage\nMissing\n\npict-rs is a a simple image hosting service.\n\nQuickstart \n\nthe minimum to start pict-rs is\n\nservices.pict-rs.enable = true;\n\n\nthis will start the http server on port 8080 by default.\n\nUsage \n\npict-rs offers the following endpoints:\n\nPOST /image for uploading an image. Uploaded content must be valid multipart/form-data with an image array located within the images[] key\n\nThis endpoint returns the following JSON structure on success with a 201 Created status\n\n{\n    \"files\": [\n        {\n            \"delete_token\": \"JFvFhqJA98\",\n            \"file\": \"lkWZDRvugm.jpg\"\n        },\n        {\n            \"delete_token\": \"kAYy9nk2WK\",\n            \"file\": \"8qFS0QooAn.jpg\"\n        },\n        {\n            \"delete_token\": \"OxRpM3sf0Y\",\n            \"file\": \"1hJaYfGE01.jpg\"\n        }\n    ],\n    \"msg\": \"ok\"\n}\n\n\nGET /image/download?url=... Download an image from a remote server, returning the same JSON payload as the POST endpoint\n\nGET /image/original/{file} for getting a full-resolution image. file here is the file key from the /image endpoint’s JSON\n\nGET /image/details/original/{file} for getting the details of a full-resolution image. The returned JSON is structured like so:\n\n{\n    \"width\": 800,\n    \"height\": 537,\n    \"content_type\": \"image/webp\",\n    \"created_at\": [\n        2020,\n        345,\n        67376,\n        394363487\n    ]\n}\n\n\nGET /image/process.{ext}?src={file}&... get a file with transformations applied. existing transformations include\n\nidentity=true: apply no changes\n\nblur={float}: apply a gaussian blur to the file\n\nthumbnail={int}: produce a thumbnail of the image fitting inside an {int} by {int} square using raw pixel sampling\n\nresize={int}: produce a thumbnail of the image fitting inside an {int} by {int} square using a Lanczos2 filter. This is slower than sampling but looks a bit better in some cases\n\ncrop={int-w}x{int-h}: produce a cropped version of the image with an {int-w} by {int-h} aspect ratio. The resulting crop will be centered on the image. Either the width or height of the image will remain full-size, depending on the image’s aspect ratio and the requested aspect ratio. For example, a 1600x900 image cropped with a 1x1 aspect ratio will become 900x900. A 1600x1100 image cropped with a 16x9 aspect ratio will become 1600x900.\n\nSupported ext file extensions include png, jpg, and webp\n\nAn example of usage could be\n\nGET /image/process.jpg?src=asdf.png&thumbnail=256&blur=3.0\n\n\nwhich would create a 256x256px JPEG thumbnail and blur it\n\nGET /image/details/process.{ext}?src={file}&... for getting the details of a processed image. The returned JSON is the same format as listed for the full-resolution details endpoint.\n\nDELETE /image/delete/{delete_token}/{file} or GET /image/delete/{delete_token}/{file} to delete a file, where delete_token and file are from the /image endpoint’s JSON\n\nMissing \n\nConfiguring the secure-api-key is not included yet. The envisioned basic use case is consumption on localhost by other services without exposing the service to the internet.\n\nNextcloud \n\nTable of Contents\n\nBasic usage\nCommon problems\nUsing an alternative webserver as reverse-proxy (e.g. httpd)\nInstalling Apps and PHP extensions\nMaintainer information\n\nNextcloud is an open-source, self-hostable cloud platform. The server setup can be automated using services.nextcloud. A desktop client is packaged at pkgs.nextcloud-client.\n\nThe current default by NixOS is nextcloud27 which is also the latest major version available.\n\nBasic usage \n\nNextcloud is a PHP-based application which requires an HTTP server (services.nextcloud and optionally supports services.nginx).\n\nFor the database, you can set services.nextcloud.config.dbtype to either sqlite (the default), mysql, or pgsql. The simplest is sqlite, which will be automatically created and managed by the application. For the last two, you can easily create a local database by setting services.nextcloud.database.createLocally to true, Nextcloud will automatically be configured to connect to it through socket.\n\nA very basic configuration may look like this:\n\n{ pkgs, ... }:\n{\n  services.nextcloud = {\n    enable = true;\n    hostName = \"nextcloud.tld\";\n    database.createLocally = true;\n    config = {\n      dbtype = \"pgsql\";\n      adminpassFile = \"/path/to/admin-pass-file\";\n    };\n  };\n\n  networking.firewall.allowedTCPPorts = [ 80 443 ];\n}\n\n\nThe hostName option is used internally to configure an HTTP server using PHP-FPM and nginx. The config attribute set is used by the imperative installer and all values are written to an additional file to ensure that changes can be applied by changing the module’s options.\n\nIn case the application serves multiple domains (those are checked with $_SERVER['HTTP_HOST']) it’s needed to add them to services.nextcloud.config.extraTrustedDomains.\n\nAuto updates for Nextcloud apps can be enabled using services.nextcloud.autoUpdateApps.\n\nCommon problems \n\nGeneral notes. Unfortunately Nextcloud appears to be very stateful when it comes to managing its own configuration. The config file lives in the home directory of the nextcloud user (by default /var/lib/nextcloud/config/config.php) and is also used to track several states of the application (e.g., whether installed or not).\n\nAll configuration parameters are also stored in /var/lib/nextcloud/config/override.config.php which is generated by the module and linked from the store to ensure that all values from config.php can be modified by the module. However config.php manages the application’s state and shouldn’t be touched manually because of that.\n\nWarning\n\nDon’t delete config.php! This file tracks the application’s state and a deletion can cause unwanted side-effects!\n\nWarning\n\nDon’t rerun nextcloud-occ maintenance:install! This command tries to install the application and can cause unwanted side-effects!\n\nMultiple version upgrades. Nextcloud doesn’t allow to move more than one major-version forward. E.g., if you’re on v16, you cannot upgrade to v18, you need to upgrade to v17 first. This is ensured automatically as long as the stateVersion is declared properly. In that case the oldest version available (one major behind the one from the previous NixOS release) will be selected by default and the module will generate a warning that reminds the user to upgrade to latest Nextcloud after that deploy.\n\nError: Command \"upgrade\" is not defined. This error usually occurs if the initial installation (nextcloud-occ maintenance:install) has failed. After that, the application is not installed, but the upgrade is attempted to be executed. Further context can be found in NixOS/nixpkgs#111175.\n\nFirst of all, it makes sense to find out what went wrong by looking at the logs of the installation via journalctl -u nextcloud-setup and try to fix the underlying issue.\n\nIf this occurs on an existing setup, this is most likely because the maintenance mode is active. It can be deactivated by running nextcloud-occ maintenance:mode --off. It’s advisable though to check the logs first on why the maintenance mode was activated.\n\nWarning\n\nOnly perform the following measures on freshly installed instances!\n\nA re-run of the installer can be forced by deleting /var/lib/nextcloud/config/config.php. This is the only time advisable because the fresh install doesn’t have any state that can be lost. In case that doesn’t help, an entire re-creation can be forced via rm -rf ~nextcloud/.\n\nServer-side encryption. Nextcloud supports server-side encryption (SSE). This is not an end-to-end encryption, but can be used to encrypt files that will be persisted to external storage such as S3.\n\nUsing an alternative webserver as reverse-proxy (e.g. httpd) \n\nBy default, nginx is used as reverse-proxy for nextcloud. However, it’s possible to use e.g. httpd by explicitly disabling nginx using services.nginx.enable and fixing the settings listen.owner & listen.group in the corresponding phpfpm pool.\n\nAn exemplary configuration may look like this:\n\n{ config, lib, pkgs, ... }: {\n  services.nginx.enable = false;\n  services.nextcloud = {\n    enable = true;\n    hostName = \"localhost\";\n\n    /* further, required options */\n  };\n  services.phpfpm.pools.nextcloud.settings = {\n    \"listen.owner\" = config.services.httpd.user;\n    \"listen.group\" = config.services.httpd.group;\n  };\n  services.httpd = {\n    enable = true;\n    adminAddr = \"webmaster@localhost\";\n    extraModules = [ \"proxy_fcgi\" ];\n    virtualHosts.\"localhost\" = {\n      documentRoot = config.services.nextcloud.package;\n      extraConfig = ''\n        <Directory \"${config.services.nextcloud.package}\">\n          <FilesMatch \"\\.php$\">\n            <If \"-f %{REQUEST_FILENAME}\">\n              SetHandler \"proxy:unix:${config.services.phpfpm.pools.nextcloud.socket}|fcgi://localhost/\"\n            </If>\n          </FilesMatch>\n          <IfModule mod_rewrite.c>\n            RewriteEngine On\n            RewriteBase /\n            RewriteRule ^index\\.php$ - [L]\n            RewriteCond %{REQUEST_FILENAME} !-f\n            RewriteCond %{REQUEST_FILENAME} !-d\n            RewriteRule . /index.php [L]\n          </IfModule>\n          DirectoryIndex index.php\n          Require all granted\n          Options +FollowSymLinks\n        </Directory>\n      '';\n    };\n  };\n}\n\nInstalling Apps and PHP extensions \n\nNextcloud apps are installed statefully through the web interface. Some apps may require extra PHP extensions to be installed. This can be configured with the services.nextcloud.phpExtraExtensions setting.\n\nAlternatively, extra apps can also be declared with the services.nextcloud.extraApps setting. When using this setting, apps can no longer be managed statefully because this can lead to Nextcloud updating apps that are managed by Nix. If you want automatic updates it is recommended that you use web interface to install apps.\n\nMaintainer information \n\nAs stated in the previous paragraph, we must provide a clean upgrade-path for Nextcloud since it cannot move more than one major version forward on a single upgrade. This chapter adds some notes how Nextcloud updates should be rolled out in the future.\n\nWhile minor and patch-level updates are no problem and can be done directly in the package-expression (and should be backported to supported stable branches after that), major-releases should be added in a new attribute (e.g. Nextcloud v19.0.0 should be available in nixpkgs as pkgs.nextcloud19). To provide simple upgrade paths it’s generally useful to backport those as well to stable branches. As long as the package-default isn’t altered, this won’t break existing setups. After that, the versioning-warning in the nextcloud-module should be updated to make sure that the package-option selects the latest version on fresh setups.\n\nIf major-releases will be abandoned by upstream, we should check first if those are needed in NixOS for a safe upgrade-path before removing those. In that case we should keep those packages, but mark them as insecure in an expression like this (in <nixpkgs/pkgs/servers/nextcloud/default.nix>):\n\n/* ... */\n{\n  nextcloud17 = generic {\n    version = \"17.0.x\";\n    sha256 = \"0000000000000000000000000000000000000000000000000000\";\n    eol = true;\n  };\n}\n\n\nIdeally we should make sure that it’s possible to jump two NixOS versions forward: i.e. the warnings and the logic in the module should guard a user to upgrade from a Nextcloud on e.g. 19.09 to a Nextcloud on 20.09.\n\nMatomo \n\nTable of Contents\n\nDatabase Setup\nArchive Processing\nBackup\nIssues\nUsing other Web Servers than nginx\n\nMatomo is a real-time web analytics application. This module configures php-fpm as backend for Matomo, optionally configuring an nginx vhost as well.\n\nAn automatic setup is not supported by Matomo, so you need to configure Matomo itself in the browser-based Matomo setup.\n\nDatabase Setup \n\nYou also need to configure a MariaDB or MySQL database and -user for Matomo yourself, and enter those credentials in your browser. You can use passwordless database authentication via the UNIX_SOCKET authentication plugin with the following SQL commands:\n\n# For MariaDB\nINSTALL PLUGIN unix_socket SONAME 'auth_socket';\nCREATE DATABASE matomo;\nCREATE USER 'matomo'@'localhost' IDENTIFIED WITH unix_socket;\nGRANT ALL PRIVILEGES ON matomo.* TO 'matomo'@'localhost';\n\n# For MySQL\nINSTALL PLUGIN auth_socket SONAME 'auth_socket.so';\nCREATE DATABASE matomo;\nCREATE USER 'matomo'@'localhost' IDENTIFIED WITH auth_socket;\nGRANT ALL PRIVILEGES ON matomo.* TO 'matomo'@'localhost';\n\n\nThen fill in matomo as database user and database name, and leave the password field blank. This authentication works by allowing only the matomo unix user to authenticate as the matomo database user (without needing a password), but no other users. For more information on passwordless login, see https://mariadb.com/kb/en/mariadb/unix_socket-authentication-plugin/.\n\nOf course, you can use password based authentication as well, e.g. when the database is not on the same host.\n\nArchive Processing \n\nThis module comes with the systemd service matomo-archive-processing.service and a timer that automatically triggers archive processing every hour. This means that you can safely disable browser triggers for Matomo archiving at Administration > System > General Settings.\n\nWith automatic archive processing, you can now also enable to delete old visitor logs at Administration > System > Privacy, but make sure that you run systemctl start matomo-archive-processing.service at least once without errors if you have already collected data before, so that the reports get archived before the source data gets deleted.\n\nBackup \n\nYou only need to take backups of your MySQL database and the /var/lib/matomo/config/config.ini.php file. Use a user in the matomo group or root to access the file. For more information, see https://matomo.org/faq/how-to-install/faq_138/.\n\nIssues \n\nMatomo will warn you that the JavaScript tracker is not writable. This is because it’s located in the read-only nix store. You can safely ignore this, unless you need a plugin that needs JavaScript tracker access.\n\nUsing other Web Servers than nginx \n\nYou can use other web servers by forwarding calls for index.php and piwik.php to the services.phpfpm.pools.<name>.socket fastcgi unix socket. You can use the nginx configuration in the module code as a reference to what else should be configured.\n\nLemmy \n\nTable of Contents\n\nQuickstart\nUsage\nMissing\n\nLemmy is a federated alternative to reddit in rust.\n\nQuickstart \n\nthe minimum to start lemmy is\n\nservices.lemmy = {\n  enable = true;\n  settings = {\n    hostname = \"lemmy.union.rocks\";\n    database.createLocally = true;\n  };\n  caddy.enable = true;\n}\n\n\nthis will start the backend on port 8536 and the frontend on port 1234. It will expose your instance with a caddy reverse proxy to the hostname you’ve provided. Postgres will be initialized on that same instance automatically.\n\nUsage \n\nOn first connection you will be asked to define an admin user.\n\nMissing \n\nExposing with nginx is not implemented yet.\n\nThis has been tested using a local database with a unix socket connection. Using different database settings will likely require modifications\n\nKeycloak \n\nTable of Contents\n\nAdministration\nDatabase access\nHostname\nSetting up TLS/SSL\nThemes\nConfiguration file settings\nExample configuration\n\nKeycloak is an open source identity and access management server with support for OpenID Connect, OAUTH 2.0 and SAML 2.0.\n\nAdministration \n\nAn administrative user with the username admin is automatically created in the master realm. Its initial password can be configured by setting services.keycloak.initialAdminPassword and defaults to changeme. The password is not stored safely and should be changed immediately in the admin panel.\n\nRefer to the Keycloak Server Administration Guide for information on how to administer your Keycloak instance.\n\nDatabase access \n\nKeycloak can be used with either PostgreSQL, MariaDB or MySQL. Which one is used can be configured in services.keycloak.database.type. The selected database will automatically be enabled and a database and role created unless services.keycloak.database.host is changed from its default of localhost or services.keycloak.database.createLocally is set to false.\n\nExternal database access can also be configured by setting services.keycloak.database.host, services.keycloak.database.name, services.keycloak.database.username, services.keycloak.database.useSSL and services.keycloak.database.caCert as appropriate. Note that you need to manually create the database and allow the configured database user full access to it.\n\nservices.keycloak.database.passwordFile must be set to the path to a file containing the password used to log in to the database. If services.keycloak.database.host and services.keycloak.database.createLocally are kept at their defaults, the database role keycloak with that password is provisioned on the local database instance.\n\nWarning\n\nThe path should be provided as a string, not a Nix path, since Nix paths are copied into the world readable Nix store.\n\nHostname \n\nThe hostname is used to build the public URL used as base for all frontend requests and must be configured through services.keycloak.settings.hostname.\n\nNote\n\nIf you’re migrating an old Wildfly based Keycloak instance and want to keep compatibility with your current clients, you’ll likely want to set services.keycloak.settings.http-relative-path to /auth. See the option description for more details.\n\nservices.keycloak.settings.hostname-strict-backchannel determines whether Keycloak should force all requests to go through the frontend URL. By default, Keycloak allows backend requests to instead use its local hostname or IP address and may also advertise it to clients through its OpenID Connect Discovery endpoint.\n\nFor more information on hostname configuration, see the Hostname section of the Keycloak Server Installation and Configuration Guide.\n\nSetting up TLS/SSL \n\nBy default, Keycloak won’t accept unsecured HTTP connections originating from outside its local network.\n\nHTTPS support requires a TLS/SSL certificate and a private key, both PEM formatted. Their paths should be set through services.keycloak.sslCertificate and services.keycloak.sslCertificateKey.\n\nWarning\n\nThe paths should be provided as a strings, not a Nix paths, since Nix paths are copied into the world readable Nix store.\n\nThemes \n\nYou can package custom themes and make them visible to Keycloak through services.keycloak.themes. See the Themes section of the Keycloak Server Development Guide and the description of the aforementioned NixOS option for more information.\n\nConfiguration file settings \n\nKeycloak server configuration parameters can be set in services.keycloak.settings. These correspond directly to options in conf/keycloak.conf. Some of the most important parameters are documented as suboptions, the rest can be found in the All configuration section of the Keycloak Server Installation and Configuration Guide.\n\nOptions containing secret data should be set to an attribute set containing the attribute _secret - a string pointing to a file containing the value the option should be set to. See the description of services.keycloak.settings for an example.\n\nExample configuration \n\nA basic configuration with some custom settings could look like this:\n\nservices.keycloak = {\n  enable = true;\n  settings = {\n    hostname = \"keycloak.example.com\";\n    hostname-strict-backchannel = true;\n  };\n  initialAdminPassword = \"e6Wcm0RrtegMEHl\";  # change on first login\n  sslCertificate = \"/run/keys/ssl_cert\";\n  sslCertificateKey = \"/run/keys/ssl_key\";\n  database.passwordFile = \"/run/keys/db_password\";\n};\n\nJitsi Meet \n\nTable of Contents\n\nBasic usage\nConfiguration\n\nWith Jitsi Meet on NixOS you can quickly configure a complete, private, self-hosted video conferencing solution.\n\nBasic usage \n\nA minimal configuration using Let’s Encrypt for TLS certificates looks like this:\n\n{\n  services.jitsi-meet = {\n    enable = true;\n    hostName = \"jitsi.example.com\";\n  };\n  services.jitsi-videobridge.openFirewall = true;\n  networking.firewall.allowedTCPPorts = [ 80 443 ];\n  security.acme.email = \"me@example.com\";\n  security.acme.acceptTerms = true;\n}\n\nConfiguration \n\nHere is the minimal configuration with additional configurations:\n\n{\n  services.jitsi-meet = {\n    enable = true;\n    hostName = \"jitsi.example.com\";\n    config = {\n      enableWelcomePage = false;\n      prejoinPageEnabled = true;\n      defaultLang = \"fi\";\n    };\n    interfaceConfig = {\n      SHOW_JITSI_WATERMARK = false;\n      SHOW_WATERMARK_FOR_GUESTS = false;\n    };\n  };\n  services.jitsi-videobridge.openFirewall = true;\n  networking.firewall.allowedTCPPorts = [ 80 443 ];\n  security.acme.email = \"me@example.com\";\n  security.acme.acceptTerms = true;\n}\n\nHonk \n\nTable of Contents\n\nBasic usage\n\nWith Honk on NixOS you can quickly configure a complete ActivityPub server with minimal setup and support costs.\n\nBasic usage \n\nA minimal configuration looks like this:\n\n{\n  services.honk = {\n    enable = true;\n    host = \"0.0.0.0\";\n    port = 8080;\n    username = \"username\";\n    passwordFile = \"/etc/honk/password.txt\";\n    servername = \"honk.example.com\";\n  };\n\n  networking.firewall.allowedTCPPorts = [ 8080 ];\n}\n\nGrocy \n\nTable of Contents\n\nBasic usage\nSettings\n\nGrocy is a web-based self-hosted groceries & household management solution for your home.\n\nBasic usage \n\nA very basic configuration may look like this:\n\n{ pkgs, ... }:\n{\n  services.grocy = {\n    enable = true;\n    hostName = \"grocy.tld\";\n  };\n}\n\n\nThis configures a simple vhost using nginx which listens to grocy.tld with fully configured ACME/LE (this can be disabled by setting services.grocy.nginx.enableSSL to false). After the initial setup the credentials admin:admin can be used to login.\n\nThe application’s state is persisted at /var/lib/grocy/grocy.db in a sqlite3 database. The migration is applied when requesting the /-route of the application.\n\nSettings \n\nThe configuration for grocy is located at /etc/grocy/config.php. By default, the following settings can be defined in the NixOS-configuration:\n\n{ pkgs, ... }:\n{\n  services.grocy.settings = {\n    # The default currency in the system for invoices etc.\n    # Please note that exchange rates aren't taken into account, this\n    # is just the setting for what's shown in the frontend.\n    currency = \"EUR\";\n\n    # The display language (and locale configuration) for grocy.\n    culture = \"de\";\n\n    calendar = {\n      # Whether or not to show the week-numbers\n      # in the calendar.\n      showWeekNumber = true;\n\n      # Index of the first day to be shown in the calendar (0=Sunday, 1=Monday,\n      # 2=Tuesday and so on).\n      firstDayOfWeek = 2;\n    };\n  };\n}\n\n\nIf you want to alter the configuration file on your own, you can do this manually with an expression like this:\n\n{ lib, ... }:\n{\n  environment.etc.\"grocy/config.php\".text = lib.mkAfter ''\n    // Arbitrary PHP code in grocy's configuration file\n  '';\n}\n\nGoToSocial \n\nTable of Contents\n\nService configuration\nProxy configuration\nUser management\n\nGoToSocial is an ActivityPub social network server, written in Golang.\n\nService configuration \n\nThe following configuration sets up the PostgreSQL as database backend and binds GoToSocial to 127.0.0.1:8080, expecting to be run behind a HTTP proxy on gotosocial.example.com.\n\nservices.gotosocial = {\n  enable = true;\n  setupPostgresqlDB = true;\n  settings = {\n    application-name = \"My GoToSocial\";\n    host = \"gotosocial.example.com\";\n    protocol = \"https\";\n    bind-address = \"127.0.0.1\";\n    port = 8080;\n  };\n};\n\n\nPlease refer to the GoToSocial Documentation for additional configuration options.\n\nProxy configuration \n\nAlthough it is possible to expose GoToSocial directly, it is common practice to operate it behind an HTTP reverse proxy such as nginx.\n\nnetworking.firewall.allowedTCPPorts = [ 80 443 ];\nservices.nginx = {\n  enable = true;\n  clientMaxBodySize = \"40M\";\n  virtualHosts = with config.services.gotosocial.settings; {\n    \"${host}\" = {\n      enableACME = true;\n      forceSSL = true;\n      locations = {\n        \"/\" = {\n          recommendedProxySettings = true;\n          proxyWebsockets = true;\n          proxyPass = \"http://${bind-address}:${toString port}\";\n        };\n      };\n    };\n  };\n};\n\n\nPlease refer to SSL/TLS Certificates with ACME for details on how to provision an SSL/TLS certificate.\n\nUser management \n\nAfter the GoToSocial service is running, the gotosocial-admin utility can be used to manage users. In particular an administrative user can be created with\n\n$ sudo gotosocial-admin account create --username <nickname> --email <email> --password <password>\n$ sudo gotosocial-admin account confirm --username <nickname>\n$ sudo gotosocial-admin account promote --username <nickname>\n\nDiscourse \n\nTable of Contents\n\nBasic usage\nUsing a regular TLS certificate\nDatabase access\nEmail\nAdditional settings\nPlugins\n\nDiscourse is a modern and open source discussion platform.\n\nBasic usage \n\nA minimal configuration using Let’s Encrypt for TLS certificates looks like this:\n\nservices.discourse = {\n  enable = true;\n  hostname = \"discourse.example.com\";\n  admin = {\n    email = \"admin@example.com\";\n    username = \"admin\";\n    fullName = \"Administrator\";\n    passwordFile = \"/path/to/password_file\";\n  };\n  secretKeyBaseFile = \"/path/to/secret_key_base_file\";\n};\nsecurity.acme.email = \"me@example.com\";\nsecurity.acme.acceptTerms = true;\n\n\nProvided a proper DNS setup, you’ll be able to connect to the instance at discourse.example.com and log in using the credentials provided in services.discourse.admin.\n\nUsing a regular TLS certificate \n\nTo set up TLS using a regular certificate and key on file, use the services.discourse.sslCertificate and services.discourse.sslCertificateKey options:\n\nservices.discourse = {\n  enable = true;\n  hostname = \"discourse.example.com\";\n  sslCertificate = \"/path/to/ssl_certificate\";\n  sslCertificateKey = \"/path/to/ssl_certificate_key\";\n  admin = {\n    email = \"admin@example.com\";\n    username = \"admin\";\n    fullName = \"Administrator\";\n    passwordFile = \"/path/to/password_file\";\n  };\n  secretKeyBaseFile = \"/path/to/secret_key_base_file\";\n};\n\nDatabase access \n\nDiscourse uses PostgreSQL to store most of its data. A database will automatically be enabled and a database and role created unless services.discourse.database.host is changed from its default of null or services.discourse.database.createLocally is set to false.\n\nExternal database access can also be configured by setting services.discourse.database.host, services.discourse.database.username and services.discourse.database.passwordFile as appropriate. Note that you need to manually create a database called discourse (or the name you chose in services.discourse.database.name) and allow the configured database user full access to it.\n\nEmail \n\nIn addition to the basic setup, you’ll want to configure an SMTP server Discourse can use to send user registration and password reset emails, among others. You can also optionally let Discourse receive email, which enables people to reply to threads and conversations via email.\n\nA basic setup which assumes you want to use your configured hostname as email domain can be done like this:\n\nservices.discourse = {\n  enable = true;\n  hostname = \"discourse.example.com\";\n  sslCertificate = \"/path/to/ssl_certificate\";\n  sslCertificateKey = \"/path/to/ssl_certificate_key\";\n  admin = {\n    email = \"admin@example.com\";\n    username = \"admin\";\n    fullName = \"Administrator\";\n    passwordFile = \"/path/to/password_file\";\n  };\n  mail.outgoing = {\n    serverAddress = \"smtp.emailprovider.com\";\n    port = 587;\n    username = \"user@emailprovider.com\";\n    passwordFile = \"/path/to/smtp_password_file\";\n  };\n  mail.incoming.enable = true;\n  secretKeyBaseFile = \"/path/to/secret_key_base_file\";\n};\n\n\nThis assumes you have set up an MX record for the address you’ve set in hostname and requires proper SPF, DKIM and DMARC configuration to be done for the domain you’re sending from, in order for email to be reliably delivered.\n\nIf you want to use a different domain for your outgoing email (for example example.com instead of discourse.example.com) you should set services.discourse.mail.notificationEmailAddress and services.discourse.mail.contactEmailAddress manually.\n\nNote\n\nSetup of TLS for incoming email is currently only configured automatically when a regular TLS certificate is used, i.e. when services.discourse.sslCertificate and services.discourse.sslCertificateKey are set.\n\nAdditional settings \n\nAdditional site settings and backend settings, for which no explicit NixOS options are provided, can be set in services.discourse.siteSettings and services.discourse.backendSettings respectively.\n\nSite settings \n\n“Site settings” are the settings that can be changed through the Discourse UI. Their default values can be set using services.discourse.siteSettings.\n\nSettings are expressed as a Nix attribute set which matches the structure of the configuration in config/site_settings.yml. To find a setting’s path, you only need to care about the first two levels; i.e. its category (e.g. login) and name (e.g. invite_only).\n\nSettings containing secret data should be set to an attribute set containing the attribute _secret - a string pointing to a file containing the value the option should be set to. See the example.\n\nBackend settings \n\nSettings are expressed as a Nix attribute set which matches the structure of the configuration in config/discourse.conf. Empty parameters can be defined by setting them to null.\n\nExample \n\nThe following example sets the title and description of the Discourse instance and enables GitHub login in the site settings, and changes a few request limits in the backend settings:\n\nservices.discourse = {\n  enable = true;\n  hostname = \"discourse.example.com\";\n  sslCertificate = \"/path/to/ssl_certificate\";\n  sslCertificateKey = \"/path/to/ssl_certificate_key\";\n  admin = {\n    email = \"admin@example.com\";\n    username = \"admin\";\n    fullName = \"Administrator\";\n    passwordFile = \"/path/to/password_file\";\n  };\n  mail.outgoing = {\n    serverAddress = \"smtp.emailprovider.com\";\n    port = 587;\n    username = \"user@emailprovider.com\";\n    passwordFile = \"/path/to/smtp_password_file\";\n  };\n  mail.incoming.enable = true;\n  siteSettings = {\n    required = {\n      title = \"My Cats\";\n      site_description = \"Discuss My Cats (and be nice plz)\";\n    };\n    login = {\n      enable_github_logins = true;\n      github_client_id = \"a2f6dfe838cb3206ce20\";\n      github_client_secret._secret = /run/keys/discourse_github_client_secret;\n    };\n  };\n  backendSettings = {\n    max_reqs_per_ip_per_minute = 300;\n    max_reqs_per_ip_per_10_seconds = 60;\n    max_asset_reqs_per_ip_per_10_seconds = 250;\n    max_reqs_per_ip_mode = \"warn+block\";\n  };\n  secretKeyBaseFile = \"/path/to/secret_key_base_file\";\n};\n\n\nIn the resulting site settings file, the login.github_client_secret key will be set to the contents of the /run/keys/discourse_github_client_secret file.\n\nPlugins \n\nYou can install Discourse plugins using the services.discourse.plugins option. Pre-packaged plugins are provided in <your_discourse_package_here>.plugins. If you want the full suite of plugins provided through nixpkgs, you can also set the services.discourse.package option to pkgs.discourseAllPlugins.\n\nPlugins can be built with the <your_discourse_package_here>.mkDiscoursePlugin function. Normally, it should suffice to provide a name and src attribute. If the plugin has Ruby dependencies, however, they need to be packaged in accordance with the Developing with Ruby section of the Nixpkgs manual and the appropriate gem options set in bundlerEnvArgs (normally gemdir is sufficient). A plugin’s Ruby dependencies are listed in its plugin.rb file as function calls to gem. To construct the corresponding Gemfile manually, run bundle init, then add the gem lines to it verbatim.\n\nMuch of the packaging can be done automatically by the nixpkgs/pkgs/servers/web-apps/discourse/update.py script - just add the plugin to the plugins list in the update_plugins function and run the script:\n\n./update.py update-plugins\n\n\nSome plugins provide site settings. Their defaults can be configured using services.discourse.siteSettings, just like regular site settings. To find the names of these settings, look in the config/settings.yml file of the plugin repo.\n\nFor example, to add the discourse-spoiler-alert and discourse-solved plugins, and disable discourse-spoiler-alert by default:\n\nservices.discourse = {\n  enable = true;\n  hostname = \"discourse.example.com\";\n  sslCertificate = \"/path/to/ssl_certificate\";\n  sslCertificateKey = \"/path/to/ssl_certificate_key\";\n  admin = {\n    email = \"admin@example.com\";\n    username = \"admin\";\n    fullName = \"Administrator\";\n    passwordFile = \"/path/to/password_file\";\n  };\n  mail.outgoing = {\n    serverAddress = \"smtp.emailprovider.com\";\n    port = 587;\n    username = \"user@emailprovider.com\";\n    passwordFile = \"/path/to/smtp_password_file\";\n  };\n  mail.incoming.enable = true;\n  plugins = with config.services.discourse.package.plugins; [\n    discourse-spoiler-alert\n    discourse-solved\n  ];\n  siteSettings = {\n    plugins = {\n      spoiler_enabled = false;\n    };\n  };\n  secretKeyBaseFile = \"/path/to/secret_key_base_file\";\n};\n\nc2FmZQ \n\nc2FmZQ is an application that can securely encrypt, store, and share files, including but not limited to pictures and videos.\n\nThe service c2fmzq-server can be enabled by setting\n\n{\n  services.c2fmzq-server.enable = true;\n}\n\n\nThis will spin up an instance of the server which is API-compatible with Stingle Photos and an experimental Progressive Web App (PWA) to interact with the storage via the browser.\n\nIn principle the server can be exposed directly on a public interface and there are command line options to manage HTTPS certificates directly, but the module is designed to be served behind a reverse proxy or only accessed via localhost.\n\n{\n  services.c2fmzq-server = {\n    enable = true;\n    bindIP = \"127.0.0.1\"; # default\n    port = 8080; # default\n  };\n\n  services.nginx = {\n    enable = true;\n    recommendedProxySettings = true;\n    virtualHosts.\"example.com\" = {\n      enableACME = true;\n      forceSSL = true;\n      locations.\"/\" = {\n        proxyPass = \"http://127.0.0.1:8080\";\n      };\n    };\n  };\n}\n\n\nFor more information, see https://github.com/c2FmZQ/c2FmZQ/.\n\nAkkoma \n\nTable of Contents\n\nService configuration\nUser management\nProxy configuration\nFrontend management\nFederation policies\nUpload filters\nMigration from Pleroma\nAdvanced deployment options\n\nAkkoma is a lightweight ActivityPub microblogging server forked from Pleroma.\n\nService configuration \n\nThe Elixir configuration file required by Akkoma is generated automatically from services.akkoma.config. Secrets must be included from external files outside of the Nix store by setting the configuration option to an attribute set containing the attribute _secret – a string pointing to the file containing the actual value of the option.\n\nFor the mandatory configuration settings these secrets will be generated automatically if the referenced file does not exist during startup, unless disabled through services.akkoma.initSecrets.\n\nThe following configuration binds Akkoma to the Unix socket /run/akkoma/socket, expecting to be run behind a HTTP proxy on fediverse.example.com.\n\nservices.akkoma.enable = true;\nservices.akkoma.config = {\n  \":pleroma\" = {\n    \":instance\" = {\n      name = \"My Akkoma instance\";\n      description = \"More detailed description\";\n      email = \"admin@example.com\";\n      registration_open = false;\n    };\n\n    \"Pleroma.Web.Endpoint\" = {\n      url.host = \"fediverse.example.com\";\n    };\n  };\n};\n\n\nPlease refer to the configuration cheat sheet for additional configuration options.\n\nUser management \n\nAfter the Akkoma service is running, the administration utility can be used to manage users. In particular an administrative user can be created with\n\n$ pleroma_ctl user new <nickname> <email> --admin --moderator --password <password>\n\nProxy configuration \n\nAlthough it is possible to expose Akkoma directly, it is common practice to operate it behind an HTTP reverse proxy such as nginx.\n\nservices.akkoma.nginx = {\n  enableACME = true;\n  forceSSL = true;\n};\n\nservices.nginx = {\n  enable = true;\n\n  clientMaxBodySize = \"16m\";\n  recommendedTlsSettings = true;\n  recommendedOptimisation = true;\n  recommendedGzipSettings = true;\n};\n\n\nPlease refer to SSL/TLS Certificates with ACME for details on how to provision an SSL/TLS certificate.\n\nMedia proxy \n\nWithout the media proxy function, Akkoma does not store any remote media like pictures or video locally, and clients have to fetch them directly from the source server.\n\n# Enable nginx slice module distributed with Tengine\nservices.nginx.package = pkgs.tengine;\n\n# Enable media proxy\nservices.akkoma.config.\":pleroma\".\":media_proxy\" = {\n  enabled = true;\n  proxy_opts.redirect_on_failure = true;\n};\n\n# Adjust the persistent cache size as needed:\n#  Assuming an average object size of 128 KiB, around 1 MiB\n#  of memory is required for the key zone per GiB of cache.\n# Ensure that the cache directory exists and is writable by nginx.\nservices.nginx.commonHttpConfig = ''\n  proxy_cache_path /var/cache/nginx/cache/akkoma-media-cache\n    levels= keys_zone=akkoma_media_cache:16m max_size=16g\n    inactive=1y use_temp_path=off;\n'';\n\nservices.akkoma.nginx = {\n  locations.\"/proxy\" = {\n    proxyPass = \"http://unix:/run/akkoma/socket\";\n\n    extraConfig = ''\n      proxy_cache akkoma_media_cache;\n\n      # Cache objects in slices of 1 MiB\n      slice 1m;\n      proxy_cache_key $host$uri$is_args$args$slice_range;\n      proxy_set_header Range $slice_range;\n\n      # Decouple proxy and upstream responses\n      proxy_buffering on;\n      proxy_cache_lock on;\n      proxy_ignore_client_abort on;\n\n      # Default cache times for various responses\n      proxy_cache_valid 200 1y;\n      proxy_cache_valid 206 301 304 1h;\n\n      # Allow serving of stale items\n      proxy_cache_use_stale error timeout invalid_header updating;\n    '';\n  };\n};\n\nPrefetch remote media\n\nThe following example enables the MediaProxyWarmingPolicy MRF policy which automatically fetches all media associated with a post through the media proxy, as soon as the post is received by the instance.\n\nservices.akkoma.config.\":pleroma\".\":mrf\".policies =\n  map (pkgs.formats.elixirConf { }).lib.mkRaw [\n    \"Pleroma.Web.ActivityPub.MRF.MediaProxyWarmingPolicy\"\n];\n\nMedia previews\n\nAkkoma can generate previews for media.\n\nservices.akkoma.config.\":pleroma\".\":media_preview_proxy\" = {\n  enabled = true;\n  thumbnail_max_width = 1920;\n  thumbnail_max_height = 1080;\n};\n\nFrontend management \n\nAkkoma will be deployed with the akkoma-fe and admin-fe frontends by default. These can be modified by setting services.akkoma.frontends.\n\nThe following example overrides the primary frontend’s default configuration using a custom derivation.\n\nservices.akkoma.frontends.primary.package = pkgs.runCommand \"akkoma-fe\" {\n  config = builtins.toJSON {\n    expertLevel = 1;\n    collapseMessageWithSubject = false;\n    stopGifs = false;\n    replyVisibility = \"following\";\n    webPushHideIfCW = true;\n    hideScopeNotice = true;\n    renderMisskeyMarkdown = false;\n    hideSiteFavicon = true;\n    postContentType = \"text/markdown\";\n    showNavShortcuts = false;\n  };\n  nativeBuildInputs = with pkgs; [ jq xorg.lndir ];\n  passAsFile = [ \"config\" ];\n} ''\n  mkdir $out\n  lndir ${pkgs.akkoma-frontends.akkoma-fe} $out\n\n  rm $out/static/config.json\n  jq -s add ${pkgs.akkoma-frontends.akkoma-fe}/static/config.json ${config} \\\n    >$out/static/config.json\n'';\n\nFederation policies \n\nAkkoma comes with a number of modules to police federation with other ActivityPub instances. The most valuable for typical users is the :mrf_simple module which allows limiting federation based on instance hostnames.\n\nThis configuration snippet provides an example on how these can be used. Choosing an adequate federation policy is not trivial and entails finding a balance between connectivity to the rest of the fediverse and providing a pleasant experience to the users of an instance.\n\nservices.akkoma.config.\":pleroma\" = with (pkgs.formats.elixirConf { }).lib; {\n  \":mrf\".policies = map mkRaw [\n    \"Pleroma.Web.ActivityPub.MRF.SimplePolicy\"\n  ];\n\n  \":mrf_simple\" = {\n    # Tag all media as sensitive\n    media_nsfw = mkMap {\n      \"nsfw.weird.kinky\" = \"Untagged NSFW content\";\n    };\n\n    # Reject all activities except deletes\n    reject = mkMap {\n      \"kiwifarms.cc\" = \"Persistent harassment of users, no moderation\";\n    };\n\n    # Force posts to be visible by followers only\n    followers_only = mkMap {\n      \"beta.birdsite.live\" = \"Avoid polluting timelines with Twitter posts\";\n    };\n  };\n};\n\nUpload filters \n\nThis example strips GPS and location metadata from uploads, deduplicates them and anonymises the the file name.\n\nservices.akkoma.config.\":pleroma\".\"Pleroma.Upload\".filters =\n  map (pkgs.formats.elixirConf { }).lib.mkRaw [\n    \"Pleroma.Upload.Filter.Exiftool\"\n    \"Pleroma.Upload.Filter.Dedupe\"\n    \"Pleroma.Upload.Filter.AnonymizeFilename\"\n  ];\n\nMigration from Pleroma \n\nPleroma instances can be migrated to Akkoma either by copying the database and upload data or by pointing Akkoma to the existing data. The necessary database migrations are run automatically during startup of the service.\n\nThe configuration has to be copy‐edited manually.\n\nDepending on the size of the database, the initial migration may take a long time and exceed the startup timeout of the system manager. To work around this issue one may adjust the startup timeout systemd.services.akkoma.serviceConfig.TimeoutStartSec or simply run the migrations manually:\n\npleroma_ctl migrate\n\nCopying data \n\nCopying the Pleroma data instead of re‐using it in place may permit easier reversion to Pleroma, but allows the two data sets to diverge.\n\nFirst disable Pleroma and then copy its database and upload data:\n\n# Create a copy of the database\nnix-shell -p postgresql --run 'createdb -T pleroma akkoma'\n\n# Copy upload data\nmkdir /var/lib/akkoma\ncp -R --reflink=auto /var/lib/pleroma/uploads /var/lib/akkoma/\n\n\nAfter the data has been copied, enable the Akkoma service and verify that the migration has been successful. If no longer required, the original data may then be deleted:\n\n# Delete original database\nnix-shell -p postgresql --run 'dropdb pleroma'\n\n# Delete original Pleroma state\nrm -r /var/lib/pleroma\n\nRe‐using data \n\nTo re‐use the Pleroma data in place, disable Pleroma and enable Akkoma, pointing it to the Pleroma database and upload directory.\n\n# Adjust these settings according to the database name and upload directory path used by Pleroma\nservices.akkoma.config.\":pleroma\".\"Pleroma.Repo\".database = \"pleroma\";\nservices.akkoma.config.\":pleroma\".\":instance\".upload_dir = \"/var/lib/pleroma/uploads\";\n\n\nPlease keep in mind that after the Akkoma service has been started, any migrations applied by Akkoma have to be rolled back before the database can be used again with Pleroma. This can be achieved through pleroma_ctl ecto.rollback. Refer to the Ecto SQL documentation for details.\n\nAdvanced deployment options \nConfinement \n\nThe Akkoma systemd service may be confined to a chroot with\n\nservices.systemd.akkoma.confinement.enable = true;\n\n\nConfinement of services is not generally supported in NixOS and therefore disabled by default. Depending on the Akkoma configuration, the default confinement settings may be insufficient and lead to subtle errors at run time, requiring adjustment:\n\nUse services.systemd.akkoma.confinement.packages to make packages available in the chroot.\n\nservices.systemd.akkoma.serviceConfig.BindPaths and services.systemd.akkoma.serviceConfig.BindReadOnlyPaths permit access to outside paths through bind mounts. Refer to BindPaths= of systemd.exec(5) for details.\n\nDistributed deployment \n\nBeing an Elixir application, Akkoma can be deployed in a distributed fashion.\n\nThis requires setting services.akkoma.dist.address and services.akkoma.dist.cookie. The specifics depend strongly on the deployment environment. For more information please check the relevant Erlang documentation.\n\nMeilisearch \n\nTable of Contents\n\nQuickstart\nUsage\nDefaults\nMissing\n\nMeilisearch is a lightweight, fast and powerful search engine. Think elastic search with a much smaller footprint.\n\nQuickstart \n\nthe minimum to start meilisearch is\n\nservices.meilisearch.enable = true;\n\n\nthis will start the http server included with meilisearch on port 7700.\n\ntest with curl -X GET 'http://localhost:7700/health'\n\nUsage \n\nyou first need to add documents to an index before you can search for documents.\n\nAdd a documents to the movies index \n\ncurl -X POST 'http://127.0.0.1:7700/indexes/movies/documents' --data '[{\"id\": \"123\", \"title\": \"Superman\"}, {\"id\": 234, \"title\": \"Batman\"}]'\n\nSearch documents in the movies index \n\ncurl 'http://127.0.0.1:7700/indexes/movies/search' --data '{ \"q\": \"botman\" }' (note the typo is intentional and there to demonstrate the typo tolerant capabilities)\n\nDefaults \n\nThe default nixos package doesn’t come with the dashboard, since the dashboard features makes some assets downloads at compile time.\n\nAnonymized Analytics sent to meilisearch are disabled by default.\n\nDefault deployment is development mode. It doesn’t require a secret master key. All routes are not protected and accessible.\n\nMissing \n\nthe snapshot feature is not yet configurable from the module, it’s just a matter of adding the relevant environment variables.\n\nYggdrasil \n\nTable of Contents\n\nConfiguration\n\nSource: modules/services/networking/yggdrasil/default.nix\n\nUpstream documentation: https://yggdrasil-network.github.io/\n\nYggdrasil is an early-stage implementation of a fully end-to-end encrypted, self-arranging IPv6 network.\n\nConfiguration \nSimple ephemeral node \n\nAn annotated example of a simple configuration:\n\n{\n  services.yggdrasil = {\n    enable = true;\n    persistentKeys = false;\n      # The NixOS module will generate new keys and a new IPv6 address each time\n      # it is started if persistentKeys is not enabled.\n\n    settings = {\n      Peers = [\n        # Yggdrasil will automatically connect and \"peer\" with other nodes it\n        # discovers via link-local multicast announcements. Unless this is the\n        # case (it probably isn't) a node needs peers within the existing\n        # network that it can tunnel to.\n        \"tcp://1.2.3.4:1024\"\n        \"tcp://1.2.3.5:1024\"\n        # Public peers can be found at\n        # https://github.com/yggdrasil-network/public-peers\n      ];\n    };\n  };\n}\n\nPersistent node with prefix \n\nA node with a fixed address that announces a prefix:\n\nlet\n  address = \"210:5217:69c0:9afc:1b95:b9f:8718:c3d2\";\n  prefix = \"310:5217:69c0:9afc\";\n  # taken from the output of \"yggdrasilctl getself\".\nin {\n\n  services.yggdrasil = {\n    enable = true;\n    persistentKeys = true; # Maintain a fixed public key and IPv6 address.\n    settings = {\n      Peers = [ \"tcp://1.2.3.4:1024\" \"tcp://1.2.3.5:1024\" ];\n      NodeInfo = {\n        # This information is visible to the network.\n        name = config.networking.hostName;\n        location = \"The North Pole\";\n      };\n    };\n  };\n\n  boot.kernel.sysctl.\"net.ipv6.conf.all.forwarding\" = 1;\n    # Forward traffic under the prefix.\n\n  networking.interfaces.${eth0}.ipv6.addresses = [{\n    # Set a 300::/8 address on the local physical device.\n    address = prefix + \"::1\";\n    prefixLength = 64;\n  }];\n\n  services.radvd = {\n    # Announce the 300::/8 prefix to eth0.\n    enable = true;\n    config = ''\n      interface eth0\n      {\n        AdvSendAdvert on;\n        prefix ${prefix}::/64 {\n          AdvOnLink on;\n          AdvAutonomous on;\n        };\n        route 200::/8 {};\n      };\n    '';\n  };\n}\n\nYggdrasil attached Container \n\nA NixOS container attached to the Yggdrasil network via a node running on the host:\n\nlet\n  yggPrefix64 = \"310:5217:69c0:9afc\";\n    # Again, taken from the output of \"yggdrasilctl getself\".\nin\n{\n  boot.kernel.sysctl.\"net.ipv6.conf.all.forwarding\" = 1;\n  # Enable IPv6 forwarding.\n\n  networking = {\n    bridges.br0.interfaces = [ ];\n    # A bridge only to containers…\n\n    interfaces.br0 = {\n      # … configured with a prefix address.\n      ipv6.addresses = [{\n        address = \"${yggPrefix64}::1\";\n        prefixLength = 64;\n      }];\n    };\n  };\n\n  containers.foo = {\n    autoStart = true;\n    privateNetwork = true;\n    hostBridge = \"br0\";\n    # Attach the container to the bridge only.\n    config = { config, pkgs, ... }: {\n      networking.interfaces.eth0.ipv6 = {\n        addresses = [{\n          # Configure a prefix address.\n          address = \"${yggPrefix64}::2\";\n          prefixLength = 64;\n        }];\n        routes = [{\n          # Configure the prefix route.\n          address = \"200::\";\n          prefixLength = 7;\n          via = \"${yggPrefix64}::1\";\n        }];\n      };\n\n      services.httpd.enable = true;\n      networking.firewall.allowedTCPPorts = [ 80 ];\n    };\n  };\n\n}\n\nProsody \n\nTable of Contents\n\nBasic usage\nLet’s Encrypt Configuration\n\nProsody is an open-source, modern XMPP server.\n\nBasic usage \n\nA common struggle for most XMPP newcomers is to find the right set of XMPP Extensions (XEPs) to setup. Forget to activate a few of those and your XMPP experience might turn into a nightmare!\n\nThe XMPP community tackles this problem by creating a meta-XEP listing a decent set of XEPs you should implement. This meta-XEP is issued every year, the 2020 edition being XEP-0423.\n\nThe NixOS Prosody module will implement most of these recommendend XEPs out of the box. That being said, two components still require some manual configuration: the Multi User Chat (MUC) and the HTTP File Upload ones. You’ll need to create a DNS subdomain for each of those. The current convention is to name your MUC endpoint conference.example.org and your HTTP upload domain upload.example.org.\n\nA good configuration to start with, including a Multi User Chat (MUC) endpoint as well as a HTTP File Upload endpoint will look like this:\n\nservices.prosody = {\n  enable = true;\n  admins = [ \"root@example.org\" ];\n  ssl.cert = \"/var/lib/acme/example.org/fullchain.pem\";\n  ssl.key = \"/var/lib/acme/example.org/key.pem\";\n  virtualHosts.\"example.org\" = {\n      enabled = true;\n      domain = \"example.org\";\n      ssl.cert = \"/var/lib/acme/example.org/fullchain.pem\";\n      ssl.key = \"/var/lib/acme/example.org/key.pem\";\n  };\n  muc = [ {\n      domain = \"conference.example.org\";\n  } ];\n  uploadHttp = {\n      domain = \"upload.example.org\";\n  };\n};\n\nLet’s Encrypt Configuration \n\nAs you can see in the code snippet from the previous section, you’ll need a single TLS certificate covering your main endpoint, the MUC one as well as the HTTP Upload one. We can generate such a certificate by leveraging the ACME extraDomainNames module option.\n\nProvided the setup detailed in the previous section, you’ll need the following acme configuration to generate a TLS certificate for the three endponits:\n\nsecurity.acme = {\n  email = \"root@example.org\";\n  acceptTerms = true;\n  certs = {\n    \"example.org\" = {\n      webroot = \"/var/www/example.org\";\n      email = \"root@example.org\";\n      extraDomainNames = [ \"conference.example.org\" \"upload.example.org\" ];\n    };\n  };\n};\n\nPleroma \n\nTable of Contents\n\nGenerating the Pleroma config\nInitializing the database\nEnabling the Pleroma service locally\nCreating the admin user\nConfiguring Nginx\n\nPleroma is a lightweight activity pub server.\n\nGenerating the Pleroma config \n\nThe pleroma_ctl CLI utility will prompt you some questions and it will generate an initial config file. This is an example of usage\n\n$ mkdir tmp-pleroma\n$ cd tmp-pleroma\n$ nix-shell -p pleroma-otp\n$ pleroma_ctl instance gen --output config.exs --output-psql setup.psql\n\n\nThe config.exs file can be further customized following the instructions on the upstream documentation. Many refinements can be applied also after the service is running.\n\nInitializing the database \n\nFirst, the Postgresql service must be enabled in the NixOS configuration\n\nservices.postgresql = {\n  enable = true;\n  package = pkgs.postgresql_13;\n};\n\n\nand activated with the usual\n\n$ nixos-rebuild switch\n\n\nThen you can create and seed the database, using the setup.psql file that you generated in the previous section, by running\n\n$ sudo -u postgres psql -f setup.psql\n\nEnabling the Pleroma service locally \n\nIn this section we will enable the Pleroma service only locally, so its configurations can be improved incrementally.\n\nThis is an example of configuration, where services.pleroma.configs option contains the content of the file config.exs, generated in the first section, but with the secrets (database password, endpoint secret key, salts, etc.) removed. Removing secrets is important, because otherwise they will be stored publicly in the Nix store.\n\nservices.pleroma = {\n  enable = true;\n  secretConfigFile = \"/var/lib/pleroma/secrets.exs\";\n  configs = [\n    ''\n    import Config\n\n    config :pleroma, Pleroma.Web.Endpoint,\n      url: [host: \"pleroma.example.net\", scheme: \"https\", port: 443],\n      http: [ip: {127, 0, 0, 1}, port: 4000]\n\n    config :pleroma, :instance,\n      name: \"Test\",\n      email: \"admin@example.net\",\n      notify_email: \"admin@example.net\",\n      limit: 5000,\n      registrations_open: true\n\n    config :pleroma, :media_proxy,\n      enabled: false,\n      redirect_on_failure: true\n\n    config :pleroma, Pleroma.Repo,\n      adapter: Ecto.Adapters.Postgres,\n      username: \"pleroma\",\n      database: \"pleroma\",\n      hostname: \"localhost\"\n\n    # Configure web push notifications\n    config :web_push_encryption, :vapid_details,\n      subject: \"mailto:admin@example.net\"\n\n    # ... TO CONTINUE ...\n    ''\n  ];\n};\n\n\nSecrets must be moved into a file pointed by services.pleroma.secretConfigFile, in our case /var/lib/pleroma/secrets.exs. This file can be created copying the previously generated config.exs file and then removing all the settings, except the secrets. This is an example\n\n# Pleroma instance passwords\n\nimport Config\n\nconfig :pleroma, Pleroma.Web.Endpoint,\n   secret_key_base: \"<the secret generated by pleroma_ctl>\",\n   signing_salt: \"<the secret generated by pleroma_ctl>\"\n\nconfig :pleroma, Pleroma.Repo,\n  password: \"<the secret generated by pleroma_ctl>\"\n\n# Configure web push notifications\nconfig :web_push_encryption, :vapid_details,\n  public_key: \"<the secret generated by pleroma_ctl>\",\n  private_key: \"<the secret generated by pleroma_ctl>\"\n\n# ... TO CONTINUE ...\n\n\nNote that the lines of the same configuration group are comma separated (i.e. all the lines end with a comma, except the last one), so when the lines with passwords are added or removed, commas must be adjusted accordingly.\n\nThe service can be enabled with the usual\n\n$ nixos-rebuild switch\n\n\nThe service is accessible only from the local 127.0.0.1:4000 port. It can be tested using a port forwarding like this\n\n$ ssh -L 4000:localhost:4000 myuser@example.net\n\n\nand then accessing http://localhost:4000 from a web browser.\n\nCreating the admin user \n\nAfter Pleroma service is running, all Pleroma administration utilities can be used. In particular an admin user can be created with\n\n$ pleroma_ctl user new <nickname> <email>  --admin --moderator --password <password>\n\nConfiguring Nginx \n\nIn this configuration, Pleroma is listening only on the local port 4000. Nginx can be configured as a Reverse Proxy, for forwarding requests from public ports to the Pleroma service. This is an example of configuration, using Let’s Encrypt for the TLS certificates\n\nsecurity.acme = {\n  email = \"root@example.net\";\n  acceptTerms = true;\n};\n\nservices.nginx = {\n  enable = true;\n  addSSL = true;\n\n  recommendedTlsSettings = true;\n  recommendedOptimisation = true;\n  recommendedGzipSettings = true;\n\n  recommendedProxySettings = false;\n  # NOTE: if enabled, the NixOS proxy optimizations will override the Pleroma\n  # specific settings, and they will enter in conflict.\n\n  virtualHosts = {\n    \"pleroma.example.net\" = {\n      http2 = true;\n      enableACME = true;\n      forceSSL = true;\n\n      locations.\"/\" = {\n        proxyPass = \"http://127.0.0.1:4000\";\n\n        extraConfig = ''\n          etag on;\n          gzip on;\n\n          add_header 'Access-Control-Allow-Origin' '*' always;\n          add_header 'Access-Control-Allow-Methods' 'POST, PUT, DELETE, GET, PATCH, OPTIONS' always;\n          add_header 'Access-Control-Allow-Headers' 'Authorization, Content-Type, Idempotency-Key' always;\n          add_header 'Access-Control-Expose-Headers' 'Link, X-RateLimit-Reset, X-RateLimit-Limit, X-RateLimit-Remaining, X-Request-Id' always;\n          if ($request_method = OPTIONS) {\n            return 204;\n          }\n          add_header X-XSS-Protection \"1; mode=block\";\n          add_header X-Permitted-Cross-Domain-Policies none;\n          add_header X-Frame-Options DENY;\n          add_header X-Content-Type-Options nosniff;\n          add_header Referrer-Policy same-origin;\n          add_header X-Download-Options noopen;\n          proxy_http_version 1.1;\n          proxy_set_header Upgrade $http_upgrade;\n          proxy_set_header Connection \"upgrade\";\n          proxy_set_header Host $host;\n\n          client_max_body_size 16m;\n          # NOTE: increase if users need to upload very big files\n        '';\n      };\n    };\n  };\n};\n\nMosquitto \n\nTable of Contents\n\nQuickstart\nConfiguration\n\nMosquitto is a MQTT broker often used for IoT or home automation data transport.\n\nQuickstart \n\nA minimal configuration for Mosquitto is\n\nservices.mosquitto = {\n  enable = true;\n  listeners = [ {\n    acl = [ \"pattern readwrite #\" ];\n    omitPasswordAuth = true;\n    settings.allow_anonymous = true;\n  } ];\n};\n\n\nThis will start a broker on port 1883, listening on all interfaces of the machine, allowing read/write access to all topics to any user without password requirements.\n\nUser authentication can be configured with the users key of listeners. A config that gives full read access to a user monitor and restricted write access to a user service could look like\n\nservices.mosquitto = {\n  enable = true;\n  listeners = [ {\n    users = {\n      monitor = {\n        acl = [ \"read #\" ];\n        password = \"monitor\";\n      };\n      service = {\n        acl = [ \"write service/#\" ];\n        password = \"service\";\n      };\n    };\n  } ];\n};\n\n\nTLS authentication is configured by setting TLS-related options of the listener:\n\nservices.mosquitto = {\n  enable = true;\n  listeners = [ {\n    port = 8883; # port change is not required, but helpful to avoid mistakes\n    # ...\n    settings = {\n      cafile = \"/path/to/mqtt.ca.pem\";\n      certfile = \"/path/to/mqtt.pem\";\n      keyfile = \"/path/to/mqtt.key\";\n    };\n  } ];\n\nConfiguration \n\nThe Mosquitto configuration has four distinct types of settings: the global settings of the daemon, listeners, plugins, and bridges. Bridges and listeners are part of the global configuration, plugins are part of listeners. Users of the broker are configured as parts of listeners rather than globally, allowing configurations in which a given user is only allowed to log in to the broker using specific listeners (eg to configure an admin user with full access to all topics, but restricted to localhost).\n\nAlmost all options of Mosquitto are available for configuration at their appropriate levels, some as NixOS options written in camel case, the remainders under settings with their exact names in the Mosquitto config file. The exceptions are acl_file (which is always set according to the acl attributes of a listener and its users) and per_listener_settings (which is always set to true).\n\nPassword authentication \n\nMosquitto can be run in two modes, with a password file or without. Each listener has its own password file, and different listeners may use different password files. Password file generation can be disabled by setting omitPasswordAuth = true for a listener; in this case it is necessary to either set settings.allow_anonymous = true to allow all logins, or to configure other authentication methods like TLS client certificates with settings.use_identity_as_username = true.\n\nThe default is to generate a password file for each listener from the users configured to that listener. Users with no configured password will not be added to the password file and thus will not be able to use the broker.\n\nACL format \n\nEvery listener has a Mosquitto acl_file attached to it. This ACL is configured via two attributes of the config:\n\nthe acl attribute of the listener configures pattern ACL entries and topic ACL entries for anonymous users. Each entry must be prefixed with pattern or topic to distinguish between these two cases.\n\nthe acl attribute of every user configures in the listener configured the ACL for that given user. Only topic ACLs are supported by Mosquitto in this setting, so no prefix is required or allowed.\n\nThe default ACL for a listener is empty, disallowing all accesses from all clients. To configure a completely open ACL, set acl = [ \"pattern readwrite #\" ] in the listener.\n\nFirefox Sync server \n\nTable of Contents\n\nQuickstart\nMore detailed setup\n\nA storage server for Firefox Sync that you can easily host yourself.\n\nQuickstart \n\nThe absolute minimal configuration for the sync server looks like this:\n\nservices.mysql.package = pkgs.mariadb;\n\nservices.firefox-syncserver = {\n  enable = true;\n  secrets = builtins.toFile \"sync-secrets\" ''\n    SYNC_MASTER_SECRET=this-secret-is-actually-leaked-to-/nix/store\n  '';\n  singleNode = {\n    enable = true;\n    hostname = \"localhost\";\n    url = \"http://localhost:5000\";\n  };\n};\n\n\nThis will start a sync server that is only accessible locally. Once the services is running you can navigate to about:config in your Firefox profile and set identity.sync.tokenserver.uri to http://localhost:5000/1.0/sync/1.5. Your browser will now use your local sync server for data storage.\n\nWarning\n\nThis configuration should never be used in production. It is not encrypted and stores its secrets in a world-readable location.\n\nMore detailed setup \n\nThe firefox-syncserver service provides a number of options to make setting up small deployment easier. These are grouped under the singleNode element of the option tree and allow simple configuration of the most important parameters.\n\nSingle node setup is split into two kinds of options: those that affect the sync server itself, and those that affect its surroundings. Options that affect the sync server are capacity, which configures how many accounts may be active on this instance, and url, which holds the URL under which the sync server can be accessed. The url can be configured automatically when using nginx.\n\nOptions that affect the surroundings of the sync server are enableNginx, enableTLS and hostname. If enableNginx is set the sync server module will automatically add an nginx virtual host to the system using hostname as the domain and set url accordingly. If enableTLS is set the module will also enable ACME certificates on the new virtual host and force all connections to be made via TLS.\n\nFor actual deployment it is also recommended to store the secrets file in a secure location.\n\nLitestream \n\nTable of Contents\n\nConfiguration\n\nLitestream is a standalone streaming replication tool for SQLite.\n\nConfiguration \n\nLitestream service is managed by a dedicated user named litestream which needs permission to the database file. Here’s an example config which gives required permissions to access grafana database:\n\n{ pkgs, ... }:\n{\n  users.users.litestream.extraGroups = [ \"grafana\" ];\n\n  systemd.services.grafana.serviceConfig.ExecStartPost = \"+\" + pkgs.writeShellScript \"grant-grafana-permissions\" ''\n    timeout=10\n\n    while [ ! -f /var/lib/grafana/data/grafana.db ];\n    do\n      if [ \"$timeout\" == 0 ]; then\n        echo \"ERROR: Timeout while waiting for /var/lib/grafana/data/grafana.db.\"\n        exit 1\n      fi\n\n      sleep 1\n\n      ((timeout--))\n    done\n\n    find /var/lib/grafana -type d -exec chmod -v 775 {} \\;\n    find /var/lib/grafana -type f -exec chmod -v 660 {} \\;\n  '';\n\n  services.litestream = {\n    enable = true;\n\n    environmentFile = \"/run/secrets/litestream\";\n\n    settings = {\n      dbs = [\n        {\n          path = \"/var/lib/grafana/data/grafana.db\";\n          replicas = [{\n            url = \"s3://mybkt.litestream.io/grafana\";\n          }];\n        }\n      ];\n    };\n  };\n}\n\nPrometheus exporters \n\nTable of Contents\n\nConfiguration\nAdding a new exporter\nUpdating an exporter module\n\nPrometheus exporters provide metrics for the prometheus monitoring system.\n\nConfiguration \n\nOne of the most common exporters is the node exporter, it provides hardware and OS metrics from the host it’s running on. The exporter could be configured as follows:\n\n  services.prometheus.exporters.node = {\n    enable = true;\n    port = 9100;\n    enabledCollectors = [\n      \"logind\"\n      \"systemd\"\n    ];\n    disabledCollectors = [\n      \"textfile\"\n    ];\n    openFirewall = true;\n    firewallFilter = \"-i br0 -p tcp -m tcp --dport 9100\";\n  };\n\n\nIt should now serve all metrics from the collectors that are explicitly enabled and the ones that are enabled by default, via http under /metrics. In this example the firewall should just allow incoming connections to the exporter’s port on the bridge interface br0 (this would have to be configured separately of course). For more information about configuration see man configuration.nix or search through the available options.\n\nPrometheus can now be configured to consume the metrics produced by the exporter:\n\n    services.prometheus = {\n      # ...\n\n      scrapeConfigs = [\n        {\n          job_name = \"node\";\n          static_configs = [{\n            targets = [ \"localhost:${toString config.services.prometheus.exporters.node.port}\" ];\n          }];\n        }\n      ];\n\n      # ...\n    }\n\nAdding a new exporter \n\nTo add a new exporter, it has to be packaged first (see nixpkgs/pkgs/servers/monitoring/prometheus/ for examples), then a module can be added. The postfix exporter is used in this example:\n\nSome default options for all exporters are provided by nixpkgs/nixos/modules/services/monitoring/prometheus/exporters.nix:\n\nenable\n\nport\n\nlistenAddress\n\nextraFlags\n\nopenFirewall\n\nfirewallFilter\n\nuser\n\ngroup\n\nAs there is already a package available, the module can now be added. This is accomplished by adding a new file to the nixos/modules/services/monitoring/prometheus/exporters/ directory, which will be called postfix.nix and contains all exporter specific options and configuration:\n\n# nixpkgs/nixos/modules/services/prometheus/exporters/postfix.nix\n{ config, lib, pkgs, options }:\n\nwith lib;\n\nlet\n  # for convenience we define cfg here\n  cfg = config.services.prometheus.exporters.postfix;\nin\n{\n  port = 9154; # The postfix exporter listens on this port by default\n\n  # `extraOpts` is an attribute set which contains additional options\n  # (and optional overrides for default options).\n  # Note that this attribute is optional.\n  extraOpts = {\n    telemetryPath = mkOption {\n      type = types.str;\n      default = \"/metrics\";\n      description = ''\n        Path under which to expose metrics.\n      '';\n    };\n    logfilePath = mkOption {\n      type = types.path;\n      default = /var/log/postfix_exporter_input.log;\n      example = /var/log/mail.log;\n      description = ''\n        Path where Postfix writes log entries.\n        This file will be truncated by this exporter!\n      '';\n    };\n    showqPath = mkOption {\n      type = types.path;\n      default = /var/spool/postfix/public/showq;\n      example = /var/lib/postfix/queue/public/showq;\n      description = ''\n        Path at which Postfix places its showq socket.\n      '';\n    };\n  };\n\n  # `serviceOpts` is an attribute set which contains configuration\n  # for the exporter's systemd service. One of\n  # `serviceOpts.script` and `serviceOpts.serviceConfig.ExecStart`\n  # has to be specified here. This will be merged with the default\n  # service configuration.\n  # Note that by default 'DynamicUser' is 'true'.\n  serviceOpts = {\n    serviceConfig = {\n      DynamicUser = false;\n      ExecStart = ''\n        ${pkgs.prometheus-postfix-exporter}/bin/postfix_exporter \\\n          --web.listen-address ${cfg.listenAddress}:${toString cfg.port} \\\n          --web.telemetry-path ${cfg.telemetryPath} \\\n          ${concatStringsSep \" \\\\\\n  \" cfg.extraFlags}\n      '';\n    };\n  };\n}\n\n\nThis should already be enough for the postfix exporter. Additionally one could now add assertions and conditional default values. This can be done in the ‘meta-module’ that combines all exporter definitions and generates the submodules: nixpkgs/nixos/modules/services/prometheus/exporters.nix\n\nUpdating an exporter module \n\nShould an exporter option change at some point, it is possible to add information about the change to the exporter definition similar to nixpkgs/nixos/modules/rename.nix:\n\n{ config, lib, pkgs, options }:\n\nwith lib;\n\nlet\n  cfg = config.services.prometheus.exporters.nginx;\nin\n{\n  port = 9113;\n  extraOpts = {\n    # additional module options\n    # ...\n  };\n  serviceOpts = {\n    # service configuration\n    # ...\n  };\n  imports = [\n    # 'services.prometheus.exporters.nginx.telemetryEndpoint' -> 'services.prometheus.exporters.nginx.telemetryPath'\n    (mkRenamedOptionModule [ \"telemetryEndpoint\" ] [ \"telemetryPath\" ])\n\n    # removed option 'services.prometheus.exporters.nginx.insecure'\n    (mkRemovedOptionModule [ \"insecure\" ] ''\n      This option was replaced by 'prometheus.exporters.nginx.sslVerify' which defaults to true.\n    '')\n    ({ options.warnings = options.warnings; })\n  ];\n}\n\nparsedmarc \n\nTable of Contents\n\nBasic usage\nLocal mail\nGrafana and GeoIP\n\nparsedmarc is a service which parses incoming DMARC reports and stores or sends them to a downstream service for further analysis. In combination with Elasticsearch, Grafana and the included Grafana dashboard, it provides a handy overview of DMARC reports over time.\n\nBasic usage \n\nA very minimal setup which reads incoming reports from an external email address and saves them to a local Elasticsearch instance looks like this:\n\nservices.parsedmarc = {\n  enable = true;\n  settings.imap = {\n    host = \"imap.example.com\";\n    user = \"alice@example.com\";\n    password = \"/path/to/imap_password_file\";\n  };\n  provision.geoIp = false; # Not recommended!\n};\n\n\nNote that GeoIP provisioning is disabled in the example for simplicity, but should be turned on for fully functional reports.\n\nLocal mail \n\nInstead of watching an external inbox, a local inbox can be automatically provisioned. The recipient’s name is by default set to dmarc, but can be configured in services.parsedmarc.provision.localMail.recipientName. You need to add an MX record pointing to the host. More concretely: for the example to work, an MX record needs to be set up for monitoring.example.com and the complete email address that should be configured in the domain’s dmarc policy is dmarc@monitoring.example.com.\n\nservices.parsedmarc = {\n  enable = true;\n  provision = {\n    localMail = {\n      enable = true;\n      hostname = monitoring.example.com;\n    };\n    geoIp = false; # Not recommended!\n  };\n};\n\nGrafana and GeoIP \n\nThe reports can be visualized and summarized with parsedmarc’s official Grafana dashboard. For all views to work, and for the data to be complete, GeoIP databases are also required. The following example shows a basic deployment where the provisioned Elasticsearch instance is automatically added as a Grafana datasource, and the dashboard is added to Grafana as well.\n\nservices.parsedmarc = {\n  enable = true;\n  provision = {\n    localMail = {\n      enable = true;\n      hostname = url;\n    };\n    grafana = {\n      datasource = true;\n      dashboard = true;\n    };\n  };\n};\n\n# Not required, but recommended for full functionality\nservices.geoipupdate = {\n  settings = {\n    AccountID = 000000;\n    LicenseKey = \"/path/to/license_key_file\";\n  };\n};\n\nservices.grafana = {\n  enable = true;\n  addr = \"0.0.0.0\";\n  domain = url;\n  rootUrl = \"https://\" + url;\n  protocol = \"socket\";\n  security = {\n    adminUser = \"admin\";\n    adminPasswordFile = \"/path/to/admin_password_file\";\n    secretKeyFile = \"/path/to/secret_key_file\";\n  };\n};\n\nservices.nginx = {\n  enable = true;\n  recommendedTlsSettings = true;\n  recommendedOptimisation = true;\n  recommendedGzipSettings = true;\n  recommendedProxySettings = true;\n  upstreams.grafana.servers.\"unix:/${config.services.grafana.socket}\" = {};\n  virtualHosts.${url} = {\n    root = config.services.grafana.staticRootPath;\n    enableACME = true;\n    forceSSL = true;\n    locations.\"/\".tryFiles = \"$uri @grafana\";\n    locations.\"@grafana\".proxyPass = \"http://grafana\";\n  };\n};\nusers.users.nginx.extraGroups = [ \"grafana\" ];\n\nGoss \n\nTable of Contents\n\nBasic Usage\n\ngoss is a YAML based serverspec alternative tool for validating a server’s configuration.\n\nBasic Usage \n\nA minimal configuration looks like this:\n\n{\n  services.goss = {\n    enable = true;\n\n    environment = {\n      GOSS_FMT = \"json\";\n      GOSS_LOGLEVEL = \"TRACE\";\n    };\n\n    settings = {\n      addr.\"tcp://localhost:8080\" = {\n        reachable = true;\n        local-address = \"127.0.0.1\";\n      };\n      command.\"check-goss-version\" = {\n        exec = \"${lib.getExe pkgs.goss} --version\";\n        exit-status = 0;\n      };\n      dns.localhost.resolvable = true;\n      file.\"/nix\" = {\n        filetype = \"directory\";\n        exists = true;\n      };\n      group.root.exists = true;\n      kernel-param.\"kernel.ostype\".value = \"Linux\";\n      service.goss = {\n        enabled = true;\n        running = true;\n      };\n      user.root.exists = true;\n    };\n  };\n}\n\nCert Spotter \n\nTable of Contents\n\nService Configuration\nOperation\nHooks\n\nCert Spotter is a tool for monitoring Certificate Transparency logs.\n\nService Configuration \n\nA basic config that notifies you of all certificate changes for your domain would look as follows:\n\nservices.certspotter = {\n  enable = true;\n  # replace example.org with your domain name\n  watchlist = [ \".example.org\" ];\n  emailRecipients = [ \"webmaster@example.org\" ];\n};\n\n# Configure an SMTP client\nprograms.msmtp.enable = true;\n# Or you can use any other module that provides sendmail, like\n# services.nullmailer, services.opensmtpd, services.postfix\n\n\nIn this case, the leading dot in \".example.org\" means that Cert Spotter should monitor not only example.org, but also all of its subdomains.\n\nOperation \n\nBy default, NixOS configures Cert Spotter to skip all certificates issued before its first launch, because checking the entire Certificate Transparency logs requires downloading tens of terabytes of data. If you want to check the entire logs for previously issued certificates, you have to set services.certspotter.startAtEnd to false and remove all previously saved log state in /var/lib/certspotter/logs. The downloaded logs aren’t saved, so if you add a new domain to the watchlist and want Cert Spotter to go through the logs again, you will have to remove /var/lib/certspotter/logs again.\n\nAfter catching up with the logs, Cert Spotter will start monitoring live logs. As of October 2023, it uses around 20 Mbps of traffic on average.\n\nHooks \n\nCert Spotter supports running custom hooks instead of (or in addition to) sending emails. Hooks are shell scripts that will be passed certain environment variables.\n\nTo see hook documentation, see Cert Spotter’s man pages:\n\nnix-shell -p certspotter --run 'man 8 certspotter-script'\n\n\nFor example, you can remove emailRecipients and send email notifications manually using the following hook:\n\nservices.certspotter.hooks = [\n  (pkgs.writeShellScript \"certspotter-hook\" ''\n    function print_email() {\n      echo \"Subject: [certspotter] $SUMMARY\"\n      echo \"Mime-Version: 1.0\"\n      echo \"Content-Type: text/plain; charset=US-ASCII\"\n      echo\n      cat \"$TEXT_FILENAME\"\n    }\n    print_email | ${config.services.certspotter.sendmailPath} -i webmaster@example.org\n  '')\n];\n\nWeeChat \n\nTable of Contents\n\nBasic Usage\nRe-attaching to WeeChat\n\nWeeChat is a fast and extensible IRC client.\n\nBasic Usage \n\nBy default, the module creates a systemd unit which runs the chat client in a detached screen session.\n\nThis can be done by enabling the weechat service:\n\n{ ... }:\n\n{\n  services.weechat.enable = true;\n}\n\n\nThe service is managed by a dedicated user named weechat in the state directory /var/lib/weechat.\n\nRe-attaching to WeeChat \n\nWeeChat runs in a screen session owned by a dedicated user. To explicitly allow your another user to attach to this session, the screenrc needs to be tweaked by adding multiuser support:\n\n{\n  programs.screen.screenrc = ''\n    multiuser on\n    acladd normal_user\n  '';\n}\n\n\nNow, the session can be re-attached like this:\n\nscreen -x weechat/weechat-screen\n\n\nThe session name can be changed using services.weechat.sessionName.\n\nTaskserver \n\nTable of Contents\n\nConfiguration\nThe nixos-taskserver tool\nDeclarative/automatic CA management\nManual CA management\n\nTaskserver is the server component of Taskwarrior, a free and open source todo list application.\n\nUpstream documentation: https://taskwarrior.org/docs/#taskd\n\nConfiguration \n\nTaskserver does all of its authentication via TLS using client certificates, so you either need to roll your own CA or purchase a certificate from a known CA, which allows creation of client certificates. These certificates are usually advertised as “server certificates”.\n\nSo in order to make it easier to handle your own CA, there is a helper tool called nixos-taskserver which manages the custom CA along with Taskserver organisations, users and groups.\n\nWhile the client certificates in Taskserver only authenticate whether a user is allowed to connect, every user has its own UUID which identifies it as an entity.\n\nWith nixos-taskserver the client certificate is created along with the UUID of the user, so it handles all of the credentials needed in order to setup the Taskwarrior client to work with a Taskserver.\n\nThe nixos-taskserver tool \n\nBecause Taskserver by default only provides scripts to setup users imperatively, the nixos-taskserver tool is used for addition and deletion of organisations along with users and groups defined by services.taskserver.organisations and as well for imperative set up.\n\nThe tool is designed to not interfere if the command is used to manually set up some organisations, users or groups.\n\nFor example if you add a new organisation using nixos-taskserver org add foo, the organisation is not modified and deleted no matter what you define in services.taskserver.organisations, even if you’re adding the same organisation in that option.\n\nThe tool is modelled to imitate the official taskd command, documentation for each subcommand can be shown by using the --help switch.\n\nDeclarative/automatic CA management \n\nEverything is done according to what you specify in the module options, however in order to set up a Taskwarrior client for synchronisation with a Taskserver instance, you have to transfer the keys and certificates to the client machine.\n\nThis is done using nixos-taskserver user export $orgname $username which is printing a shell script fragment to stdout which can either be used verbatim or adjusted to import the user on the client machine.\n\nFor example, let’s say you have the following configuration:\n\n{\n  services.taskserver.enable = true;\n  services.taskserver.fqdn = \"server\";\n  services.taskserver.listenHost = \"::\";\n  services.taskserver.organisations.my-company.users = [ \"alice\" ];\n}\n\n\nThis creates an organisation called my-company with the user alice.\n\nNow in order to import the alice user to another machine alicebox, all we need to do is something like this:\n\n$ ssh server nixos-taskserver user export my-company alice | sh\n\n\nOf course, if no SSH daemon is available on the server you can also copy & paste it directly into a shell.\n\nAfter this step the user should be set up and you can start synchronising your tasks for the first time with task sync init on alicebox.\n\nSubsequent synchronisation requests merely require the command task sync after that stage.\n\nManual CA management \n\nIf you set any options within service.taskserver.pki.manual.*, nixos-taskserver won’t issue certificates, but you can still use it for adding or removing user accounts.\n\nSourcehut \n\nTable of Contents\n\nBasic usage\nConfiguration\nUsing an alternative webserver as reverse-proxy (e.g. httpd)\n\nSourcehut is an open-source, self-hostable software development platform. The server setup can be automated using services.sourcehut.\n\nBasic usage \n\nSourcehut is a Python and Go based set of applications. This NixOS module also provides basic configuration integrating Sourcehut into locally running services.nginx, services.redis.servers.sourcehut, services.postfix and services.postgresql services.\n\nA very basic configuration may look like this:\n\n{ pkgs, ... }:\nlet\n  fqdn =\n    let\n      join = hostName: domain: hostName + optionalString (domain != null) \".${domain}\";\n    in join config.networking.hostName config.networking.domain;\nin {\n\n  networking = {\n    hostName = \"srht\";\n    domain = \"tld\";\n    firewall.allowedTCPPorts = [ 22 80 443 ];\n  };\n\n  services.sourcehut = {\n    enable = true;\n    git.enable = true;\n    man.enable = true;\n    meta.enable = true;\n    nginx.enable = true;\n    postfix.enable = true;\n    postgresql.enable = true;\n    redis.enable = true;\n    settings = {\n        \"sr.ht\" = {\n          environment = \"production\";\n          global-domain = fqdn;\n          origin = \"https://${fqdn}\";\n          # Produce keys with srht-keygen from sourcehut.coresrht.\n          network-key = \"/run/keys/path/to/network-key\";\n          service-key = \"/run/keys/path/to/service-key\";\n        };\n        webhooks.private-key= \"/run/keys/path/to/webhook-key\";\n    };\n  };\n\n  security.acme.certs.\"${fqdn}\".extraDomainNames = [\n    \"meta.${fqdn}\"\n    \"man.${fqdn}\"\n    \"git.${fqdn}\"\n  ];\n\n  services.nginx = {\n    enable = true;\n    # only recommendedProxySettings are strictly required, but the rest make sense as well.\n    recommendedTlsSettings = true;\n    recommendedOptimisation = true;\n    recommendedGzipSettings = true;\n    recommendedProxySettings = true;\n\n    # Settings to setup what certificates are used for which endpoint.\n    virtualHosts = {\n      \"${fqdn}\".enableACME = true;\n      \"meta.${fqdn}\".useACMEHost = fqdn:\n      \"man.${fqdn}\".useACMEHost = fqdn:\n      \"git.${fqdn}\".useACMEHost = fqdn:\n    };\n  };\n}\n\n\nThe hostName option is used internally to configure the nginx reverse-proxy. The settings attribute set is used by the configuration generator and the result is placed in /etc/sr.ht/config.ini.\n\nConfiguration \n\nAll configuration parameters are also stored in /etc/sr.ht/config.ini which is generated by the module and linked from the store to ensure that all values from config.ini can be modified by the module.\n\nUsing an alternative webserver as reverse-proxy (e.g. httpd) \n\nBy default, nginx is used as reverse-proxy for sourcehut. However, it’s possible to use e.g. httpd by explicitly disabling nginx using services.nginx.enable and fixing the settings.\n\nGitLab \n\nTable of Contents\n\nPrerequisites\nConfiguring\nMaintenance\n\nGitLab is a feature-rich git hosting service.\n\nPrerequisites \n\nThe gitlab service exposes only an Unix socket at /run/gitlab/gitlab-workhorse.socket. You need to configure a webserver to proxy HTTP requests to the socket.\n\nFor instance, the following configuration could be used to use nginx as frontend proxy:\n\nservices.nginx = {\n  enable = true;\n  recommendedGzipSettings = true;\n  recommendedOptimisation = true;\n  recommendedProxySettings = true;\n  recommendedTlsSettings = true;\n  virtualHosts.\"git.example.com\" = {\n    enableACME = true;\n    forceSSL = true;\n    locations.\"/\".proxyPass = \"http://unix:/run/gitlab/gitlab-workhorse.socket\";\n  };\n};\n\nConfiguring \n\nGitLab depends on both PostgreSQL and Redis and will automatically enable both services. In the case of PostgreSQL, a database and a role will be created.\n\nThe default state dir is /var/gitlab/state. This is where all data like the repositories and uploads will be stored.\n\nA basic configuration with some custom settings could look like this:\n\nservices.gitlab = {\n  enable = true;\n  databasePasswordFile = \"/var/keys/gitlab/db_password\";\n  initialRootPasswordFile = \"/var/keys/gitlab/root_password\";\n  https = true;\n  host = \"git.example.com\";\n  port = 443;\n  user = \"git\";\n  group = \"git\";\n  smtp = {\n    enable = true;\n    address = \"localhost\";\n    port = 25;\n  };\n  secrets = {\n    dbFile = \"/var/keys/gitlab/db\";\n    secretFile = \"/var/keys/gitlab/secret\";\n    otpFile = \"/var/keys/gitlab/otp\";\n    jwsFile = \"/var/keys/gitlab/jws\";\n  };\n  extraConfig = {\n    gitlab = {\n      email_from = \"gitlab-no-reply@example.com\";\n      email_display_name = \"Example GitLab\";\n      email_reply_to = \"gitlab-no-reply@example.com\";\n      default_projects_features = { builds = false; };\n    };\n  };\n};\n\n\nIf you’re setting up a new GitLab instance, generate new secrets. You for instance use tr -dc A-Za-z0-9 < /dev/urandom | head -c 128 > /var/keys/gitlab/db to generate a new db secret. Make sure the files can be read by, and only by, the user specified by services.gitlab.user. GitLab encrypts sensitive data stored in the database. If you’re restoring an existing GitLab instance, you must specify the secrets secret from config/secrets.yml located in your GitLab state folder.\n\nWhen incoming_mail.enabled is set to true in extraConfig an additional service called gitlab-mailroom is enabled for fetching incoming mail.\n\nRefer to Appendix A for all available configuration options for the services.gitlab module.\n\nMaintenance \nBackups \n\nBackups can be configured with the options in services.gitlab.backup. Use the services.gitlab.backup.startAt option to configure regular backups.\n\nTo run a manual backup, start the gitlab-backup service:\n\n$ systemctl start gitlab-backup.service\n\nRake tasks \n\nYou can run GitLab’s rake tasks with gitlab-rake which will be available on the system when GitLab is enabled. You will have to run the command as the user that you configured to run GitLab with.\n\nA list of all available rake tasks can be obtained by running:\n\n$ sudo -u git -H gitlab-rake -T\n\nMatrix \n\nTable of Contents\n\nSynapse Homeserver\nRegistering Matrix users\nElement (formerly known as Riot) Web Client\n\nMatrix is an open standard for interoperable, decentralised, real-time communication over IP. It can be used to power Instant Messaging, VoIP/WebRTC signalling, Internet of Things communication - or anywhere you need a standard HTTP API for publishing and subscribing to data whilst tracking the conversation history.\n\nThis chapter will show you how to set up your own, self-hosted Matrix homeserver using the Synapse reference homeserver, and how to serve your own copy of the Element web client. See the Try Matrix Now! overview page for links to Element Apps for Android and iOS, desktop clients, as well as bridges to other networks and other projects around Matrix.\n\nSynapse Homeserver \n\nSynapse is the reference homeserver implementation of Matrix from the core development team at matrix.org. The following configuration example will set up a synapse server for the example.org domain, served from the host myhostname.example.org. For more information, please refer to the installation instructions of Synapse .\n\n{ pkgs, lib, config, ... }:\nlet\n  fqdn = \"${config.networking.hostName}.${config.networking.domain}\";\n  baseUrl = \"https://${fqdn}\";\n  clientConfig.\"m.homeserver\".base_url = baseUrl;\n  serverConfig.\"m.server\" = \"${fqdn}:443\";\n  mkWellKnown = data: ''\n    default_type application/json;\n    add_header Access-Control-Allow-Origin *;\n    return 200 '${builtins.toJSON data}';\n  '';\nin {\n  networking.hostName = \"myhostname\";\n  networking.domain = \"example.org\";\n  networking.firewall.allowedTCPPorts = [ 80 443 ];\n\n  services.postgresql.enable = true;\n  services.postgresql.initialScript = pkgs.writeText \"synapse-init.sql\" ''\n    CREATE ROLE \"matrix-synapse\" WITH LOGIN PASSWORD 'synapse';\n    CREATE DATABASE \"matrix-synapse\" WITH OWNER \"matrix-synapse\"\n      TEMPLATE template0\n      LC_COLLATE = \"C\"\n      LC_CTYPE = \"C\";\n  '';\n\n  services.nginx = {\n    enable = true;\n    recommendedTlsSettings = true;\n    recommendedOptimisation = true;\n    recommendedGzipSettings = true;\n    recommendedProxySettings = true;\n    virtualHosts = {\n      # If the A and AAAA DNS records on example.org do not point on the same host as the\n      # records for myhostname.example.org, you can easily move the /.well-known\n      # virtualHost section of the code to the host that is serving example.org, while\n      # the rest stays on myhostname.example.org with no other changes required.\n      # This pattern also allows to seamlessly move the homeserver from\n      # myhostname.example.org to myotherhost.example.org by only changing the\n      # /.well-known redirection target.\n      \"${config.networking.domain}\" = {\n        enableACME = true;\n        forceSSL = true;\n        # This section is not needed if the server_name of matrix-synapse is equal to\n        # the domain (i.e. example.org from @foo:example.org) and the federation port\n        # is 8448.\n        # Further reference can be found in the docs about delegation under\n        # https://matrix-org.github.io/synapse/latest/delegate.html\n        locations.\"= /.well-known/matrix/server\".extraConfig = mkWellKnown serverConfig;\n        # This is usually needed for homeserver discovery (from e.g. other Matrix clients).\n        # Further reference can be found in the upstream docs at\n        # https://spec.matrix.org/latest/client-server-api/#getwell-knownmatrixclient\n        locations.\"= /.well-known/matrix/client\".extraConfig = mkWellKnown clientConfig;\n      };\n      \"${fqdn}\" = {\n        enableACME = true;\n        forceSSL = true;\n        # It's also possible to do a redirect here or something else, this vhost is not\n        # needed for Matrix. It's recommended though to *not put* element\n        # here, see also the section about Element.\n        locations.\"/\".extraConfig = ''\n          return 404;\n        '';\n        # Forward all Matrix API calls to the synapse Matrix homeserver. A trailing slash\n        # *must not* be used here.\n        locations.\"/_matrix\".proxyPass = \"http://[::1]:8008\";\n        # Forward requests for e.g. SSO and password-resets.\n        locations.\"/_synapse/client\".proxyPass = \"http://[::1]:8008\";\n      };\n    };\n  };\n\n  services.matrix-synapse = {\n    enable = true;\n    settings.server_name = config.networking.domain;\n    # The public base URL value must match the `base_url` value set in `clientConfig` above.\n    # The default value here is based on `server_name`, so if your `server_name` is different\n    # from the value of `fqdn` above, you will likely run into some mismatched domain names\n    # in client applications.\n    settings.public_baseurl = baseUrl;\n    settings.listeners = [\n      { port = 8008;\n        bind_addresses = [ \"::1\" ];\n        type = \"http\";\n        tls = false;\n        x_forwarded = true;\n        resources = [ {\n          names = [ \"client\" \"federation\" ];\n          compress = true;\n        } ];\n      }\n    ];\n  };\n}\n\nRegistering Matrix users \n\nIf you want to run a server with public registration by anybody, you can then enable services.matrix-synapse.settings.enable_registration = true;. Otherwise, or you can generate a registration secret with pwgen -s 64 1 and set it with services.matrix-synapse.settings.registration_shared_secret. To create a new user or admin, run the following after you have set the secret and have rebuilt NixOS:\n\n$ nix-shell -p matrix-synapse\n$ register_new_matrix_user -k your-registration-shared-secret http://localhost:8008\nNew user localpart: your-username\nPassword:\nConfirm password:\nMake admin [no]:\nSuccess!\n\n\nIn the example, this would create a user with the Matrix Identifier @your-username:example.org.\n\nWarning\n\nWhen using services.matrix-synapse.settings.registration_shared_secret, the secret will end up in the world-readable store. Instead it’s recommended to deploy the secret in an additional file like this:\n\nCreate a file with the following contents:\n\nregistration_shared_secret: your-very-secret-secret\n\n\nDeploy the file with a secret-manager such as deployment.keys from nixops(1) or sops-nix to e.g. /run/secrets/matrix-shared-secret and ensure that it’s readable by matrix-synapse.\n\nInclude the file like this in your configuration:\n\n{\n  services.matrix-synapse.extraConfigFiles = [\n    \"/run/secrets/matrix-shared-secret\"\n  ];\n}\n\nNote\n\nIt’s also possible to user alternative authentication mechanism such as LDAP (via matrix-synapse-ldap3) or OpenID.\n\nElement (formerly known as Riot) Web Client \n\nElement Web is the reference web client for Matrix and developed by the core team at matrix.org. Element was formerly known as Riot.im, see the Element introductory blog post for more information. The following snippet can be optionally added to the code before to complete the synapse installation with a web client served at https://element.myhostname.example.org and https://element.example.org. Alternatively, you can use the hosted copy at https://app.element.io/, or use other web clients or native client applications. Due to the /.well-known urls set up done above, many clients should fill in the required connection details automatically when you enter your Matrix Identifier. See Try Matrix Now! for a list of existing clients and their supported featureset.\n\n{\n  services.nginx.virtualHosts.\"element.${fqdn}\" = {\n    enableACME = true;\n    forceSSL = true;\n    serverAliases = [\n      \"element.${config.networking.domain}\"\n    ];\n\n    root = pkgs.element-web.override {\n      conf = {\n        default_server_config = clientConfig; # see `clientConfig` from the snippet above.\n      };\n    };\n  };\n}\n\nNote\n\nThe Element developers do not recommend running Element and your Matrix homeserver on the same fully-qualified domain name for security reasons. In the example, this means that you should not reuse the myhostname.example.org virtualHost to also serve Element, but instead serve it on a different subdomain, like element.example.org in the example. See the Element Important Security Notes for more information on this subject.\n\nMjolnir (Matrix Moderation Tool) \n\nTable of Contents\n\nMjolnir Setup\nSynapse Antispam Module\n\nThis chapter will show you how to set up your own, self-hosted Mjolnir instance.\n\nAs an all-in-one moderation tool, it can protect your server from malicious invites, spam messages, and whatever else you don’t want. In addition to server-level protection, Mjolnir is great for communities wanting to protect their rooms without having to use their personal accounts for moderation.\n\nThe bot by default includes support for bans, redactions, anti-spam, server ACLs, room directory changes, room alias transfers, account deactivation, room shutdown, and more.\n\nSee the README page and the Moderator’s guide for additional instructions on how to setup and use Mjolnir.\n\nFor additional settings see the default configuration.\n\nMjolnir Setup \n\nFirst create a new Room which will be used as a management room for Mjolnir. In this room, Mjolnir will log possible errors and debugging information. You’ll need to set this Room-ID in services.mjolnir.managementRoom.\n\nNext, create a new user for Mjolnir on your homeserver, if not present already.\n\nThe Mjolnir Matrix user expects to be free of any rate limiting. See Synapse #6286 for an example on how to achieve this.\n\nIf you want Mjolnir to be able to deactivate users, move room aliases, shutdown rooms, etc. you’ll need to make the Mjolnir user a Matrix server admin.\n\nNow invite the Mjolnir user to the management room.\n\nIt is recommended to use Pantalaimon, so your management room can be encrypted. This also applies if you are looking to moderate an encrypted room.\n\nTo enable the Pantalaimon E2E Proxy for mjolnir, enable services.mjolnir.pantalaimon. This will autoconfigure a new Pantalaimon instance, which will connect to the homeserver set in services.mjolnir.homeserverUrl and Mjolnir itself will be configured to connect to the new Pantalaimon instance.\n\n{\n  services.mjolnir = {\n    enable = true;\n    homeserverUrl = \"https://matrix.domain.tld\";\n    pantalaimon = {\n       enable = true;\n       username = \"mjolnir\";\n       passwordFile = \"/run/secrets/mjolnir-password\";\n    };\n    protectedRooms = [\n      \"https://matrix.to/#/!xxx:domain.tld\"\n    ];\n    managementRoom = \"!yyy:domain.tld\";\n  };\n}\n\nElement Matrix Services (EMS) \n\nIf you are using a managed “Element Matrix Services (EMS)” server, you will need to consent to the terms and conditions. Upon startup, an error log entry with a URL to the consent page will be generated.\n\nSynapse Antispam Module \n\nA Synapse module is also available to apply the same rulesets the bot uses across an entire homeserver.\n\nTo use the Antispam Module, add matrix-synapse-plugins.matrix-synapse-mjolnir-antispam to the Synapse plugin list and enable the mjolnir.Module module.\n\n{\n  services.matrix-synapse = {\n    plugins = with pkgs; [\n      matrix-synapse-plugins.matrix-synapse-mjolnir-antispam\n    ];\n    extraConfig = ''\n      modules:\n        - module: mjolnir.Module\n          config:\n            # Prevent servers/users in the ban lists from inviting users on this\n            # server to rooms. Default true.\n            block_invites: true\n            # Flag messages sent by servers/users in the ban lists as spam. Currently\n            # this means that spammy messages will appear as empty to users. Default\n            # false.\n            block_messages: false\n            # Remove users from the user directory search by filtering matrix IDs and\n            # display names by the entries in the user ban list. Default false.\n            block_usernames: false\n            # The room IDs of the ban lists to honour. Unlike other parts of Mjolnir,\n            # this list cannot be room aliases or permalinks. This server is expected\n            # to already be joined to the room - Mjolnir will not automatically join\n            # these rooms.\n            ban_lists:\n              - \"!roomid:example.org\"\n    '';\n  };\n}\n\nMailman \n\nTable of Contents\n\nBasic usage with Postfix\nUsing with other MTAs\n\nMailman is free software for managing electronic mail discussion and e-newsletter lists. Mailman and its web interface can be configured using the corresponding NixOS module. Note that this service is best used with an existing, securely configured Postfix setup, as it does not automatically configure this.\n\nBasic usage with Postfix \n\nFor a basic configuration with Postfix as the MTA, the following settings are suggested:\n\n{ config, ... }: {\n  services.postfix = {\n    enable = true;\n    relayDomains = [\"hash:/var/lib/mailman/data/postfix_domains\"];\n    sslCert = config.security.acme.certs.\"lists.example.org\".directory + \"/full.pem\";\n    sslKey = config.security.acme.certs.\"lists.example.org\".directory + \"/key.pem\";\n    config = {\n      transport_maps = [\"hash:/var/lib/mailman/data/postfix_lmtp\"];\n      local_recipient_maps = [\"hash:/var/lib/mailman/data/postfix_lmtp\"];\n    };\n  };\n  services.mailman = {\n    enable = true;\n    serve.enable = true;\n    hyperkitty.enable = true;\n    webHosts = [\"lists.example.org\"];\n    siteOwner = \"mailman@example.org\";\n  };\n  services.nginx.virtualHosts.\"lists.example.org\".enableACME = true;\n  networking.firewall.allowedTCPPorts = [ 25 80 443 ];\n}\n\n\nDNS records will also be required:\n\nAAAA and A records pointing to the host in question, in order for browsers to be able to discover the address of the web server;\n\nAn MX record pointing to a domain name at which the host is reachable, in order for other mail servers to be able to deliver emails to the mailing lists it hosts.\n\nAfter this has been done and appropriate DNS records have been set up, the Postorius mailing list manager and the Hyperkitty archive browser will be available at https://lists.example.org/. Note that this setup is not sufficient to deliver emails to most email providers nor to avoid spam – a number of additional measures for authenticating incoming and outgoing mails, such as SPF, DMARC and DKIM are necessary, but outside the scope of the Mailman module.\n\nUsing with other MTAs \n\nMailman also supports other MTA, though with a little bit more configuration. For example, to use Mailman with Exim, you can use the following settings:\n\n{ config, ... }: {\n  services = {\n    mailman = {\n      enable = true;\n      siteOwner = \"mailman@example.org\";\n      enablePostfix = false;\n      settings.mta = {\n        incoming = \"mailman.mta.exim4.LMTP\";\n        outgoing = \"mailman.mta.deliver.deliver\";\n        lmtp_host = \"localhost\";\n        lmtp_port = \"8024\";\n        smtp_host = \"localhost\";\n        smtp_port = \"25\";\n        configuration = \"python:mailman.config.exim4\";\n      };\n    };\n    exim = {\n      enable = true;\n      # You can configure Exim in a separate file to reduce configuration.nix clutter\n      config = builtins.readFile ./exim.conf;\n    };\n  };\n}\n\n\nThe exim config needs some special additions to work with Mailman. Currently NixOS can’t manage Exim config with such granularity. Please refer to Mailman documentation for more info on configuring Mailman for working with Exim.\n\nTrezor \n\nTrezor is an open-source cryptocurrency hardware wallet and security token allowing secure storage of private keys.\n\nIt offers advanced features such U2F two-factor authorization, SSH login through Trezor SSH agent, GPG and a password manager. For more information, guides and documentation, see https://wiki.trezor.io.\n\nTo enable Trezor support, add the following to your configuration.nix:\n\nservices.trezord.enable = true;\n\n\nThis will add all necessary udev rules and start Trezor Bridge.\n\nEmacs \n\nTable of Contents\n\nInstalling Emacs\nRunning Emacs as a Service\nConfiguring Emacs\n\nEmacs is an extensible, customizable, self-documenting real-time display editor — and more. At its core is an interpreter for Emacs Lisp, a dialect of the Lisp programming language with extensions to support text editing.\n\nEmacs runs within a graphical desktop environment using the X Window System, but works equally well on a text terminal. Under macOS, a “Mac port” edition is available, which uses Apple’s native GUI frameworks.\n\nNixpkgs provides a superior environment for running Emacs. It’s simple to create custom builds by overriding the default packages. Chaotic collections of Emacs Lisp code and extensions can be brought under control using declarative package management. NixOS even provides a systemd user service for automatically starting the Emacs daemon.\n\nInstalling Emacs \n\nEmacs can be installed in the normal way for Nix (see Package Management). In addition, a NixOS service can be enabled.\n\nThe Different Releases of Emacs \n\nNixpkgs defines several basic Emacs packages. The following are attributes belonging to the pkgs set:\n\nemacs\n\nThe latest stable version of Emacs using the GTK 2 widget toolkit.\n\nemacs-nox\n\nEmacs built without any dependency on X11 libraries.\n\nemacsMacport\n\nEmacs with the “Mac port” patches, providing a more native look and feel under macOS.\n\nIf those aren’t suitable, then the following imitation Emacs editors are also available in Nixpkgs: Zile, mg, Yi, jmacs.\n\nAdding Packages to Emacs \n\nEmacs includes an entire ecosystem of functionality beyond text editing, including a project planner, mail and news reader, debugger interface, calendar, and more.\n\nMost extensions are gotten with the Emacs packaging system (package.el) from Emacs Lisp Package Archive (ELPA), MELPA, MELPA Stable, and Org ELPA. Nixpkgs is regularly updated to mirror all these archives.\n\nUnder NixOS, you can continue to use package-list-packages and package-install to install packages. You can also declare the set of Emacs packages you need using the derivations from Nixpkgs. The rest of this section discusses declarative installation of Emacs packages through nixpkgs.\n\nThe first step to declare the list of packages you want in your Emacs installation is to create a dedicated derivation. This can be done in a dedicated emacs.nix file such as:\n\nExample 5. Nix expression to build Emacs with packages (emacs.nix)\n\n/*\nThis is a nix expression to build Emacs and some Emacs packages I like\nfrom source on any distribution where Nix is installed. This will install\nall the dependencies from the nixpkgs repository and build the binary files\nwithout interfering with the host distribution.\n\nTo build the project, type the following from the current directory:\n\n$ nix-build emacs.nix\n\nTo run the newly compiled executable:\n\n$ ./result/bin/emacs\n*/\n\n# The first non-comment line in this file indicates that\n# the whole file represents a function.\n{ pkgs ? import <nixpkgs> {} }:\n\nlet\n  # The let expression below defines a myEmacs binding pointing to the\n  # current stable version of Emacs. This binding is here to separate\n  # the choice of the Emacs binary from the specification of the\n  # required packages.\n  myEmacs = pkgs.emacs;\n  # This generates an emacsWithPackages function. It takes a single\n  # argument: a function from a package set to a list of packages\n  # (the packages that will be available in Emacs).\n  emacsWithPackages = (pkgs.emacsPackagesFor myEmacs).emacsWithPackages;\nin\n  # The rest of the file specifies the list of packages to install. In the\n  # example, two packages (magit and zerodark-theme) are taken from\n  # MELPA stable.\n  emacsWithPackages (epkgs: (with epkgs.melpaStablePackages; [\n    magit          # ; Integrate git <C-x g>\n    zerodark-theme # ; Nicolas' theme\n  ])\n  # Two packages (undo-tree and zoom-frm) are taken from MELPA.\n  ++ (with epkgs.melpaPackages; [\n    undo-tree      # ; <C-x u> to show the undo tree\n    zoom-frm       # ; increase/decrease font size for all buffers %lt;C-x C-+>\n  ])\n  # Three packages are taken from GNU ELPA.\n  ++ (with epkgs.elpaPackages; [\n    auctex         # ; LaTeX mode\n    beacon         # ; highlight my cursor when scrolling\n    nameless       # ; hide current package name everywhere in elisp code\n  ])\n  # notmuch is taken from a nixpkgs derivation which contains an Emacs mode.\n  ++ [\n    pkgs.notmuch   # From main packages set\n  ])\n\n\n\n\nThe result of this configuration will be an emacs command which launches Emacs with all of your chosen packages in the load-path.\n\nYou can check that it works by executing this in a terminal:\n\n$ nix-build emacs.nix\n$ ./result/bin/emacs -q\n\n\nand then typing M-x package-initialize. Check that you can use all the packages you want in this Emacs instance. For example, try switching to the zerodark theme through M-x load-theme <RET> zerodark <RET> y.\n\nTip\n\nA few popular extensions worth checking out are: auctex, company, edit-server, flycheck, helm, iedit, magit, multiple-cursors, projectile, and yasnippet.\n\nThe list of available packages in the various ELPA repositories can be seen with the following commands:\n\nExample 6. Querying Emacs packages\n\nnix-env -f \"<nixpkgs>\" -qaP -A emacs.pkgs.elpaPackages\nnix-env -f \"<nixpkgs>\" -qaP -A emacs.pkgs.melpaPackages\nnix-env -f \"<nixpkgs>\" -qaP -A emacs.pkgs.melpaStablePackages\nnix-env -f \"<nixpkgs>\" -qaP -A emacs.pkgs.orgPackages\n\n\n\n\nIf you are on NixOS, you can install this particular Emacs for all users by adding it to the list of system packages (see the section called “Declarative Package Management”). Simply modify your file configuration.nix to make it contain:\n\nExample 7. Custom Emacs in configuration.nix\n\n{\n environment.systemPackages = [\n   # [...]\n   (import /path/to/emacs.nix { inherit pkgs; })\n  ];\n}\n\n\n\n\nIn this case, the next nixos-rebuild switch will take care of adding your emacs to the PATH environment variable (see Changing the Configuration).\n\nIf you are not on NixOS or want to install this particular Emacs only for yourself, you can do so by adding it to your ~/.config/nixpkgs/config.nix (see Nixpkgs manual):\n\nExample 8. Custom Emacs in ~/.config/nixpkgs/config.nix\n\n{\n  packageOverrides = super: let self = super.pkgs; in {\n    myemacs = import /path/to/emacs.nix { pkgs = self; };\n  };\n}\n\n\n\n\nIn this case, the next nix-env -f '<nixpkgs>' -iA myemacs will take care of adding your emacs to the PATH environment variable.\n\nAdvanced Emacs Configuration \n\nIf you want, you can tweak the Emacs package itself from your emacs.nix. For example, if you want to have a GTK 3-based Emacs instead of the default GTK 2-based binary and remove the automatically generated emacs.desktop (useful if you only use emacsclient), you can change your file emacs.nix in this way:\n\nExample 9. Custom Emacs build\n\n{ pkgs ? import <nixpkgs> {} }:\nlet\n  myEmacs = (pkgs.emacs.override {\n    # Use gtk3 instead of the default gtk2\n    withGTK3 = true;\n    withGTK2 = false;\n  }).overrideAttrs (attrs: {\n    # I don't want emacs.desktop file because I only use\n    # emacsclient.\n    postInstall = (attrs.postInstall or \"\") + ''\n      rm $out/share/applications/emacs.desktop\n    '';\n  });\nin [...]\n\n\n\n\nAfter building this file as shown in Example 5, you will get an GTK 3-based Emacs binary pre-loaded with your favorite packages.\n\nRunning Emacs as a Service \n\nNixOS provides an optional systemd service which launches Emacs daemon with the user’s login session.\n\nSource: modules/services/editors/emacs.nix\n\nEnabling the Service \n\nTo install and enable the systemd user service for Emacs daemon, add the following to your configuration.nix:\n\nservices.emacs.enable = true;\nservices.emacs.package = import /home/cassou/.emacs.d { pkgs = pkgs; };\n\n\nThe services.emacs.package option allows a custom derivation to be used, for example, one created by emacsWithPackages.\n\nEnsure that the Emacs server is enabled for your user’s Emacs configuration, either by customizing the server-mode variable, or by adding (server-start) to ~/.emacs.d/init.el.\n\nTo start the daemon, execute the following:\n\n$ nixos-rebuild switch  # to activate the new configuration.nix\n$ systemctl --user daemon-reload        # to force systemd reload\n$ systemctl --user start emacs.service  # to start the Emacs daemon\n\n\nThe server should now be ready to serve Emacs clients.\n\nStarting the client \n\nEnsure that the Emacs server is enabled, either by customizing the server-mode variable, or by adding (server-start) to ~/.emacs.\n\nTo connect to the Emacs daemon, run one of the following:\n\nemacsclient FILENAME\nemacsclient --create-frame  # opens a new frame (window)\nemacsclient --create-frame --tty  # opens a new frame on the current terminal\n\nConfiguring the EDITOR variable \n\nIf services.emacs.defaultEditor is true, the EDITOR variable will be set to a wrapper script which launches emacsclient.\n\nAny setting of EDITOR in the shell config files will override services.emacs.defaultEditor. To make sure EDITOR refers to the Emacs wrapper script, remove any existing EDITOR assignment from .profile, .bashrc, .zshenv or any other shell config file.\n\nIf you have formed certain bad habits when editing files, these can be corrected with a shell alias to the wrapper script:\n\nalias vi=$EDITOR\n\nPer-User Enabling of the Service \n\nIn general, systemd user services are globally enabled by symlinks in /etc/systemd/user. In the case where Emacs daemon is not wanted for all users, it is possible to install the service but not globally enable it:\n\nservices.emacs.enable = false;\nservices.emacs.install = true;\n\n\nTo enable the systemd user service for just the currently logged in user, run:\n\nsystemctl --user enable emacs\n\n\nThis will add the symlink ~/.config/systemd/user/emacs.service.\n\nConfiguring Emacs \n\nIf you want to only use extension packages from Nixpkgs, you can add (setq package-archives nil) to your init file.\n\nAfter the declarative Emacs package configuration has been tested, previously downloaded packages can be cleaned up by removing ~/.emacs.d/elpa (do make a backup first, in case you forgot a package).\n\nA Major Mode for Nix Expressions \n\nOf interest may be melpaPackages.nix-mode, which provides syntax highlighting for the Nix language. This is particularly convenient if you regularly edit Nix files.\n\nAccessing man pages \n\nYou can use woman to get completion of all available man pages. For example, type M-x woman <RET> nixos-rebuild <RET>.\n\nEditing DocBook 5 XML Documents \n\nEmacs includes nXML, a major-mode for validating and editing XML documents. When editing DocBook 5.0 documents, such as this one, nXML needs to be configured with the relevant schema, which is not included.\n\nTo install the DocBook 5.0 schemas, either add pkgs.docbook5 to environment.systemPackages (NixOS), or run nix-env -f '<nixpkgs>' -iA docbook5 (Nix).\n\nThen customize the variable rng-schema-locating-files to include ~/.emacs.d/schemas.xml and put the following text into that file:\n\nExample 10. nXML Schema Configuration (~/.emacs.d/schemas.xml)\n\n<?xml version=\"1.0\"?>\n<!--\n  To let emacs find this file, evaluate:\n  (add-to-list 'rng-schema-locating-files \"~/.emacs.d/schemas.xml\")\n-->\n<locatingRules xmlns=\"http://thaiopensource.com/ns/locating-rules/1.0\">\n  <!--\n    Use this variation if pkgs.docbook5 is added to environment.systemPackages\n  -->\n  <namespace ns=\"http://docbook.org/ns/docbook\"\n             uri=\"/run/current-system/sw/share/xml/docbook-5.0/rng/docbookxi.rnc\"/>\n  <!--\n    Use this variation if installing schema with \"nix-env -iA pkgs.docbook5\".\n  <namespace ns=\"http://docbook.org/ns/docbook\"\n             uri=\"../.nix-profile/share/xml/docbook-5.0/rng/docbookxi.rnc\"/>\n  -->\n</locatingRules>\n\n\n\nLivebook \n\nTable of Contents\n\nBasic Usage\n\nLivebook is a web application for writing interactive and collaborative code notebooks.\n\nBasic Usage \n\nEnabling the livebook service creates a user systemd unit which runs the server.\n\n{ ... }:\n\n{\n  services.livebook = {\n    enableUserService = true;\n    port = 20123;\n    # See note below about security\n    environmentFile = pkgs.writeText \"livebook.env\" ''\n      LIVEBOOK_PASSWORD = \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\";\n    '';\n  };\n}\n\nNote\n\nThe Livebook server has the ability to run any command as the user it is running under, so securing access to it with a password is highly recommended.\n\nPutting the password in the Nix configuration like above is an easy way to get started but it is not recommended in the real world because the livebook.env file will be added to the world-readable Nix store. A better approach would be to put the password in some secure user-readable location and set environmentFile = /home/user/secure/livebook.env.\n\nBlackfire profiler \n\nSource: modules/services/development/blackfire.nix\n\nUpstream documentation: https://blackfire.io/docs/introduction\n\nBlackfire is a proprietary tool for profiling applications. There are several languages supported by the product but currently only PHP support is packaged in Nixpkgs. The back-end consists of a module that is loaded into the language runtime (called probe) and a service (agent) that the probe connects to and that sends the profiles to the server.\n\nTo use it, you will need to enable the agent and the probe on your server. The exact method will depend on the way you use PHP but here is an example of NixOS configuration for PHP-FPM:\n\nlet\n  php = pkgs.php.withExtensions ({ enabled, all }: enabled ++ (with all; [\n    blackfire\n  ]));\nin {\n  # Enable the probe extension for PHP-FPM.\n  services.phpfpm = {\n    phpPackage = php;\n  };\n\n  # Enable and configure the agent.\n  services.blackfire-agent = {\n    enable = true;\n    settings = {\n      # You will need to get credentials at https://blackfire.io/my/settings/credentials\n      # You can also use other options described in https://blackfire.io/docs/up-and-running/configuration/agent\n      server-id = \"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\";\n      server-token = \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\";\n    };\n  };\n\n  # Make the agent run on start-up.\n  # (WantedBy= from the upstream unit not respected: https://github.com/NixOS/nixpkgs/issues/81138)\n  # Alternately, you can start it manually with `systemctl start blackfire-agent`.\n  systemd.services.blackfire-agent.wantedBy = [ \"phpfpm-foo.service\" ];\n}\n\n\nOn your developer machine, you will also want to install the client (see blackfire package) or the browser extension to actually trigger the profiling.\n\nFlatpak \n\nSource: modules/services/desktop/flatpak.nix\n\nUpstream documentation: https://github.com/flatpak/flatpak/wiki\n\nFlatpak is a system for building, distributing, and running sandboxed desktop applications on Linux.\n\nTo enable Flatpak, add the following to your configuration.nix:\n\n  services.flatpak.enable = true;\n\n\nFor the sandboxed apps to work correctly, desktop integration portals need to be installed. If you run GNOME, this will be handled automatically for you; in other cases, you will need to add something like the following to your configuration.nix:\n\n  xdg.portal.extraPortals = [ pkgs.xdg-desktop-portal-gtk ];\n\n\nThen, you will need to add a repository, for example, Flathub, either using the following commands:\n\n$ flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo\n$ flatpak update\n\n\nor by opening the repository file in GNOME Software.\n\nFinally, you can search and install programs:\n\n$ flatpak search bustle\n$ flatpak install flathub org.freedesktop.Bustle\n$ flatpak run org.freedesktop.Bustle\n\n\nAgain, GNOME Software offers graphical interface for these tasks.\n\nPostgreSQL \n\nTable of Contents\n\nConfiguring\nUpgrading\nOptions\nPlugins\nJIT (Just-In-Time compilation)\n\nSource: modules/services/databases/postgresql.nix\n\nUpstream documentation: https://www.postgresql.org/docs/\n\nPostgreSQL is an advanced, free relational database.\n\nConfiguring \n\nTo enable PostgreSQL, add the following to your configuration.nix:\n\nservices.postgresql.enable = true;\nservices.postgresql.package = pkgs.postgresql_15;\n\n\nNote that you are required to specify the desired version of PostgreSQL (e.g. pkgs.postgresql_15). Since upgrading your PostgreSQL version requires a database dump and reload (see below), NixOS cannot provide a default value for services.postgresql.package such as the most recent release of PostgreSQL.\n\nBy default, PostgreSQL stores its databases in /var/lib/postgresql/$psqlSchema. You can override this using services.postgresql.dataDir, e.g.\n\nservices.postgresql.dataDir = \"/data/postgresql\";\n\nUpgrading \nNote\n\nThe steps below demonstrate how to upgrade from an older version to pkgs.postgresql_13. These instructions are also applicable to other versions.\n\nMajor PostgreSQL upgrades require a downtime and a few imperative steps to be called. This is the case because each major version has some internal changes in the databases’ state during major releases. Because of that, NixOS places the state into /var/lib/postgresql/&lt;version&gt; where each version can be obtained like this:\n\n$ nix-instantiate --eval -A postgresql_13.psqlSchema\n\"13\"\n\n\nFor an upgrade, a script like this can be used to simplify the process:\n\n{ config, pkgs, ... }:\n{\n  environment.systemPackages = [\n    (let\n      # XXX specify the postgresql package you'd like to upgrade to.\n      # Do not forget to list the extensions you need.\n      newPostgres = pkgs.postgresql_13.withPackages (pp: [\n        # pp.plv8\n      ]);\n    in pkgs.writeScriptBin \"upgrade-pg-cluster\" ''\n      set -eux\n      # XXX it's perhaps advisable to stop all services that depend on postgresql\n      systemctl stop postgresql\n\n      export NEWDATA=\"/var/lib/postgresql/${newPostgres.psqlSchema}\"\n\n      export NEWBIN=\"${newPostgres}/bin\"\n\n      export OLDDATA=\"${config.services.postgresql.dataDir}\"\n      export OLDBIN=\"${config.services.postgresql.package}/bin\"\n\n      install -d -m 0700 -o postgres -g postgres \"$NEWDATA\"\n      cd \"$NEWDATA\"\n      sudo -u postgres $NEWBIN/initdb -D \"$NEWDATA\"\n\n      sudo -u postgres $NEWBIN/pg_upgrade \\\n        --old-datadir \"$OLDDATA\" --new-datadir \"$NEWDATA\" \\\n        --old-bindir $OLDBIN --new-bindir $NEWBIN \\\n        \"$@\"\n    '')\n  ];\n}\n\n\nThe upgrade process is:\n\nRebuild nixos configuration with the configuration above added to your configuration.nix. Alternatively, add that into separate file and reference it in imports list.\n\nLogin as root (sudo su -)\n\nRun upgrade-pg-cluster. It will stop old postgresql, initialize a new one and migrate the old one to the new one. You may supply arguments like --jobs 4 and --link to speedup migration process. See https://www.postgresql.org/docs/current/pgupgrade.html for details.\n\nChange postgresql package in NixOS configuration to the one you were upgrading to via services.postgresql.package. Rebuild NixOS. This should start new postgres using upgraded data directory and all services you stopped during the upgrade.\n\nAfter the upgrade it’s advisable to analyze the new cluster.\n\nFor PostgreSQL ≥ 14, use the vacuumdb command printed by the upgrades script.\n\nFor PostgreSQL < 14, run (as su -l postgres in the services.postgresql.dataDir, in this example /var/lib/postgresql/13):\n\n$ ./analyze_new_cluster.sh\n\nWarning\n\nThe next step removes the old state-directory!\n\n$ ./delete_old_cluster.sh\n\nOptions \n\nA complete list of options for the PostgreSQL module may be found here.\n\nPlugins \n\nPlugins collection for each PostgreSQL version can be accessed with .pkgs. For example, for pkgs.postgresql_15 package, its plugin collection is accessed by pkgs.postgresql_15.pkgs:\n\n$ nix repl '<nixpkgs>'\n\nLoading '<nixpkgs>'...\nAdded 10574 variables.\n\nnix-repl> postgresql_15.pkgs.<TAB><TAB>\npostgresql_15.pkgs.cstore_fdw        postgresql_15.pkgs.pg_repack\npostgresql_15.pkgs.pg_auto_failover  postgresql_15.pkgs.pg_safeupdate\npostgresql_15.pkgs.pg_bigm           postgresql_15.pkgs.pg_similarity\npostgresql_15.pkgs.pg_cron           postgresql_15.pkgs.pg_topn\npostgresql_15.pkgs.pg_hll            postgresql_15.pkgs.pgjwt\npostgresql_15.pkgs.pg_partman        postgresql_15.pkgs.pgroonga\n...\n\n\nTo add plugins via NixOS configuration, set services.postgresql.extraPlugins:\n\nservices.postgresql.package = pkgs.postgresql_12;\nservices.postgresql.extraPlugins = with pkgs.postgresql_12.pkgs; [\n  pg_repack\n  postgis\n];\n\n\nYou can build custom PostgreSQL-with-plugins (to be used outside of NixOS) using function .withPackages. For example, creating a custom PostgreSQL package in an overlay can look like:\n\nself: super: {\n  postgresql_custom = self.postgresql_12.withPackages (ps: [\n    ps.pg_repack\n    ps.postgis\n  ]);\n}\n\n\nHere’s a recipe on how to override a particular plugin through an overlay:\n\nself: super: {\n  postgresql_15 = super.postgresql_15.override { this = self.postgresql_15; } // {\n    pkgs = super.postgresql_15.pkgs // {\n      pg_repack = super.postgresql_15.pkgs.pg_repack.overrideAttrs (_: {\n        name = \"pg_repack-v20181024\";\n        src = self.fetchzip {\n          url = \"https://github.com/reorg/pg_repack/archive/923fa2f3c709a506e111cc963034bf2fd127aa00.tar.gz\";\n          sha256 = \"17k6hq9xaax87yz79j773qyigm4fwk8z4zh5cyp6z0sxnwfqxxw5\";\n        };\n      });\n    };\n  };\n}\n\nJIT (Just-In-Time compilation) \n\nJIT-support in the PostgreSQL package is disabled by default because of the ~300MiB closure-size increase from the LLVM dependency. It can be optionally enabled in PostgreSQL with the following config option:\n\n{\n  services.postgresql.enableJIT = true;\n}\n\n\nThis makes sure that the jit-setting is set to on and a PostgreSQL package with JIT enabled is used. Further tweaking of the JIT compiler, e.g. setting a different query cost threshold via jit_above_cost can be done manually via services.postgresql.settings.\n\nThe attribute-names of JIT-enabled PostgreSQL packages are suffixed with _jit, i.e. for each pkgs.postgresql (and pkgs.postgresql_<major>) in nixpkgs there’s also a pkgs.postgresql_jit (and pkgs.postgresql_<major>_jit). Alternatively, a JIT-enabled variant can be derived from a given postgresql package via postgresql.withJIT. This is also useful if it’s not clear which attribute from nixpkgs was originally used (e.g. when working with config.services.postgresql.package or if the package was modified via an overlay) since all modifications are propagated to withJIT. I.e.\n\nwith import <nixpkgs> {\n  overlays = [\n    (self: super: {\n      postgresql = super.postgresql.overrideAttrs (_: { pname = \"foobar\"; });\n    })\n  ];\n};\npostgresql.withJIT.pname\n\n\nevaluates to \"foobar\".\n\nFoundationDB \n\nTable of Contents\n\nConfiguring and basic setup\nScaling processes and backup agents\nClustering\nClient connectivity\nClient authorization and TLS\nBackups and Disaster Recovery\nKnown limitations\nOptions\nFull documentation\n\nSource: modules/services/databases/foundationdb.nix\n\nUpstream documentation: https://apple.github.io/foundationdb/\n\nMaintainer: Austin Seipp\n\nAvailable version(s): 7.1.x\n\nFoundationDB (or “FDB”) is an open source, distributed, transactional key-value store.\n\nConfiguring and basic setup \n\nTo enable FoundationDB, add the following to your configuration.nix:\n\nservices.foundationdb.enable = true;\nservices.foundationdb.package = pkgs.foundationdb71; # FoundationDB 7.1.x\n\n\nThe services.foundationdb.package option is required, and must always be specified. Due to the fact FoundationDB network protocols and on-disk storage formats may change between (major) versions, and upgrades must be explicitly handled by the user, you must always manually specify this yourself so that the NixOS module will use the proper version. Note that minor, bugfix releases are always compatible.\n\nAfter running nixos-rebuild, you can verify whether FoundationDB is running by executing fdbcli (which is added to environment.systemPackages):\n\n$ sudo -u foundationdb fdbcli\nUsing cluster file `/etc/foundationdb/fdb.cluster'.\n\nThe database is available.\n\nWelcome to the fdbcli. For help, type `help'.\nfdb> status\n\nUsing cluster file `/etc/foundationdb/fdb.cluster'.\n\nConfiguration:\n  Redundancy mode        - single\n  Storage engine         - memory\n  Coordinators           - 1\n\nCluster:\n  FoundationDB processes - 1\n  Machines               - 1\n  Memory availability    - 5.4 GB per process on machine with least available\n  Fault Tolerance        - 0 machines\n  Server time            - 04/20/18 15:21:14\n\n...\n\nfdb>\n\n\nYou can also write programs using the available client libraries. For example, the following Python program can be run in order to grab the cluster status, as a quick example. (This example uses nix-shell shebang support to automatically supply the necessary Python modules).\n\na@link> cat fdb-status.py\n#! /usr/bin/env nix-shell\n#! nix-shell -i python -p python pythonPackages.foundationdb71\n\nimport fdb\nimport json\n\ndef main():\n    fdb.api_version(520)\n    db = fdb.open()\n\n    @fdb.transactional\n    def get_status(tr):\n        return str(tr['\\xff\\xff/status/json'])\n\n    obj = json.loads(get_status(db))\n    print('FoundationDB available: %s' % obj['client']['database_status']['available'])\n\nif __name__ == \"__main__\":\n    main()\na@link> chmod +x fdb-status.py\na@link> ./fdb-status.py\nFoundationDB available: True\na@link>\n\n\nFoundationDB is run under the foundationdb user and group by default, but this may be changed in the NixOS configuration. The systemd unit foundationdb.service controls the fdbmonitor process.\n\nBy default, the NixOS module for FoundationDB creates a single SSD-storage based database for development and basic usage. This storage engine is designed for SSDs and will perform poorly on HDDs; however it can handle far more data than the alternative “memory” engine and is a better default choice for most deployments. (Note that you can change the storage backend on-the-fly for a given FoundationDB cluster using fdbcli.)\n\nFurthermore, only 1 server process and 1 backup agent are started in the default configuration. See below for more on scaling to increase this.\n\nFoundationDB stores all data for all server processes under /var/lib/foundationdb. You can override this using services.foundationdb.dataDir, e.g.\n\nservices.foundationdb.dataDir = \"/data/fdb\";\n\n\nSimilarly, logs are stored under /var/log/foundationdb by default, and there is a corresponding services.foundationdb.logDir as well.\n\nScaling processes and backup agents \n\nScaling the number of server processes is quite easy; simply specify services.foundationdb.serverProcesses to be the number of FoundationDB worker processes that should be started on the machine.\n\nFoundationDB worker processes typically require 4GB of RAM per-process at minimum for good performance, so this option is set to 1 by default since the maximum amount of RAM is unknown. You’re advised to abide by this restriction, so pick a number of processes so that each has 4GB or more.\n\nA similar option exists in order to scale backup agent processes, services.foundationdb.backupProcesses. Backup agents are not as performance/RAM sensitive, so feel free to experiment with the number of available backup processes.\n\nClustering \n\nFoundationDB on NixOS works similarly to other Linux systems, so this section will be brief. Please refer to the full FoundationDB documentation for more on clustering.\n\nFoundationDB organizes clusters using a set of coordinators, which are just specially-designated worker processes. By default, every installation of FoundationDB on NixOS will start as its own individual cluster, with a single coordinator: the first worker process on localhost.\n\nCoordinators are specified globally using the /etc/foundationdb/fdb.cluster file, which all servers and client applications will use to find and join coordinators. Note that this file can not be managed by NixOS so easily: FoundationDB is designed so that it will rewrite the file at runtime for all clients and nodes when cluster coordinators change, with clients transparently handling this without intervention. It is fundamentally a mutable file, and you should not try to manage it in any way in NixOS.\n\nWhen dealing with a cluster, there are two main things you want to do:\n\nAdd a node to the cluster for storage/compute.\n\nPromote an ordinary worker to a coordinator.\n\nA node must already be a member of the cluster in order to properly be promoted to a coordinator, so you must always add it first if you wish to promote it.\n\nTo add a machine to a FoundationDB cluster:\n\nChoose one of the servers to start as the initial coordinator.\n\nCopy the /etc/foundationdb/fdb.cluster file from this server to all the other servers. Restart FoundationDB on all of these other servers, so they join the cluster.\n\nAll of these servers are now connected and working together in the cluster, under the chosen coordinator.\n\nAt this point, you can add as many nodes as you want by just repeating the above steps. By default there will still be a single coordinator: you can use fdbcli to change this and add new coordinators.\n\nAs a convenience, FoundationDB can automatically assign coordinators based on the redundancy mode you wish to achieve for the cluster. Once all the nodes have been joined, simply set the replication policy, and then issue the coordinators auto command\n\nFor example, assuming we have 3 nodes available, we can enable double redundancy mode, then auto-select coordinators. For double redundancy, 3 coordinators is ideal: therefore FoundationDB will make every node a coordinator automatically:\n\nfdbcli> configure double ssd\nfdbcli> coordinators auto\n\n\nThis will transparently update all the servers within seconds, and appropriately rewrite the fdb.cluster file, as well as informing all client processes to do the same.\n\nClient connectivity \n\nBy default, all clients must use the current fdb.cluster file to access a given FoundationDB cluster. This file is located by default in /etc/foundationdb/fdb.cluster on all machines with the FoundationDB service enabled, so you may copy the active one from your cluster to a new node in order to connect, if it is not part of the cluster.\n\nClient authorization and TLS \n\nBy default, any user who can connect to a FoundationDB process with the correct cluster configuration can access anything. FoundationDB uses a pluggable design to transport security, and out of the box it supports a LibreSSL-based plugin for TLS support. This plugin not only does in-flight encryption, but also performs client authorization based on the given endpoint’s certificate chain. For example, a FoundationDB server may be configured to only accept client connections over TLS, where the client TLS certificate is from organization Acme Co in the Research and Development unit.\n\nConfiguring TLS with FoundationDB is done using the services.foundationdb.tls options in order to control the peer verification string, as well as the certificate and its private key.\n\nNote that the certificate and its private key must be accessible to the FoundationDB user account that the server runs under. These files are also NOT managed by NixOS, as putting them into the store may reveal private information.\n\nAfter you have a key and certificate file in place, it is not enough to simply set the NixOS module options – you must also configure the fdb.cluster file to specify that a given set of coordinators use TLS. This is as simple as adding the suffix :tls to your cluster coordinator configuration, after the port number. For example, assuming you have a coordinator on localhost with the default configuration, simply specifying:\n\nXXXXXX:XXXXXX@127.0.0.1:4500:tls\n\n\nwill configure all clients and server processes to use TLS from now on.\n\nBackups and Disaster Recovery \n\nThe usual rules for doing FoundationDB backups apply on NixOS as written in the FoundationDB manual. However, one important difference is the security profile for NixOS: by default, the foundationdb systemd unit uses Linux namespaces to restrict write access to the system, except for the log directory, data directory, and the /etc/foundationdb/ directory. This is enforced by default and cannot be disabled.\n\nHowever, a side effect of this is that the fdbbackup command doesn’t work properly for local filesystem backups: FoundationDB uses a server process alongside the database processes to perform backups and copy the backups to the filesystem. As a result, this process is put under the restricted namespaces above: the backup process can only write to a limited number of paths.\n\nIn order to allow flexible backup locations on local disks, the FoundationDB NixOS module supports a services.foundationdb.extraReadWritePaths option. This option takes a list of paths, and adds them to the systemd unit, allowing the processes inside the service to write (and read) the specified directories.\n\nFor example, to create backups in /opt/fdb-backups, first set up the paths in the module options:\n\nservices.foundationdb.extraReadWritePaths = [ \"/opt/fdb-backups\" ];\n\n\nRestart the FoundationDB service, and it will now be able to write to this directory (even if it does not yet exist.) Note: this path must exist before restarting the unit. Otherwise, systemd will not include it in the private FoundationDB namespace (and it will not add it dynamically at runtime).\n\nYou can now perform a backup:\n\n$ sudo -u foundationdb fdbbackup start  -t default -d file:///opt/fdb-backups\n$ sudo -u foundationdb fdbbackup status -t default\n\nKnown limitations \n\nThe FoundationDB setup for NixOS should currently be considered beta. FoundationDB is not new software, but the NixOS compilation and integration has only undergone fairly basic testing of all the available functionality.\n\nThere is no way to specify individual parameters for individual fdbserver processes. Currently, all server processes inherit all the global fdbmonitor settings.\n\nRuby bindings are not currently installed.\n\nGo bindings are not currently installed.\n\nOptions \n\nNixOS’s FoundationDB module allows you to configure all of the most relevant configuration options for fdbmonitor, matching it quite closely. A complete list of options for the FoundationDB module may be found here. You should also read the FoundationDB documentation as well.\n\nFull documentation \n\nFoundationDB is a complex piece of software, and requires careful administration to properly use. Full documentation for administration can be found here: https://apple.github.io/foundationdb/.\n\nBorgBackup \n\nTable of Contents\n\nConfiguring\nBasic usage for a local backup\nCreate a borg backup server\nBackup to the borg repository server\nBackup to a hosting service\nVorta backup client for the desktop\n\nSource: modules/services/backup/borgbackup.nix\n\nUpstream documentation: https://borgbackup.readthedocs.io/\n\nBorgBackup (short: Borg) is a deduplicating backup program. Optionally, it supports compression and authenticated encryption.\n\nThe main goal of Borg is to provide an efficient and secure way to backup data. The data deduplication technique used makes Borg suitable for daily backups since only changes are stored. The authenticated encryption technique makes it suitable for backups to not fully trusted targets.\n\nConfiguring \n\nA complete list of options for the Borgbase module may be found here.\n\nBasic usage for a local backup \n\nA very basic configuration for backing up to a locally accessible directory is:\n\n{\n    opt.services.borgbackup.jobs = {\n      { rootBackup = {\n          paths = \"/\";\n          exclude = [ \"/nix\" \"/path/to/local/repo\" ];\n          repo = \"/path/to/local/repo\";\n          doInit = true;\n          encryption = {\n            mode = \"repokey\";\n            passphrase = \"secret\";\n          };\n          compression = \"auto,lzma\";\n          startAt = \"weekly\";\n        };\n      }\n    };\n}\n\nWarning\n\nIf you do not want the passphrase to be stored in the world-readable Nix store, use passCommand. You find an example below.\n\nCreate a borg backup server \n\nYou should use a different SSH key for each repository you write to, because the specified keys are restricted to running borg serve and can only access this single repository. You need the output of the generate pub file.\n\n# sudo ssh-keygen -N '' -t ed25519 -f /run/keys/id_ed25519_my_borg_repo\n# cat /run/keys/id_ed25519_my_borg_repo\nssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAID78zmOyA+5uPG4Ot0hfAy+sLDPU1L4AiIoRYEIVbbQ/ root@nixos\n\n\nAdd the following snippet to your NixOS configuration:\n\n{\n  services.borgbackup.repos = {\n    my_borg_repo = {\n      authorizedKeys = [\n        \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAID78zmOyA+5uPG4Ot0hfAy+sLDPU1L4AiIoRYEIVbbQ/ root@nixos\"\n      ] ;\n      path = \"/var/lib/my_borg_repo\" ;\n    };\n  };\n}\n\nBackup to the borg repository server \n\nThe following NixOS snippet creates an hourly backup to the service (on the host nixos) as created in the section above. We assume that you have stored a secret passphrasse in the file /run/keys/borgbackup_passphrase, which should be only accessible by root\n\n{\n  services.borgbackup.jobs = {\n    backupToLocalServer = {\n      paths = [ \"/etc/nixos\" ];\n      doInit = true;\n      repo =  \"borg@nixos:.\" ;\n      encryption = {\n        mode = \"repokey-blake2\";\n        passCommand = \"cat /run/keys/borgbackup_passphrase\";\n      };\n      environment = { BORG_RSH = \"ssh -i /run/keys/id_ed25519_my_borg_repo\"; };\n      compression = \"auto,lzma\";\n      startAt = \"hourly\";\n    };\n  };\n};\n\n\nThe following few commands (run as root) let you test your backup.\n\n> nixos-rebuild switch\n...restarting the following units: polkit.service\n> systemctl restart borgbackup-job-backupToLocalServer\n> sleep 10\n> systemctl restart borgbackup-job-backupToLocalServer\n> export BORG_PASSPHRASE=topSecrect\n> borg list --rsh='ssh -i /run/keys/id_ed25519_my_borg_repo' borg@nixos:.\nnixos-backupToLocalServer-2020-03-30T21:46:17 Mon, 2020-03-30 21:46:19 [84feb97710954931ca384182f5f3cb90665f35cef214760abd7350fb064786ac]\nnixos-backupToLocalServer-2020-03-30T21:46:30 Mon, 2020-03-30 21:46:32 [e77321694ecd160ca2228611747c6ad1be177d6e0d894538898de7a2621b6e68]\n\nBackup to a hosting service \n\nSeveral companies offer (paid) hosting services for Borg repositories.\n\nTo backup your home directory to borgbase you have to:\n\nGenerate a SSH key without a password, to access the remote server. E.g.\n\nsudo ssh-keygen -N '' -t ed25519 -f /run/keys/id_ed25519_borgbase\n\n\nCreate the repository on the server by following the instructions for your hosting server.\n\nInitialize the repository on the server. Eg.\n\nsudo borg init --encryption=repokey-blake2  \\\n    --rsh \"ssh -i /run/keys/id_ed25519_borgbase\" \\\n    zzz2aaaaa@zzz2aaaaa.repo.borgbase.com:repo\n\n\nAdd it to your NixOS configuration, e.g.\n\n{\n    services.borgbackup.jobs = {\n    my_Remote_Backup = {\n        paths = [ \"/\" ];\n        exclude = [ \"/nix\" \"'**/.cache'\" ];\n        repo =  \"zzz2aaaaa@zzz2aaaaa.repo.borgbase.com:repo\";\n          encryption = {\n          mode = \"repokey-blake2\";\n          passCommand = \"cat /run/keys/borgbackup_passphrase\";\n        };\n        environment = { BORG_RSH = \"ssh -i /run/keys/id_ed25519_borgbase\"; };\n        compression = \"auto,lzma\";\n        startAt = \"daily\";\n    };\n  };\n}}\n\nVorta backup client for the desktop \n\nVorta is a backup client for macOS and Linux desktops. It integrates the mighty BorgBackup with your desktop environment to protect your data from disk failure, ransomware and theft.\n\nIt can be installed in NixOS e.g. by adding pkgs.vorta to environment.systemPackages.\n\nDetails about using Vorta can be found under https://vorta.borgbase.com .\n\nCastopod \n\nTable of Contents\n\nQuickstart\n\nCastopod is an open-source hosting platform made for podcasters who want to engage and interact with their audience.\n\nQuickstart \n\nUse the following configuration to start a public instance of Castopod on castopod.example.com domain:\n\nnetworking.firewall.allowedTCPPorts = [ 80 443 ];\nservices.castopod = {\n  enable = true;\n  database.createLocally = true;\n  nginx.virtualHost = {\n    serverName = \"castopod.example.com\";\n    enableACME = true;\n    forceSSL = true;\n  };\n};\n\n\nGo to https://castopod.example.com/cp-install to create superadmin account after applying the above configuration.\n\nSSL/TLS Certificates with ACME \n\nTable of Contents\n\nPrerequisites\nUsing ACME certificates in Nginx\nUsing ACME certificates in Apache/httpd\nManual configuration of HTTP-01 validation\nConfiguring ACME for DNS validation\nUsing DNS validation with web server virtual hosts\nUsing ACME with services demanding root owned certificates\nRegenerating certificates\nFixing JWS Verification error\n\nNixOS supports automatic domain validation & certificate retrieval and renewal using the ACME protocol. Any provider can be used, but by default NixOS uses Let’s Encrypt. The alternative ACME client lego is used under the hood.\n\nAutomatic cert validation and configuration for Apache and Nginx virtual hosts is included in NixOS, however if you would like to generate a wildcard cert or you are not using a web server you will have to configure DNS based validation.\n\nPrerequisites \n\nTo use the ACME module, you must accept the provider’s terms of service by setting security.acme.acceptTerms to true. The Let’s Encrypt ToS can be found here.\n\nYou must also set an email address to be used when creating accounts with Let’s Encrypt. You can set this for all certs with security.acme.defaults.email and/or on a per-cert basis with security.acme.certs.<name>.email. This address is only used for registration and renewal reminders, and cannot be used to administer the certificates in any way.\n\nAlternatively, you can use a different ACME server by changing the security.acme.defaults.server option to a provider of your choosing, or just change the server for one cert with security.acme.certs.<name>.server.\n\nYou will need an HTTP server or DNS server for verification. For HTTP, the server must have a webroot defined that can serve .well-known/acme-challenge. This directory must be writeable by the user that will run the ACME client. For DNS, you must set up credentials with your provider/server for use with lego.\n\nUsing ACME certificates in Nginx \n\nNixOS supports fetching ACME certificates for you by setting enableACME = true; in a virtualHost config. We first create self-signed placeholder certificates in place of the real ACME certs. The placeholder certs are overwritten when the ACME certs arrive. For foo.example.com the config would look like this:\n\nsecurity.acme.acceptTerms = true;\nsecurity.acme.defaults.email = \"admin+acme@example.com\";\nservices.nginx = {\n  enable = true;\n  virtualHosts = {\n    \"foo.example.com\" = {\n      forceSSL = true;\n      enableACME = true;\n      # All serverAliases will be added as extra domain names on the certificate.\n      serverAliases = [ \"bar.example.com\" ];\n      locations.\"/\" = {\n        root = \"/var/www\";\n      };\n    };\n\n    # We can also add a different vhost and reuse the same certificate\n    # but we have to append extraDomainNames manually beforehand:\n    # security.acme.certs.\"foo.example.com\".extraDomainNames = [ \"baz.example.com\" ];\n    \"baz.example.com\" = {\n      forceSSL = true;\n      useACMEHost = \"foo.example.com\";\n      locations.\"/\" = {\n        root = \"/var/www\";\n      };\n    };\n  };\n}\n\nUsing ACME certificates in Apache/httpd \n\nUsing ACME certificates with Apache virtual hosts is identical to using them with Nginx. The attribute names are all the same, just replace “nginx” with “httpd” where appropriate.\n\nManual configuration of HTTP-01 validation \n\nFirst off you will need to set up a virtual host to serve the challenges. This example uses a vhost called certs.example.com, with the intent that you will generate certs for all your vhosts and redirect everyone to HTTPS.\n\nsecurity.acme.acceptTerms = true;\nsecurity.acme.defaults.email = \"admin+acme@example.com\";\n\n# /var/lib/acme/.challenges must be writable by the ACME user\n# and readable by the Nginx user. The easiest way to achieve\n# this is to add the Nginx user to the ACME group.\nusers.users.nginx.extraGroups = [ \"acme\" ];\n\nservices.nginx = {\n  enable = true;\n  virtualHosts = {\n    \"acmechallenge.example.com\" = {\n      # Catchall vhost, will redirect users to HTTPS for all vhosts\n      serverAliases = [ \"*.example.com\" ];\n      locations.\"/.well-known/acme-challenge\" = {\n        root = \"/var/lib/acme/.challenges\";\n      };\n      locations.\"/\" = {\n        return = \"301 https://$host$request_uri\";\n      };\n    };\n  };\n}\n# Alternative config for Apache\nusers.users.wwwrun.extraGroups = [ \"acme\" ];\nservices.httpd = {\n  enable = true;\n  virtualHosts = {\n    \"acmechallenge.example.com\" = {\n      # Catchall vhost, will redirect users to HTTPS for all vhosts\n      serverAliases = [ \"*.example.com\" ];\n      # /var/lib/acme/.challenges must be writable by the ACME user and readable by the Apache user.\n      # By default, this is the case.\n      documentRoot = \"/var/lib/acme/.challenges\";\n      extraConfig = ''\n        RewriteEngine On\n        RewriteCond %{HTTPS} off\n        RewriteCond %{REQUEST_URI} !^/\\.well-known/acme-challenge [NC]\n        RewriteRule (.*) https://%{HTTP_HOST}%{REQUEST_URI} [R=301]\n      '';\n    };\n  };\n}\n\n\nNow you need to configure ACME to generate a certificate.\n\nsecurity.acme.certs.\"foo.example.com\" = {\n  webroot = \"/var/lib/acme/.challenges\";\n  email = \"foo@example.com\";\n  # Ensure that the web server you use can read the generated certs\n  # Take a look at the group option for the web server you choose.\n  group = \"nginx\";\n  # Since we have a wildcard vhost to handle port 80,\n  # we can generate certs for anything!\n  # Just make sure your DNS resolves them.\n  extraDomainNames = [ \"mail.example.com\" ];\n};\n\n\nThe private key key.pem and certificate fullchain.pem will be put into /var/lib/acme/foo.example.com.\n\nRefer to Appendix A for all available configuration options for the security.acme module.\n\nConfiguring ACME for DNS validation \n\nThis is useful if you want to generate a wildcard certificate, since ACME servers will only hand out wildcard certs over DNS validation. There are a number of supported DNS providers and servers you can utilise, see the lego docs for provider/server specific configuration values. For the sake of these docs, we will provide a fully self-hosted example using bind.\n\nservices.bind = {\n  enable = true;\n  extraConfig = ''\n    include \"/var/lib/secrets/dnskeys.conf\";\n  '';\n  zones = [\n    rec {\n      name = \"example.com\";\n      file = \"/var/db/bind/${name}\";\n      master = true;\n      extraConfig = \"allow-update { key rfc2136key.example.com.; };\";\n    }\n  ];\n}\n\n# Now we can configure ACME\nsecurity.acme.acceptTerms = true;\nsecurity.acme.defaults.email = \"admin+acme@example.com\";\nsecurity.acme.certs.\"example.com\" = {\n  domain = \"*.example.com\";\n  dnsProvider = \"rfc2136\";\n  environmentFile = \"/var/lib/secrets/certs.secret\";\n  # We don't need to wait for propagation since this is a local DNS server\n  dnsPropagationCheck = false;\n};\n\n\nThe dnskeys.conf and certs.secret must be kept secure and thus you should not keep their contents in your Nix config. Instead, generate them one time with a systemd service:\n\nsystemd.services.dns-rfc2136-conf = {\n  requiredBy = [\"acme-example.com.service\" \"bind.service\"];\n  before = [\"acme-example.com.service\" \"bind.service\"];\n  unitConfig = {\n    ConditionPathExists = \"!/var/lib/secrets/dnskeys.conf\";\n  };\n  serviceConfig = {\n    Type = \"oneshot\";\n    UMask = 0077;\n  };\n  path = [ pkgs.bind ];\n  script = ''\n    mkdir -p /var/lib/secrets\n    chmod 755 /var/lib/secrets\n    tsig-keygen rfc2136key.example.com > /var/lib/secrets/dnskeys.conf\n    chown named:root /var/lib/secrets/dnskeys.conf\n    chmod 400 /var/lib/secrets/dnskeys.conf\n\n    # extract secret value from the dnskeys.conf\n    while read x y; do if [ \"$x\" = \"secret\" ]; then secret=\"''${y:1:''${#y}-3}\"; fi; done < /var/lib/secrets/dnskeys.conf\n\n    cat > /var/lib/secrets/certs.secret << EOF\n    RFC2136_NAMESERVER='127.0.0.1:53'\n    RFC2136_TSIG_ALGORITHM='hmac-sha256.'\n    RFC2136_TSIG_KEY='rfc2136key.example.com'\n    RFC2136_TSIG_SECRET='$secret'\n    EOF\n    chmod 400 /var/lib/secrets/certs.secret\n  '';\n};\n\n\nNow you’re all set to generate certs! You should monitor the first invocation by running systemctl start acme-example.com.service & journalctl -fu acme-example.com.service and watching its log output.\n\nUsing DNS validation with web server virtual hosts \n\nIt is possible to use DNS-01 validation with all certificates, including those automatically configured via the Nginx/Apache enableACME option. This configuration pattern is fully supported and part of the module’s test suite for Nginx + Apache.\n\nYou must follow the guide above on configuring DNS-01 validation first, however instead of setting the options for one certificate (e.g. security.acme.certs.<name>.dnsProvider) you will set them as defaults (e.g. security.acme.defaults.dnsProvider).\n\n# Configure ACME appropriately\nsecurity.acme.acceptTerms = true;\nsecurity.acme.defaults.email = \"admin+acme@example.com\";\nsecurity.acme.defaults = {\n  dnsProvider = \"rfc2136\";\n  environmentFile = \"/var/lib/secrets/certs.secret\";\n  # We don't need to wait for propagation since this is a local DNS server\n  dnsPropagationCheck = false;\n};\n\n# For each virtual host you would like to use DNS-01 validation with,\n# set acmeRoot = null\nservices.nginx = {\n  enable = true;\n  virtualHosts = {\n    \"foo.example.com\" = {\n      enableACME = true;\n      acmeRoot = null;\n    };\n  };\n}\n\n\nAnd that’s it! Next time your configuration is rebuilt, or when you add a new virtualHost, it will be DNS-01 validated.\n\nUsing ACME with services demanding root owned certificates \n\nSome services refuse to start if the configured certificate files are not owned by root. PostgreSQL and OpenSMTPD are examples of these. There is no way to change the user the ACME module uses (it will always be acme), however you can use systemd’s LoadCredential feature to resolve this elegantly. Below is an example configuration for OpenSMTPD, but this pattern can be applied to any service.\n\n# Configure ACME however you like (DNS or HTTP validation), adding\n# the following configuration for the relevant certificate.\n# Note: You cannot use `systemctl reload` here as that would mean\n# the LoadCredential configuration below would be skipped and\n# the service would continue to use old certificates.\nsecurity.acme.certs.\"mail.example.com\".postRun = ''\n  systemctl restart opensmtpd\n'';\n\n# Now you must augment OpenSMTPD's systemd service to load\n# the certificate files.\nsystemd.services.opensmtpd.requires = [\"acme-finished-mail.example.com.target\"];\nsystemd.services.opensmtpd.serviceConfig.LoadCredential = let\n  certDir = config.security.acme.certs.\"mail.example.com\".directory;\nin [\n  \"cert.pem:${certDir}/cert.pem\"\n  \"key.pem:${certDir}/key.pem\"\n];\n\n# Finally, configure OpenSMTPD to use these certs.\nservices.opensmtpd = let\n  credsDir = \"/run/credentials/opensmtpd.service\";\nin {\n  enable = true;\n  setSendmail = false;\n  serverConfiguration = ''\n    pki mail.example.com cert \"${credsDir}/cert.pem\"\n    pki mail.example.com key \"${credsDir}/key.pem\"\n    listen on localhost tls pki mail.example.com\n    action act1 relay host smtp://127.0.0.1:10027\n    match for local action act1\n  '';\n};\n\nRegenerating certificates \n\nShould you need to regenerate a particular certificate in a hurry, such as when a vulnerability is found in Let’s Encrypt, there is now a convenient mechanism for doing so. Running systemctl clean --what=state acme-example.com.service will remove all certificate files and the account data for the given domain, allowing you to then systemctl start acme-example.com.service to generate fresh ones.\n\nFixing JWS Verification error \n\nIt is possible that your account credentials file may become corrupt and need to be regenerated. In this scenario lego will produce the error JWS verification error. The solution is to simply delete the associated accounts file and re-run the affected service(s).\n\n# Find the accounts folder for the certificate\nsystemctl cat acme-example.com.service | grep -Po 'accounts/[^:]*'\nexport accountdir=\"$(!!)\"\n# Move this folder to some place else\nmv /var/lib/acme/.lego/$accountdir{,.bak}\n# Recreate the folder using systemd-tmpfiles\nsystemd-tmpfiles --create\n# Get a new account and reissue certificates\n# Note: Do this for all certs that share the same account email address\nsystemctl start acme-example.com.service\n\nOh my ZSH \n\nTable of Contents\n\nBasic usage\nCustom additions\nCustom environments\nPackage your own customizations\n\noh-my-zsh is a framework to manage your ZSH configuration including completion scripts for several CLI tools or custom prompt themes.\n\nBasic usage \n\nThe module uses the oh-my-zsh package with all available features. The initial setup using Nix expressions is fairly similar to the configuration format of oh-my-zsh.\n\n{\n  programs.zsh.ohMyZsh = {\n    enable = true;\n    plugins = [ \"git\" \"python\" \"man\" ];\n    theme = \"agnoster\";\n  };\n}\n\n\nFor a detailed explanation of these arguments please refer to the oh-my-zsh docs.\n\nThe expression generates the needed configuration and writes it into your /etc/zshrc.\n\nCustom additions \n\nSometimes third-party or custom scripts such as a modified theme may be needed. oh-my-zsh provides the ZSH_CUSTOM environment variable for this which points to a directory with additional scripts.\n\nThe module can do this as well:\n\n{\n  programs.zsh.ohMyZsh.custom = \"~/path/to/custom/scripts\";\n}\n\nCustom environments \n\nThere are several extensions for oh-my-zsh packaged in nixpkgs. One of them is nix-zsh-completions which bundles completion scripts and a plugin for oh-my-zsh.\n\nRather than using a single mutable path for ZSH_CUSTOM, it’s also possible to generate this path from a list of Nix packages:\n\n{ pkgs, ... }:\n{\n  programs.zsh.ohMyZsh.customPkgs = [\n    pkgs.nix-zsh-completions\n    # and even more...\n  ];\n}\n\n\nInternally a single store path will be created using buildEnv. Please refer to the docs of buildEnv for further reference.\n\nPlease keep in mind that this is not compatible with programs.zsh.ohMyZsh.custom as it requires an immutable store path while custom shall remain mutable! An evaluation failure will be thrown if both custom and customPkgs are set.\n\nPackage your own customizations \n\nIf third-party customizations (e.g. new themes) are supposed to be added to oh-my-zsh there are several pitfalls to keep in mind:\n\nTo comply with the default structure of ZSH the entire output needs to be written to $out/share/zsh.\n\nCompletion scripts are supposed to be stored at $out/share/zsh/site-functions. This directory is part of the fpath and the package should be compatible with pure ZSH setups. The module will automatically link the contents of site-functions to completions directory in the proper store path.\n\nThe plugins directory needs the structure pluginname/pluginname.plugin.zsh as structured in the upstream repo.\n\nA derivation for oh-my-zsh may look like this:\n\n{ stdenv, fetchFromGitHub }:\n\nstdenv.mkDerivation rec {\n  name = \"exemplary-zsh-customization-${version}\";\n  version = \"1.0.0\";\n  src = fetchFromGitHub {\n    # path to the upstream repository\n  };\n\n  dontBuild = true;\n  installPhase = ''\n    mkdir -p $out/share/zsh/site-functions\n    cp {themes,plugins} $out/share/zsh\n    cp completions $out/share/zsh/site-functions\n  '';\n}\n\nPlotinus \n\nSource: modules/programs/plotinus.nix\n\nUpstream documentation: https://github.com/p-e-w/plotinus\n\nPlotinus is a searchable command palette in every modern GTK application.\n\nWhen in a GTK 3 application and Plotinus is enabled, you can press Ctrl+Shift+P to open the command palette. The command palette provides a searchable list of of all menu items in the application.\n\nTo enable Plotinus, add the following to your configuration.nix:\n\nprograms.plotinus.enable = true;\n\nDigital Bitbox \n\nTable of Contents\n\nPackage\nHardware\n\nDigital Bitbox is a hardware wallet and second-factor authenticator.\n\nThe digitalbitbox programs module may be installed by setting programs.digitalbitbox to true in a manner similar to\n\nprograms.digitalbitbox.enable = true;\n\n\nand bundles the digitalbitbox package (see the section called “Package”), which contains the dbb-app and dbb-cli binaries, along with the hardware module (see the section called “Hardware”) which sets up the necessary udev rules to access the device.\n\nEnabling the digitalbitbox module is pretty much the easiest way to get a Digital Bitbox device working on your system.\n\nFor more information, see https://digitalbitbox.com/start_linux.\n\nPackage \n\nThe binaries, dbb-app (a GUI tool) and dbb-cli (a CLI tool), are available through the digitalbitbox package which could be installed as follows:\n\nenvironment.systemPackages = [\n  pkgs.digitalbitbox\n];\n\nHardware \n\nThe digitalbitbox hardware package enables the udev rules for Digital Bitbox devices and may be installed as follows:\n\nhardware.digitalbitbox.enable = true;\n\n\nIn order to alter the udev rules, one may provide different values for the udevRule51 and udevRule52 attributes by means of overriding as follows:\n\nprograms.digitalbitbox = {\n  enable = true;\n  package = pkgs.digitalbitbox.override {\n    udevRule51 = \"something else\";\n  };\n};\n\nInput Methods \n\nTable of Contents\n\nIBus\nFcitx5\nNabi\nUim\nHime\nKime\n\nInput methods are an operating system component that allows any data, such as keyboard strokes or mouse movements, to be received as input. In this way users can enter characters and symbols not found on their input devices. Using an input method is obligatory for any language that has more graphemes than there are keys on the keyboard.\n\nThe following input methods are available in NixOS:\n\nIBus: The intelligent input bus.\n\nFcitx5: The next generation of fcitx, addons (including engines, dictionaries, skins) can be added using i18n.inputMethod.fcitx5.addons.\n\nNabi: A Korean input method based on XIM.\n\nUim: The universal input method, is a library with a XIM bridge.\n\nHime: An extremely easy-to-use input method framework.\n\nKime: Korean IME\n\nIBus \n\nIBus is an Intelligent Input Bus. It provides full featured and user friendly input method user interface.\n\nThe following snippet can be used to configure IBus:\n\ni18n.inputMethod = {\n  enabled = \"ibus\";\n  ibus.engines = with pkgs.ibus-engines; [ anthy hangul mozc ];\n};\n\n\ni18n.inputMethod.ibus.engines is optional and can be used to add extra IBus engines.\n\nAvailable extra IBus engines are:\n\nAnthy (ibus-engines.anthy): Anthy is a system for Japanese input method. It converts Hiragana text to Kana Kanji mixed text.\n\nHangul (ibus-engines.hangul): Korean input method.\n\nm17n (ibus-engines.m17n): m17n is an input method that uses input methods and corresponding icons in the m17n database.\n\nmozc (ibus-engines.mozc): A Japanese input method from Google.\n\nTable (ibus-engines.table): An input method that load tables of input methods.\n\ntable-others (ibus-engines.table-others): Various table-based input methods. To use this, and any other table-based input methods, it must appear in the list of engines along with table. For example:\n\nibus.engines = with pkgs.ibus-engines; [ table table-others ];\n\n\nTo use any input method, the package must be added in the configuration, as shown above, and also (after running nixos-rebuild) the input method must be added from IBus’ preference dialog.\n\nTroubleshooting \n\nIf IBus works in some applications but not others, a likely cause of this is that IBus is depending on a different version of glib to what the applications are depending on. This can be checked by running nix-store -q --requisites <path> | grep glib, where <path> is the path of either IBus or an application in the Nix store. The glib packages must match exactly. If they do not, uninstalling and reinstalling the application is a likely fix.\n\nFcitx5 \n\nFcitx5 is an input method framework with extension support. It has three built-in Input Method Engine, Pinyin, QuWei and Table-based input methods.\n\nThe following snippet can be used to configure Fcitx:\n\ni18n.inputMethod = {\n  enabled = \"fcitx5\";\n  fcitx5.addons = with pkgs; [ fcitx5-mozc fcitx5-hangul fcitx5-m17n ];\n};\n\n\ni18n.inputMethod.fcitx5.addons is optional and can be used to add extra Fcitx5 addons.\n\nAvailable extra Fcitx5 addons are:\n\nAnthy (fcitx5-anthy): Anthy is a system for Japanese input method. It converts Hiragana text to Kana Kanji mixed text.\n\nChewing (fcitx5-chewing): Chewing is an intelligent Zhuyin input method. It is one of the most popular input methods among Traditional Chinese Unix users.\n\nHangul (fcitx5-hangul): Korean input method.\n\nUnikey (fcitx5-unikey): Vietnamese input method.\n\nm17n (fcitx5-m17n): m17n is an input method that uses input methods and corresponding icons in the m17n database.\n\nmozc (fcitx5-mozc): A Japanese input method from Google.\n\ntable-others (fcitx5-table-other): Various table-based input methods.\n\nchinese-addons (fcitx5-chinese-addons): Various chinese input methods.\n\nrime (fcitx5-rime): RIME support for fcitx5.\n\nNabi \n\nNabi is an easy to use Korean X input method. It allows you to enter phonetic Korean characters (hangul) and pictographic Korean characters (hanja).\n\nThe following snippet can be used to configure Nabi:\n\ni18n.inputMethod = {\n  enabled = \"nabi\";\n};\n\nUim \n\nUim (short for “universal input method”) is a multilingual input method framework. Applications can use it through so-called bridges.\n\nThe following snippet can be used to configure uim:\n\ni18n.inputMethod = {\n  enabled = \"uim\";\n};\n\n\nNote: The i18n.inputMethod.uim.toolbar option can be used to choose uim toolbar.\n\nHime \n\nHime is an extremely easy-to-use input method framework. It is lightweight, stable, powerful and supports many commonly used input methods, including Cangjie, Zhuyin, Dayi, Rank, Shrimp, Greek, Korean Pinyin, Latin Alphabet, etc…\n\nThe following snippet can be used to configure Hime:\n\ni18n.inputMethod = {\n  enabled = \"hime\";\n};\n\nKime \n\nKime is Korean IME. it’s built with Rust language and let you get simple, safe, fast Korean typing\n\nThe following snippet can be used to configure Kime:\n\ni18n.inputMethod = {\n  enabled = \"kime\";\n};\n\nProfiles \n\nTable of Contents\n\nAll Hardware\nBase\nClone Config\nDemo\nDocker Container\nGraphical\nHardened\nHeadless\nInstallation Device\nMinimal\nQEMU Guest\n\nIn some cases, it may be desirable to take advantage of commonly-used, predefined configurations provided by nixpkgs, but different from those that come as default. This is a role fulfilled by NixOS’s Profiles, which come as files living in <nixpkgs/nixos/modules/profiles>. That is to say, expected usage is to add them to the imports list of your /etc/configuration.nix as such:\n\nimports = [\n  <nixpkgs/nixos/modules/profiles/profile-name.nix>\n];\n\n\nEven if some of these profiles seem only useful in the context of install media, many are actually intended to be used in real installs.\n\nWhat follows is a brief explanation on the purpose and use-case for each profile. Detailing each option configured by each one is out of scope.\n\nAll Hardware \n\nEnables all hardware supported by NixOS: i.e., all firmware is included, and all devices from which one may boot are enabled in the initrd. Its primary use is in the NixOS installation CDs.\n\nThe enabled kernel modules include support for SATA and PATA, SCSI (partially), USB, Firewire (untested), Virtio (QEMU, KVM, etc.), VMware, and Hyper-V. Additionally, hardware.enableAllFirmware is enabled, and the firmware for the ZyDAS ZD1211 chipset is specifically installed.\n\nBase \n\nDefines the software packages included in the “minimal” installation CD. It installs several utilities useful in a simple recovery or install media, such as a text-mode web browser, and tools for manipulating block devices, networking, hardware diagnostics, and filesystems (with their respective kernel modules).\n\nClone Config \n\nThis profile is used in installer images. It provides an editable configuration.nix that imports all the modules that were also used when creating the image in the first place. As a result it allows users to edit and rebuild the live-system.\n\nOn images where the installation media also becomes an installation target, copying over configuration.nix should be disabled by setting installer.cloneConfig to false. For example, this is done in sd-image-aarch64-installer.nix.\n\nDemo \n\nThis profile just enables a demo user, with password demo, uid 1000, wheel group and autologin in the SDDM display manager.\n\nDocker Container \n\nThis is the profile from which the Docker images are generated. It prepares a working system by importing the Minimal and Clone Config profiles, and setting appropriate configuration options that are useful inside a container context, like boot.isContainer.\n\nGraphical \n\nDefines a NixOS configuration with the Plasma 5 desktop. It’s used by the graphical installation CD.\n\nIt sets services.xserver.enable, services.xserver.displayManager.sddm.enable, services.xserver.desktopManager.plasma5.enable, and services.xserver.libinput.enable to true. It also includes glxinfo and firefox in the system packages list.\n\nHardened \n\nA profile with most (vanilla) hardening options enabled by default, potentially at the cost of stability, features and performance.\n\nThis includes a hardened kernel, and limiting the system information available to processes through the /sys and /proc filesystems. It also disables the User Namespaces feature of the kernel, which stops Nix from being able to build anything (this particular setting can be overridden via security.allowUserNamespaces). See the profile source for further detail on which settings are altered.\n\nWarning\n\nThis profile enables options that are known to affect system stability. If you experience any stability issues when using the profile, try disabling it. If you report an issue and use this profile, always mention that you do.\n\nHeadless \n\nCommon configuration for headless machines (e.g., Amazon EC2 instances).\n\nDisables sound, vesa, serial consoles, emergency mode, grub splash images and configures the kernel to reboot automatically on panic.\n\nInstallation Device \n\nProvides a basic configuration for installation devices like CDs. This enables redistributable firmware, includes the Clone Config profile and a copy of the Nixpkgs channel, so nixos-install works out of the box.\n\nDocumentation for Nixpkgs and NixOS are forcefully enabled (to override the Minimal profile preference); the NixOS manual is shown automatically on TTY 8, udisks is disabled. Autologin is enabled as nixos user, while passwordless login as both root and nixos is possible. Passwordless sudo is enabled too. wpa_supplicant is enabled, but configured to not autostart.\n\nIt is explained how to login, start the ssh server, and if available, how to start the display manager.\n\nSeveral settings are tweaked so that the installer has a better chance of succeeding under low-memory environments.\n\nMinimal \n\nThis profile defines a small NixOS configuration. It does not contain any graphical stuff. It’s a very short file that enables noXlibs, sets i18n.supportedLocales to only support the user-selected locale, disables packages’ documentation, and disables sound.\n\nQEMU Guest \n\nThis profile contains common configuration for virtual machines running under QEMU (using virtio).\n\nIt makes virtio modules available on the initrd and sets the system time from the hardware clock to work around a bug in qemu-kvm.\n\nKubernetes \n\nThe NixOS Kubernetes module is a collective term for a handful of individual submodules implementing the Kubernetes cluster components.\n\nThere are generally two ways of enabling Kubernetes on NixOS. One way is to enable and configure cluster components appropriately by hand:\n\nservices.kubernetes = {\n  apiserver.enable = true;\n  controllerManager.enable = true;\n  scheduler.enable = true;\n  addonManager.enable = true;\n  proxy.enable = true;\n  flannel.enable = true;\n};\n\n\nAnother way is to assign cluster roles (“master” and/or “node”) to the host. This enables apiserver, controllerManager, scheduler, addonManager, kube-proxy and etcd:\n\nservices.kubernetes.roles = [ \"master\" ];\n\n\nWhile this will enable the kubelet and kube-proxy only:\n\nservices.kubernetes.roles = [ \"node\" ];\n\n\nAssigning both the master and node roles is usable if you want a single node Kubernetes cluster for dev or testing purposes:\n\nservices.kubernetes.roles = [ \"master\" \"node\" ];\n\n\nNote: Assigning either role will also default both services.kubernetes.flannel.enable and services.kubernetes.easyCerts to true. This sets up flannel as CNI and activates automatic PKI bootstrapping.\n\nNote\n\nAs of NixOS 19.03, it is mandatory to configure: services.kubernetes.masterAddress. The masterAddress must be resolveable and routeable by all cluster nodes. In single node clusters, this can be set to localhost.\n\nRole-based access control (RBAC) authorization mode is enabled by default. This means that anonymous requests to the apiserver secure port will expectedly cause a permission denied error. All cluster components must therefore be configured with x509 certificates for two-way tls communication. The x509 certificate subject section determines the roles and permissions granted by the apiserver to perform clusterwide or namespaced operations. See also: Using RBAC Authorization.\n\nThe NixOS kubernetes module provides an option for automatic certificate bootstrapping and configuration, services.kubernetes.easyCerts. The PKI bootstrapping process involves setting up a certificate authority (CA) daemon (cfssl) on the kubernetes master node. cfssl generates a CA-cert for the cluster, and uses the CA-cert for signing subordinate certs issued to each of the cluster components. Subsequently, the certmgr daemon monitors active certificates and renews them when needed. For single node Kubernetes clusters, setting services.kubernetes.easyCerts = true is sufficient and no further action is required. For joining extra node machines to an existing cluster on the other hand, establishing initial trust is mandatory.\n\nTo add new nodes to the cluster: On any (non-master) cluster node where services.kubernetes.easyCerts is enabled, the helper script nixos-kubernetes-node-join is available on PATH. Given a token on stdin, it will copy the token to the kubernetes secrets directory and restart the certmgr service. As requested certificates are issued, the script will restart kubernetes cluster components as needed for them to pick up new keypairs.\n\nNote\n\nMulti-master (HA) clusters are not supported by the easyCerts module.\n\nIn order to interact with an RBAC-enabled cluster as an administrator, one needs to have cluster-admin privileges. By default, when easyCerts is enabled, a cluster-admin kubeconfig file is generated and linked into /etc/kubernetes/cluster-admin.kubeconfig as determined by services.kubernetes.pki.etcClusterAdminKubeconfig. export KUBECONFIG=/etc/kubernetes/cluster-admin.kubeconfig will make kubectl use this kubeconfig to access and authenticate the cluster. The cluster-admin kubeconfig references an auto-generated keypair owned by root. Thus, only root on the kubernetes master may obtain cluster-admin rights by means of this file.\n\nAdministration \n\nThis chapter describes various aspects of managing a running NixOS system, such as how to use the systemd service manager.\n\nTable of Contents\n\nService Management\nRebooting and Shutting Down\nUser Sessions\nControl Groups\nLogging\nCleaning the Nix Store\nContainer Management\nTroubleshooting\nService Management \n\nTable of Contents\n\nInteracting with a running systemd\nsystemd in NixOS\nTemplate units\n\nIn NixOS, all system services are started and monitored using the systemd program. systemd is the “init” process of the system (i.e. PID 1), the parent of all other processes. It manages a set of so-called “units”, which can be things like system services (programs), but also mount points, swap files, devices, targets (groups of units) and more. Units can have complex dependencies; for instance, one unit can require that another unit must be successfully started before the first unit can be started. When the system boots, it starts a unit named default.target; the dependencies of this unit cause all system services to be started, file systems to be mounted, swap files to be activated, and so on.\n\nInteracting with a running systemd \n\nThe command systemctl is the main way to interact with systemd. The following paragraphs demonstrate ways to interact with any OS running systemd as init system. NixOS is of no exception. The next section explains NixOS specific things worth knowing.\n\nWithout any arguments, systemctl the status of active units:\n\n$ systemctl\n-.mount          loaded active mounted   /\nswapfile.swap    loaded active active    /swapfile\nsshd.service     loaded active running   SSH Daemon\ngraphical.target loaded active active    Graphical Interface\n...\n\n\nYou can ask for detailed status information about a unit, for instance, the PostgreSQL database service:\n\n$ systemctl status postgresql.service\npostgresql.service - PostgreSQL Server\n          Loaded: loaded (/nix/store/pn3q73mvh75gsrl8w7fdlfk3fq5qm5mw-unit/postgresql.service)\n          Active: active (running) since Mon, 2013-01-07 15:55:57 CET; 9h ago\n        Main PID: 2390 (postgres)\n          CGroup: name=systemd:/system/postgresql.service\n                  ├─2390 postgres\n                  ├─2418 postgres: writer process\n                  ├─2419 postgres: wal writer process\n                  ├─2420 postgres: autovacuum launcher process\n                  ├─2421 postgres: stats collector process\n                  └─2498 postgres: zabbix zabbix [local] idle\n\nJan 07 15:55:55 hagbard postgres[2394]: [1-1] LOG:  database system was shut down at 2013-01-07 15:55:05 CET\nJan 07 15:55:57 hagbard postgres[2390]: [1-1] LOG:  database system is ready to accept connections\nJan 07 15:55:57 hagbard postgres[2420]: [1-1] LOG:  autovacuum launcher started\nJan 07 15:55:57 hagbard systemd[1]: Started PostgreSQL Server.\n\n\nNote that this shows the status of the unit (active and running), all the processes belonging to the service, as well as the most recent log messages from the service.\n\nUnits can be stopped, started or restarted:\n\n# systemctl stop postgresql.service\n# systemctl start postgresql.service\n# systemctl restart postgresql.service\n\n\nThese operations are synchronous: they wait until the service has finished starting or stopping (or has failed). Starting a unit will cause the dependencies of that unit to be started as well (if necessary).\n\nsystemd in NixOS \n\nPackages in Nixpkgs sometimes provide systemd units with them, usually in e.g #pkg-out#/lib/systemd/. Putting such a package in environment.systemPackages doesn’t make the service available to users or the system.\n\nIn order to enable a systemd system service with provided upstream package, use (e.g):\n\nsystemd.packages = [ pkgs.packagekit ];\n\n\nUsually NixOS modules written by the community do the above, plus take care of other details. If a module was written for a service you are interested in, you’d probably need only to use services.#name#.enable = true;. These services are defined in Nixpkgs’ nixos/modules/ directory . In case the service is simple enough, the above method should work, and start the service on boot.\n\nUser systemd services on the other hand, should be treated differently. Given a package that has a systemd unit file at #pkg-out#/lib/systemd/user/, using systemd.packages will make you able to start the service via systemctl --user start, but it won’t start automatically on login. However, You can imperatively enable it by adding the package’s attribute to systemd.packages and then do this (e.g):\n\n$ mkdir -p ~/.config/systemd/user/default.target.wants\n$ ln -s /run/current-system/sw/lib/systemd/user/syncthing.service ~/.config/systemd/user/default.target.wants/\n$ systemctl --user daemon-reload\n$ systemctl --user enable syncthing.service\n\n\nIf you are interested in a timer file, use timers.target.wants instead of default.target.wants in the 1st and 2nd command.\n\nUsing systemctl --user enable syncthing.service instead of the above, will work, but it’ll use the absolute path of syncthing.service for the symlink, and this path is in /nix/store/.../lib/systemd/user/. Hence garbage collection will remove that file and you will wind up with a broken symlink in your systemd configuration, which in turn will not make the service / timer start on login.\n\nTemplate units \n\nsystemd supports templated units where a base unit can be started multiple times with a different parameter. The syntax to accomplish this is service-name@instance-name.service. Units get the instance name passed to them (see systemd.unit(5)). NixOS has support for these kinds of units and for template-specific overrides. A service needs to be defined twice, once for the base unit and once for the instance. All instances must include overrideStrategy = \"asDropin\" for the change detection to work. This example illustrates this:\n\n{\n  systemd.services = {\n    \"base-unit@\".serviceConfig = {\n      ExecStart = \"...\";\n      User = \"...\";\n    };\n    \"base-unit@instance-a\" = {\n      overrideStrategy = \"asDropin\"; # needed for templates to work\n      wantedBy = [ \"multi-user.target\" ]; # causes NixOS to manage the instance\n    };\n    \"base-unit@instance-b\" = {\n      overrideStrategy = \"asDropin\"; # needed for templates to work\n      wantedBy = [ \"multi-user.target\" ]; # causes NixOS to manage the instance\n      serviceConfig.User = \"root\"; # also override something for this specific instance\n    };\n  };\n}\n\nRebooting and Shutting Down \n\nThe system can be shut down (and automatically powered off) by doing:\n\n# shutdown\n\n\nThis is equivalent to running systemctl poweroff.\n\nTo reboot the system, run\n\n# reboot\n\n\nwhich is equivalent to systemctl reboot. Alternatively, you can quickly reboot the system using kexec, which bypasses the BIOS by directly loading the new kernel into memory:\n\n# systemctl kexec\n\n\nThe machine can be suspended to RAM (if supported) using systemctl suspend, and suspended to disk using systemctl hibernate.\n\nThese commands can be run by any user who is logged in locally, i.e. on a virtual console or in X11; otherwise, the user is asked for authentication.\n\nUser Sessions \n\nSystemd keeps track of all users who are logged into the system (e.g. on a virtual console or remotely via SSH). The command loginctl allows querying and manipulating user sessions. For instance, to list all user sessions:\n\n$ loginctl\n   SESSION        UID USER             SEAT\n        c1        500 eelco            seat0\n        c3          0 root             seat0\n        c4        500 alice\n\n\nThis shows that two users are logged in locally, while another is logged in remotely. (“Seats” are essentially the combinations of displays and input devices attached to the system; usually, there is only one seat.) To get information about a session:\n\n$ loginctl session-status c3\nc3 - root (0)\n           Since: Tue, 2013-01-08 01:17:56 CET; 4min 42s ago\n          Leader: 2536 (login)\n            Seat: seat0; vc3\n             TTY: /dev/tty3\n         Service: login; type tty; class user\n           State: online\n          CGroup: name=systemd:/user/root/c3\n                  ├─ 2536 /nix/store/10mn4xip9n7y9bxqwnsx7xwx2v2g34xn-shadow-4.1.5.1/bin/login --\n                  ├─10339 -bash\n                  └─10355 w3m nixos.org\n\n\nThis shows that the user is logged in on virtual console 3. It also lists the processes belonging to this session. Since systemd keeps track of this, you can terminate a session in a way that ensures that all the session’s processes are gone:\n\n# loginctl terminate-session c3\n\nControl Groups \n\nTo keep track of the processes in a running system, systemd uses control groups (cgroups). A control group is a set of processes used to allocate resources such as CPU, memory or I/O bandwidth. There can be multiple control group hierarchies, allowing each kind of resource to be managed independently.\n\nThe command systemd-cgls lists all control groups in the systemd hierarchy, which is what systemd uses to keep track of the processes belonging to each service or user session:\n\n$ systemd-cgls\n├─user\n│ └─eelco\n│   └─c1\n│     ├─ 2567 -:0\n│     ├─ 2682 kdeinit4: kdeinit4 Running...\n│     ├─ ...\n│     └─10851 sh -c less -R\n└─system\n  ├─httpd.service\n  │ ├─2444 httpd -f /nix/store/3pyacby5cpr55a03qwbnndizpciwq161-httpd.conf -DNO_DETACH\n  │ └─...\n  ├─dhcpcd.service\n  │ └─2376 dhcpcd --config /nix/store/f8dif8dsi2yaa70n03xir8r653776ka6-dhcpcd.conf\n  └─ ...\n\n\nSimilarly, systemd-cgls cpu shows the cgroups in the CPU hierarchy, which allows per-cgroup CPU scheduling priorities. By default, every systemd service gets its own CPU cgroup, while all user sessions are in the top-level CPU cgroup. This ensures, for instance, that a thousand run-away processes in the httpd.service cgroup cannot starve the CPU for one process in the postgresql.service cgroup. (By contrast, it they were in the same cgroup, then the PostgreSQL process would get 1/1001 of the cgroup’s CPU time.) You can limit a service’s CPU share in configuration.nix:\n\nsystemd.services.httpd.serviceConfig.CPUShares = 512;\n\n\nBy default, every cgroup has 1024 CPU shares, so this will halve the CPU allocation of the httpd.service cgroup.\n\nThere also is a memory hierarchy that controls memory allocation limits; by default, all processes are in the top-level cgroup, so any service or session can exhaust all available memory. Per-cgroup memory limits can be specified in configuration.nix; for instance, to limit httpd.service to 512 MiB of RAM (excluding swap):\n\nsystemd.services.httpd.serviceConfig.MemoryLimit = \"512M\";\n\n\nThe command systemd-cgtop shows a continuously updated list of all cgroups with their CPU and memory usage.\n\nLogging \n\nSystem-wide logging is provided by systemd’s journal, which subsumes traditional logging daemons such as syslogd and klogd. Log entries are kept in binary files in /var/log/journal/. The command journalctl allows you to see the contents of the journal. For example,\n\n$ journalctl -b\n\n\nshows all journal entries since the last reboot. (The output of journalctl is piped into less by default.) You can use various options and match operators to restrict output to messages of interest. For instance, to get all messages from PostgreSQL:\n\n$ journalctl -u postgresql.service\n-- Logs begin at Mon, 2013-01-07 13:28:01 CET, end at Tue, 2013-01-08 01:09:57 CET. --\n...\nJan 07 15:44:14 hagbard postgres[2681]: [2-1] LOG:  database system is shut down\n-- Reboot --\nJan 07 15:45:10 hagbard postgres[2532]: [1-1] LOG:  database system was shut down at 2013-01-07 15:44:14 CET\nJan 07 15:45:13 hagbard postgres[2500]: [1-1] LOG:  database system is ready to accept connections\n\n\nOr to get all messages since the last reboot that have at least a “critical” severity level:\n\n$ journalctl -b -p crit\nDec 17 21:08:06 mandark sudo[3673]: pam_unix(sudo:auth): auth could not identify password for [alice]\nDec 29 01:30:22 mandark kernel[6131]: [1053513.909444] CPU6: Core temperature above threshold, cpu clock throttled (total events = 1)\n\n\nThe system journal is readable by root and by users in the wheel and systemd-journal groups. All users have a private journal that can be read using journalctl.\n\nCleaning the Nix Store \n\nTable of Contents\n\nNixOS Boot Entries\n\nNix has a purely functional model, meaning that packages are never upgraded in place. Instead new versions of packages end up in a different location in the Nix store (/nix/store). You should periodically run Nix’s garbage collector to remove old, unreferenced packages. This is easy:\n\n$ nix-collect-garbage\n\n\nAlternatively, you can use a systemd unit that does the same in the background:\n\n# systemctl start nix-gc.service\n\n\nYou can tell NixOS in configuration.nix to run this unit automatically at certain points in time, for instance, every night at 03:15:\n\nnix.gc.automatic = true;\nnix.gc.dates = \"03:15\";\n\n\nThe commands above do not remove garbage collector roots, such as old system configurations. Thus they do not remove the ability to roll back to previous configurations. The following command deletes old roots, removing the ability to roll back to them:\n\n$ nix-collect-garbage -d\n\n\nYou can also do this for specific profiles, e.g.\n\n$ nix-env -p /nix/var/nix/profiles/per-user/eelco/profile --delete-generations old\n\n\nNote that NixOS system configurations are stored in the profile /nix/var/nix/profiles/system.\n\nAnother way to reclaim disk space (often as much as 40% of the size of the Nix store) is to run Nix’s store optimiser, which seeks out identical files in the store and replaces them with hard links to a single copy.\n\n$ nix-store --optimise\n\n\nSince this command needs to read the entire Nix store, it can take quite a while to finish.\n\nNixOS Boot Entries \n\nIf your /boot partition runs out of space, after clearing old profiles you must rebuild your system with nixos-rebuild boot or nixos-rebuild switch to update the /boot partition and clear space.\n\nContainer Management \n\nTable of Contents\n\nImperative Container Management\nDeclarative Container Specification\nContainer Networking\n\nNixOS allows you to easily run other NixOS instances as containers. Containers are a light-weight approach to virtualisation that runs software in the container at the same speed as in the host system. NixOS containers share the Nix store of the host, making container creation very efficient.\n\nWarning\n\nCurrently, NixOS containers are not perfectly isolated from the host system. This means that a user with root access to the container can do things that affect the host. So you should not give container root access to untrusted users.\n\nNixOS containers can be created in two ways: imperatively, using the command nixos-container, and declaratively, by specifying them in your configuration.nix. The declarative approach implies that containers get upgraded along with your host system when you run nixos-rebuild, which is often not what you want. By contrast, in the imperative approach, containers are configured and updated independently from the host system.\n\nImperative Container Management \n\nWe’ll cover imperative container management using nixos-container first. Be aware that container management is currently only possible as root.\n\nYou create a container with identifier foo as follows:\n\n# nixos-container create foo\n\n\nThis creates the container’s root directory in /var/lib/nixos-containers/foo and a small configuration file in /etc/nixos-containers/foo.conf. It also builds the container’s initial system configuration and stores it in /nix/var/nix/profiles/per-container/foo/system. You can modify the initial configuration of the container on the command line. For instance, to create a container that has sshd running, with the given public key for root:\n\n# nixos-container create foo --config '\n  services.openssh.enable = true;\n  users.users.root.openssh.authorizedKeys.keys = [\"ssh-dss AAAAB3N…\"];\n'\n\n\nBy default the next free address in the 10.233.0.0/16 subnet will be chosen as container IP. This behavior can be altered by setting --host-address and --local-address:\n\n# nixos-container create test --config-file test-container.nix \\\n    --local-address 10.235.1.2 --host-address 10.235.1.1\n\n\nCreating a container does not start it. To start the container, run:\n\n# nixos-container start foo\n\n\nThis command will return as soon as the container has booted and has reached multi-user.target. On the host, the container runs within a systemd unit called container@container-name.service. Thus, if something went wrong, you can get status info using systemctl:\n\n# systemctl status container@foo\n\n\nIf the container has started successfully, you can log in as root using the root-login operation:\n\n# nixos-container root-login foo\n[root@foo:~]#\n\n\nNote that only root on the host can do this (since there is no authentication). You can also get a regular login prompt using the login operation, which is available to all users on the host:\n\n# nixos-container login foo\nfoo login: alice\nPassword: ***\n\n\nWith nixos-container run, you can execute arbitrary commands in the container:\n\n# nixos-container run foo -- uname -a\nLinux foo 3.4.82 #1-NixOS SMP Thu Mar 20 14:44:05 UTC 2014 x86_64 GNU/Linux\n\n\nThere are several ways to change the configuration of the container. First, on the host, you can edit /var/lib/container/name/etc/nixos/configuration.nix, and run\n\n# nixos-container update foo\n\n\nThis will build and activate the new configuration. You can also specify a new configuration on the command line:\n\n# nixos-container update foo --config '\n  services.httpd.enable = true;\n  services.httpd.adminAddr = \"foo@example.org\";\n  networking.firewall.allowedTCPPorts = [ 80 ];\n'\n\n# curl http://$(nixos-container show-ip foo)/\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">…\n\n\nHowever, note that this will overwrite the container’s /etc/nixos/configuration.nix.\n\nAlternatively, you can change the configuration from within the container itself by running nixos-rebuild switch inside the container. Note that the container by default does not have a copy of the NixOS channel, so you should run nix-channel --update first.\n\nContainers can be stopped and started using nixos-container stop and nixos-container start, respectively, or by using systemctl on the container’s service unit. To destroy a container, including its file system, do\n\n# nixos-container destroy foo\n\nDeclarative Container Specification \n\nYou can also specify containers and their configuration in the host’s configuration.nix. For example, the following specifies that there shall be a container named database running PostgreSQL:\n\ncontainers.database =\n  { config =\n      { config, pkgs, ... }:\n      { services.postgresql.enable = true;\n      services.postgresql.package = pkgs.postgresql_14;\n      };\n  };\n\n\nIf you run nixos-rebuild switch, the container will be built. If the container was already running, it will be updated in place, without rebooting. The container can be configured to start automatically by setting containers.database.autoStart = true in its configuration.\n\nBy default, declarative containers share the network namespace of the host, meaning that they can listen on (privileged) ports. However, they cannot change the network configuration. You can give a container its own network as follows:\n\ncontainers.database = {\n  privateNetwork = true;\n  hostAddress = \"192.168.100.10\";\n  localAddress = \"192.168.100.11\";\n};\n\n\nThis gives the container a private virtual Ethernet interface with IP address 192.168.100.11, which is hooked up to a virtual Ethernet interface on the host with IP address 192.168.100.10. (See the next section for details on container networking.)\n\nTo disable the container, just remove it from configuration.nix and run nixos-rebuild switch. Note that this will not delete the root directory of the container in /var/lib/nixos-containers. Containers can be destroyed using the imperative method: nixos-container destroy foo.\n\nDeclarative containers can be started and stopped using the corresponding systemd service, e.g. systemctl start container@database.\n\nContainer Networking \n\nWhen you create a container using nixos-container create, it gets it own private IPv4 address in the range 10.233.0.0/16. You can get the container’s IPv4 address as follows:\n\n# nixos-container show-ip foo\n10.233.4.2\n\n$ ping -c1 10.233.4.2\n64 bytes from 10.233.4.2: icmp_seq=1 ttl=64 time=0.106 ms\n\n\nNetworking is implemented using a pair of virtual Ethernet devices. The network interface in the container is called eth0, while the matching interface in the host is called ve-container-name (e.g., ve-foo). The container has its own network namespace and the CAP_NET_ADMIN capability, so it can perform arbitrary network configuration such as setting up firewall rules, without affecting or having access to the host’s network.\n\nBy default, containers cannot talk to the outside network. If you want that, you should set up Network Address Translation (NAT) rules on the host to rewrite container traffic to use your external IP address. This can be accomplished using the following configuration on the host:\n\nnetworking.nat.enable = true;\nnetworking.nat.internalInterfaces = [\"ve-+\"];\nnetworking.nat.externalInterface = \"eth0\";\n\n\nwhere eth0 should be replaced with the desired external interface. Note that ve-+ is a wildcard that matches all container interfaces.\n\nIf you are using Network Manager, you need to explicitly prevent it from managing container interfaces:\n\nnetworking.networkmanager.unmanaged = [ \"interface-name:ve-*\" ];\n\n\nYou may need to restart your system for the changes to take effect.\n\nTroubleshooting \n\nTable of Contents\n\nBoot Problems\nMaintenance Mode\nRolling Back Configuration Changes\nNix Store Corruption\nNetwork Problems\n\nThis chapter describes solutions to common problems you might encounter when you manage your NixOS system.\n\nBoot Problems \n\nIf NixOS fails to boot, there are a number of kernel command line parameters that may help you to identify or fix the issue. You can add these parameters in the GRUB boot menu by pressing “e” to modify the selected boot entry and editing the line starting with linux. The following are some useful kernel command line parameters that are recognised by the NixOS boot scripts or by systemd:\n\nboot.shell_on_fail\n\nAllows the user to start a root shell if something goes wrong in stage 1 of the boot process (the initial ramdisk). This is disabled by default because there is no authentication for the root shell.\n\nboot.debug1\n\nStart an interactive shell in stage 1 before anything useful has been done. That is, no modules have been loaded and no file systems have been mounted, except for /proc and /sys.\n\nboot.debug1devices\n\nLike boot.debug1, but runs stage1 until kernel modules are loaded and device nodes are created. This may help with e.g. making the keyboard work.\n\nboot.debug1mounts\n\nLike boot.debug1 or boot.debug1devices, but runs stage1 until all filesystems that are mounted during initrd are mounted (see neededForBoot). As a motivating example, this could be useful if you’ve forgotten to set neededForBoot on a file system.\n\nboot.trace\n\nPrint every shell command executed by the stage 1 and 2 boot scripts.\n\nsingle\n\nBoot into rescue mode (a.k.a. single user mode). This will cause systemd to start nothing but the unit rescue.target, which runs sulogin to prompt for the root password and start a root login shell. Exiting the shell causes the system to continue with the normal boot process.\n\nsystemd.log_level=debug systemd.log_target=console\n\nMake systemd very verbose and send log messages to the console instead of the journal. For more parameters recognised by systemd, see systemd(1).\n\nIn addition, these arguments are recognised by the live image only:\n\nlive.nixos.passwd=password\n\nSet the password for the nixos live user. This can be used for SSH access if there are issues using the terminal.\n\nNotice that for boot.shell_on_fail, boot.debug1, boot.debug1devices, and boot.debug1mounts, if you did not select “start the new shell as pid 1”, and you exit from the new shell, boot will proceed normally from the point where it failed, as if you’d chosen “ignore the error and continue”.\n\nIf no login prompts or X11 login screens appear (e.g. due to hanging dependencies), you can press Alt+ArrowUp. If you’re lucky, this will start rescue mode (described above). (Also note that since most units have a 90-second timeout before systemd gives up on them, the agetty login prompts should appear eventually unless something is very wrong.)\n\nMaintenance Mode \n\nYou can enter rescue mode by running:\n\n# systemctl rescue\n\n\nThis will eventually give you a single-user root shell. Systemd will stop (almost) all system services. To get out of maintenance mode, just exit from the rescue shell.\n\nRolling Back Configuration Changes \n\nAfter running nixos-rebuild to switch to a new configuration, you may find that the new configuration doesn’t work very well. In that case, there are several ways to return to a previous configuration.\n\nFirst, the GRUB boot manager allows you to boot into any previous configuration that hasn’t been garbage-collected. These configurations can be found under the GRUB submenu “NixOS - All configurations”. This is especially useful if the new configuration fails to boot. After the system has booted, you can make the selected configuration the default for subsequent boots:\n\n# /run/current-system/bin/switch-to-configuration boot\n\n\nSecond, you can switch to the previous configuration in a running system:\n\n# nixos-rebuild switch --rollback\n\n\nThis is equivalent to running:\n\n# /nix/var/nix/profiles/system-N-link/bin/switch-to-configuration switch\n\n\nwhere N is the number of the NixOS system configuration. To get a list of the available configurations, do:\n\n$ ls -l /nix/var/nix/profiles/system-*-link\n...\nlrwxrwxrwx 1 root root 78 Aug 12 13:54 /nix/var/nix/profiles/system-268-link -> /nix/store/202b...-nixos-13.07pre4932_5a676e4-4be1055\n\nNix Store Corruption \n\nAfter a system crash, it’s possible for files in the Nix store to become corrupted. (For instance, the Ext4 file system has the tendency to replace un-synced files with zero bytes.) NixOS tries hard to prevent this from happening: it performs a sync before switching to a new configuration, and Nix’s database is fully transactional. If corruption still occurs, you may be able to fix it automatically.\n\nIf the corruption is in a path in the closure of the NixOS system configuration, you can fix it by doing\n\n# nixos-rebuild switch --repair\n\n\nThis will cause Nix to check every path in the closure, and if its cryptographic hash differs from the hash recorded in Nix’s database, the path is rebuilt or redownloaded.\n\nYou can also scan the entire Nix store for corrupt paths:\n\n# nix-store --verify --check-contents --repair\n\n\nAny corrupt paths will be redownloaded if they’re available in a binary cache; otherwise, they cannot be repaired.\n\nNetwork Problems \n\nNix uses a so-called binary cache to optimise building a package from source into downloading it as a pre-built binary. That is, whenever a command like nixos-rebuild needs a path in the Nix store, Nix will try to download that path from the Internet rather than build it from source. The default binary cache is https://cache.nixos.org/. If this cache is unreachable, Nix operations may take a long time due to HTTP connection timeouts. You can disable the use of the binary cache by adding --option use-binary-caches false, e.g.\n\n# nixos-rebuild switch --option use-binary-caches false\n\n\nIf you have an alternative binary cache at your disposal, you can use it instead:\n\n# nixos-rebuild switch --option binary-caches http://my-cache.example.org/\n\nDevelopment \n\nThis chapter describes how you can modify and extend NixOS.\n\nTable of Contents\n\nGetting the Sources\nWriting NixOS Modules\nBuilding Specific Parts of NixOS\nExperimental feature: Bootspec\nWhat happens during a system switch?\nWriting NixOS Documentation\nNixOS Tests\nDeveloping the NixOS Test Driver\nTesting the Installer\nGetting the Sources \n\nBy default, NixOS’s nixos-rebuild command uses the NixOS and Nixpkgs sources provided by the nixos channel (kept in /nix/var/nix/profiles/per-user/root/channels/nixos). To modify NixOS, however, you should check out the latest sources from Git. This is as follows:\n\n$ git clone https://github.com/NixOS/nixpkgs\n$ cd nixpkgs\n$ git remote update origin\n\n\nThis will check out the latest Nixpkgs sources to ./nixpkgs the NixOS sources to ./nixpkgs/nixos. (The NixOS source tree lives in a subdirectory of the Nixpkgs repository.) The nixpkgs repository has branches that correspond to each Nixpkgs/NixOS channel (see Upgrading NixOS for more information about channels). Thus, the Git branch origin/nixos-17.03 will contain the latest built and tested version available in the nixos-17.03 channel.\n\nIt’s often inconvenient to develop directly on the master branch, since if somebody has just committed (say) a change to GCC, then the binary cache may not have caught up yet and you’ll have to rebuild everything from source. So you may want to create a local branch based on your current NixOS version:\n\n$ nixos-version\n17.09pre104379.6e0b727 (Hummingbird)\n\n$ git checkout -b local 6e0b727\n\n\nOr, to base your local branch on the latest version available in a NixOS channel:\n\n$ git remote update origin\n$ git checkout -b local origin/nixos-17.03\n\n\n(Replace nixos-17.03 with the name of the channel you want to use.) You can use git merge or git rebase to keep your local branch in sync with the channel, e.g.\n\n$ git remote update origin\n$ git merge origin/nixos-17.03\n\n\nYou can use git cherry-pick to copy commits from your local branch to the upstream branch.\n\nIf you want to rebuild your system using your (modified) sources, you need to tell nixos-rebuild about them using the -I flag:\n\n# nixos-rebuild switch -I nixpkgs=/my/sources/nixpkgs\n\n\nIf you want nix-env to use the expressions in /my/sources, use nix-env -f /my/sources/nixpkgs, or change the default by adding a symlink in ~/.nix-defexpr:\n\n$ ln -s /my/sources/nixpkgs ~/.nix-defexpr/nixpkgs\n\n\nYou may want to delete the symlink ~/.nix-defexpr/channels_root to prevent root’s NixOS channel from clashing with your own tree (this may break the command-not-found utility though). If you want to go back to the default state, you may just remove the ~/.nix-defexpr directory completely, log out and log in again and it should have been recreated with a link to the root channels.\n\nWriting NixOS Modules \n\nTable of Contents\n\nOption Declarations\nOptions Types\nOption Definitions\nWarnings and Assertions\nMeta Attributes\nImporting Modules\nReplace Modules\nFreeform modules\nOptions for Program Settings\n\nNixOS has a modular system for declarative configuration. This system combines multiple modules to produce the full system configuration. One of the modules that constitute the configuration is /etc/nixos/configuration.nix. Most of the others live in the nixos/modules subdirectory of the Nixpkgs tree.\n\nEach NixOS module is a file that handles one logical aspect of the configuration, such as a specific kind of hardware, a service, or network settings. A module configuration does not have to handle everything from scratch; it can use the functionality provided by other modules for its implementation. Thus a module can declare options that can be used by other modules, and conversely can define options provided by other modules in its own implementation. For example, the module pam.nix declares the option security.pam.services that allows other modules (e.g. sshd.nix) to define PAM services; and it defines the option environment.etc (declared by etc.nix) to cause files to be created in /etc/pam.d.\n\nIn Configuration Syntax, we saw the following structure of NixOS modules:\n\n{ config, pkgs, ... }:\n\n{ option definitions\n}\n\n\nThis is actually an abbreviated form of module that only defines options, but does not declare any. The structure of full NixOS modules is shown in Example: Structure of NixOS Modules.\n\nExample 11. Structure of NixOS Modules\n\n{ config, pkgs, ... }:\n\n{\n  imports =\n    [ paths of other modules\n    ];\n\n  options = {\n    option declarations\n  };\n\n  config = {\n    option definitions\n  };\n}\n\n\n\n\nThe meaning of each part is as follows.\n\nThe first line makes the current Nix expression a function. The variable pkgs contains Nixpkgs (by default, it takes the nixpkgs entry of NIX_PATH, see the Nix manual for further details), while config contains the full system configuration. This line can be omitted if there is no reference to pkgs and config inside the module.\n\nThis imports list enumerates the paths to other NixOS modules that should be included in the evaluation of the system configuration. A default set of modules is defined in the file modules/module-list.nix. These don’t need to be added in the import list.\n\nThe attribute options is a nested set of option declarations (described below).\n\nThe attribute config is a nested set of option definitions (also described below).\n\nExample: NixOS Module for the “locate” Service shows a module that handles the regular update of the “locate” database, an index of all files in the file system. This module declares two options that can be defined by other modules (typically the user’s configuration.nix): services.locate.enable (whether the database should be updated) and services.locate.interval (when the update should be done). It implements its functionality by defining two options declared by other modules: systemd.services (the set of all systemd services) and systemd.timers (the list of commands to be executed periodically by systemd).\n\nCare must be taken when writing systemd services using Exec* directives. By default systemd performs substitution on %<char> specifiers in these directives, expands environment variables from $FOO and ${FOO}, splits arguments on whitespace, and splits commands on ;. All of these must be escaped to avoid unexpected substitution or splitting when interpolating into an Exec* directive, e.g. when using an extraArgs option to pass additional arguments to the service. The functions utils.escapeSystemdExecArg and utils.escapeSystemdExecArgs are provided for this, see Example: Escaping in Exec directives for an example. When using these functions system environment substitution should not be disabled explicitly.\n\nExample 12. NixOS Module for the “locate” Service\n\n{ config, lib, pkgs, ... }:\n\nwith lib;\n\nlet\n  cfg = config.services.locate;\nin {\n  options.services.locate = {\n    enable = mkOption {\n      type = types.bool;\n      default = false;\n      description = ''\n        If enabled, NixOS will periodically update the database of\n        files used by the locate command.\n      '';\n    };\n\n    interval = mkOption {\n      type = types.str;\n      default = \"02:15\";\n      example = \"hourly\";\n      description = ''\n        Update the locate database at this interval. Updates by\n        default at 2:15 AM every day.\n\n        The format is described in\n        systemd.time(7).\n      '';\n    };\n\n    # Other options omitted for documentation\n  };\n\n  config = {\n    systemd.services.update-locatedb =\n      { description = \"Update Locate Database\";\n        path  = [ pkgs.su ];\n        script =\n          ''\n            mkdir -m 0755 -p $(dirname ${toString cfg.output})\n            exec updatedb \\\n              --localuser=${cfg.localuser} \\\n              ${optionalString (!cfg.includeStore) \"--prunepaths='/nix/store'\"} \\\n              --output=${toString cfg.output} ${concatStringsSep \" \" cfg.extraFlags}\n          '';\n      };\n\n    systemd.timers.update-locatedb = mkIf cfg.enable\n      { description = \"Update timer for locate database\";\n        partOf      = [ \"update-locatedb.service\" ];\n        wantedBy    = [ \"timers.target\" ];\n        timerConfig.OnCalendar = cfg.interval;\n      };\n  };\n}\n\n\n\n\nExample 13. Escaping in Exec directives\n\n{ config, lib, pkgs, utils, ... }:\n\nwith lib;\n\nlet\n  cfg = config.services.echo;\n  echoAll = pkgs.writeScript \"echo-all\" ''\n    #! ${pkgs.runtimeShell}\n    for s in \"$@\"; do\n      printf '%s\\n' \"$s\"\n    done\n  '';\n  args = [ \"a%Nything\" \"lang=\\${LANG}\" \";\" \"/bin/sh -c date\" ];\nin {\n  systemd.services.echo =\n    { description = \"Echo to the journal\";\n      wantedBy = [ \"multi-user.target\" ];\n      serviceConfig.Type = \"oneshot\";\n      serviceConfig.ExecStart = ''\n        ${echoAll} ${utils.escapeSystemdExecArgs args}\n      '';\n    };\n}\n\n\n\nOption Declarations \n\nAn option declaration specifies the name, type and description of a NixOS configuration option. It is invalid to define an option that hasn’t been declared in any module. An option declaration generally looks like this:\n\noptions = {\n  name = mkOption {\n    type = type specification;\n    default = default value;\n    example = example value;\n    description = lib.mdDoc \"Description for use in the NixOS manual.\";\n  };\n};\n\n\nThe attribute names within the name attribute path must be camel cased in general but should, as an exception, match the package attribute name when referencing a Nixpkgs package. For example, the option services.nix-serve.bindAddress references the nix-serve Nixpkgs package.\n\nThe function mkOption accepts the following arguments.\n\ntype\n\nThe type of the option (see the section called “Options Types”). This argument is mandatory for nixpkgs modules. Setting this is highly recommended for the sake of documentation and type checking. In case it is not set, a fallback type with unspecified behavior is used.\n\ndefault\n\nThe default value used if no value is defined by any module. A default is not required; but if a default is not given, then users of the module will have to define the value of the option, otherwise an error will be thrown.\n\ndefaultText\n\nA textual representation of the default value to be rendered verbatim in the manual. Useful if the default value is a complex expression or depends on other values or packages. Use lib.literalExpression for a Nix expression, lib.literalMD for a plain English description in Nixpkgs-flavored Markdown format.\n\nexample\n\nAn example value that will be shown in the NixOS manual. You can use lib.literalExpression and lib.literalMD in the same way as in defaultText.\n\ndescription\n\nA textual description of the option, in Nixpkgs-flavored Markdown format, that will be included in the NixOS manual. During the migration process from DocBook it is necessary to mark descriptions written in CommonMark with lib.mdDoc. The description may still be written in DocBook (without any marker), but this is discouraged and will be deprecated in the future.\n\nUtility functions for common option patterns \nmkEnableOption\n\nCreates an Option attribute set for a boolean value option i.e an option to be toggled on or off.\n\nThis function takes a single string argument, the name of the thing to be toggled.\n\nThe option’s description is “Whether to enable <name>.”.\n\nFor example:\n\nExample 14. mkEnableOption usage\n\nlib.mkEnableOption (lib.mdDoc \"magic\")\n# is like\nlib.mkOption {\n  type = lib.types.bool;\n  default = false;\n  example = true;\n  description = lib.mdDoc \"Whether to enable magic.\";\n}\n\n\n\nmkPackageOption\n\nUsage:\n\nmkPackageOption pkgs \"name\" { default = [ \"path\" \"in\" \"pkgs\" ]; example = \"literal example\"; }\n\n\nCreates an Option attribute set for an option that specifies the package a module should use for some purpose.\n\nNote: You shouldn’t necessarily make package options for all of your modules. You can always overwrite a specific package throughout nixpkgs by using nixpkgs overlays.\n\nThe package is specified in the third argument under default as a list of strings representing its attribute path in nixpkgs (or another package set). Because of this, you need to pass nixpkgs itself (or a subset) as the first argument.\n\nThe second argument may be either a string or a list of strings. It provides the display name of the package in the description of the generated option (using only the last element if the passed value is a list) and serves as the fallback value for the default argument.\n\nTo include extra information in the description, pass extraDescription to append arbitrary text to the generated description. You can also pass an example value, either a literal string or an attribute path.\n\nThe default argument can be omitted if the provided name is an attribute of pkgs (if name is a string) or a valid attribute path in pkgs (if name is a list).\n\nIf you wish to explicitly provide no default, pass null as default.\n\nExamples:\n\nExample 15. Simple mkPackageOption usage\n\nlib.mkPackageOption pkgs \"hello\" { }\n# is like\nlib.mkOption {\n  type = lib.types.package;\n  default = pkgs.hello;\n  defaultText = lib.literalExpression \"pkgs.hello\";\n  description = lib.mdDoc \"The hello package to use.\";\n}\n\n\n\n\nExample 16. mkPackageOption with explicit default and example\n\nlib.mkPackageOption pkgs \"GHC\" {\n  default = [ \"ghc\" ];\n  example = \"pkgs.haskell.packages.ghc92.ghc.withPackages (hkgs: [ hkgs.primes ])\";\n}\n# is like\nlib.mkOption {\n  type = lib.types.package;\n  default = pkgs.ghc;\n  defaultText = lib.literalExpression \"pkgs.ghc\";\n  example = lib.literalExpression \"pkgs.haskell.packages.ghc92.ghc.withPackages (hkgs: [ hkgs.primes ])\";\n  description = lib.mdDoc \"The GHC package to use.\";\n}\n\n\n\n\nExample 17. mkPackageOption with additional description text\n\nmkPackageOption pkgs [ \"python39Packages\" \"pytorch\" ] {\n  extraDescription = \"This is an example and doesn't actually do anything.\";\n}\n# is like\nlib.mkOption {\n  type = lib.types.package;\n  default = pkgs.python39Packages.pytorch;\n  defaultText = lib.literalExpression \"pkgs.python39Packages.pytorch\";\n  description = \"The pytorch package to use. This is an example and doesn't actually do anything.\";\n}\n\n\n\nExtensible Option Types \n\nExtensible option types is a feature that allow to extend certain types declaration through multiple module files. This feature only work with a restricted set of types, namely enum and submodules and any composed forms of them.\n\nExtensible option types can be used for enum options that affects multiple modules, or as an alternative to related enable options.\n\nAs an example, we will take the case of display managers. There is a central display manager module for generic display manager options and a module file per display manager backend (sddm, gdm …).\n\nThere are two approaches we could take with this module structure:\n\nConfiguring the display managers independently by adding an enable option to every display manager module backend. (NixOS)\n\nConfiguring the display managers in the central module by adding an option to select which display manager backend to use.\n\nBoth approaches have problems.\n\nMaking backends independent can quickly become hard to manage. For display managers, there can only be one enabled at a time, but the type system cannot enforce this restriction as there is no relation between each backend’s enable option. As a result, this restriction has to be done explicitly by adding assertions in each display manager backend module.\n\nOn the other hand, managing the display manager backends in the central module will require changing the central module option every time a new backend is added or removed.\n\nBy using extensible option types, it is possible to create a placeholder option in the central module (Example: Extensible type placeholder in the service module), and to extend it in each backend module (Example: Extending services.xserver.displayManager.enable in the gdm module, Example: Extending services.xserver.displayManager.enable in the sddm module).\n\nAs a result, displayManager.enable option values can be added without changing the main service module file and the type system automatically enforces that there can only be a single display manager enabled.\n\nExample 18. Extensible type placeholder in the service module\n\nservices.xserver.displayManager.enable = mkOption {\n  description = \"Display manager to use\";\n  type = with types; nullOr (enum [ ]);\n};\n\n\n\n\nExample 19. Extending services.xserver.displayManager.enable in the gdm module\n\nservices.xserver.displayManager.enable = mkOption {\n  type = with types; nullOr (enum [ \"gdm\" ]);\n};\n\n\n\n\nExample 20. Extending services.xserver.displayManager.enable in the sddm module\n\nservices.xserver.displayManager.enable = mkOption {\n  type = with types; nullOr (enum [ \"sddm\" ]);\n};\n\n\n\n\nThe placeholder declaration is a standard mkOption declaration, but it is important that extensible option declarations only use the type argument.\n\nExtensible option types work with any of the composed variants of enum such as with types; nullOr (enum [ \"foo\" \"bar\" ]) or with types; listOf (enum [ \"foo\" \"bar\" ]).\n\nOptions Types \n\nOption types are a way to put constraints on the values a module option can take. Types are also responsible of how values are merged in case of multiple value definitions.\n\nBasic types \n\nBasic types are the simplest available types in the module system. Basic types include multiple string types that mainly differ in how definition merging is handled.\n\ntypes.bool\n\nA boolean, its values can be true or false.\n\ntypes.path\n\nA filesystem path is anything that starts with a slash when coerced to a string. Even if derivations can be considered as paths, the more specific types.package should be preferred.\n\ntypes.pathInStore\n\nA path that is contained in the Nix store. This can be a top-level store path like pkgs.hello or a descendant like \"${pkgs.hello}/bin/hello\".\n\ntypes.package\n\nA top-level store path. This can be an attribute set pointing to a store path, like a derivation or a flake input.\n\ntypes.enum l\n\nOne element of the list l, e.g. types.enum [ \"left\" \"right\" ]. Multiple definitions cannot be merged.\n\ntypes.anything\n\nA type that accepts any value and recursively merges attribute sets together. This type is recommended when the option type is unknown.\n\nExample 21. types.anything\n\nTwo definitions of this type like\n\n{\n  str = lib.mkDefault \"foo\";\n  pkg.hello = pkgs.hello;\n  fun.fun = x: x + 1;\n}\n\n{\n  str = lib.mkIf true \"bar\";\n  pkg.gcc = pkgs.gcc;\n  fun.fun = lib.mkForce (x: x + 2);\n}\n\n\nwill get merged to\n\n{\n  str = \"bar\";\n  pkg.gcc = pkgs.gcc;\n  pkg.hello = pkgs.hello;\n  fun.fun = x: x + 2;\n}\n\n\n\ntypes.raw\n\nA type which doesn’t do any checking, merging or nested evaluation. It accepts a single arbitrary value that is not recursed into, making it useful for values coming from outside the module system, such as package sets or arbitrary data. Options of this type are still evaluated according to priorities and conditionals, so mkForce, mkIf and co. still work on the option value itself, but not for any value nested within it. This type should only be used when checking, merging and nested evaluation are not desirable.\n\ntypes.optionType\n\nThe type of an option’s type. Its merging operation ensures that nested options have the correct file location annotated, and that if possible, multiple option definitions are correctly merged together. The main use case is as the type of the _module.freeformType option.\n\ntypes.attrs\n\nA free-form attribute set.\n\nWarning\n\nThis type will be deprecated in the future because it doesn’t recurse into attribute sets, silently drops earlier attribute definitions, and doesn’t discharge lib.mkDefault, lib.mkIf and co. For allowing arbitrary attribute sets, prefer types.attrsOf types.anything instead which doesn’t have these problems.\n\ntypes.pkgs\n\nA type for the top level Nixpkgs package set.\n\nNumeric types\ntypes.int\n\nA signed integer.\n\ntypes.ints.{s8, s16, s32}\n\nSigned integers with a fixed length (8, 16 or 32 bits). They go from −2^n/2 to 2^n/2−1 respectively (e.g. −128 to 127 for 8 bits).\n\ntypes.ints.unsigned\n\nAn unsigned integer (that is >= 0).\n\ntypes.ints.{u8, u16, u32}\n\nUnsigned integers with a fixed length (8, 16 or 32 bits). They go from 0 to 2^n−1 respectively (e.g. 0 to 255 for 8 bits).\n\ntypes.ints.between lowest highest\n\nAn integer between lowest and highest (both inclusive).\n\ntypes.ints.positive\n\nA positive integer (that is > 0).\n\ntypes.port\n\nA port number. This type is an alias to types.ints.u16.\n\ntypes.float\n\nA floating point number.\n\nWarning\n\nConverting a floating point number to a string with toString or toJSON may result in precision loss.\n\ntypes.number\n\nEither a signed integer or a floating point number. No implicit conversion is done between the two types, and multiple equal definitions will only be merged if they have the same type.\n\ntypes.numbers.between lowest highest\n\nAn integer or floating point number between lowest and highest (both inclusive).\n\ntypes.numbers.nonnegative\n\nA nonnegative integer or floating point number (that is >= 0).\n\ntypes.numbers.positive\n\nA positive integer or floating point number (that is > 0).\n\nString types\ntypes.str\n\nA string. Multiple definitions cannot be merged.\n\ntypes.separatedString sep\n\nA string. Multiple definitions are concatenated with sep, e.g. types.separatedString \"|\".\n\ntypes.lines\n\nA string. Multiple definitions are concatenated with a new line \"\\n\".\n\ntypes.commas\n\nA string. Multiple definitions are concatenated with a comma \",\".\n\ntypes.envVar\n\nA string. Multiple definitions are concatenated with a colon \":\".\n\ntypes.strMatching\n\nA string matching a specific regular expression. Multiple definitions cannot be merged. The regular expression is processed using builtins.match.\n\nSubmodule types \n\nSubmodules are detailed in Submodule.\n\ntypes.submodule o\n\nA set of sub options o. o can be an attribute set, a function returning an attribute set, or a path to a file containing such a value. Submodules are used in composed types to create modular options. This is equivalent to types.submoduleWith { modules = toList o; shorthandOnlyDefinesConfig = true; }.\n\ntypes.submoduleWith { modules, specialArgs ? {}, shorthandOnlyDefinesConfig ? false }\n\nLike types.submodule, but more flexible and with better defaults. It has parameters\n\nmodules A list of modules to use by default for this submodule type. This gets combined with all option definitions to build the final list of modules that will be included.\n\nNote\n\nOnly options defined with this argument are included in rendered documentation.\n\nspecialArgs An attribute set of extra arguments to be passed to the module functions. The option _module.args should be used instead for most arguments since it allows overriding. specialArgs should only be used for arguments that can’t go through the module fixed-point, because of infinite recursion or other problems. An example is overriding the lib argument, because lib itself is used to define _module.args, which makes using _module.args to define it impossible.\n\nshorthandOnlyDefinesConfig Whether definitions of this type should default to the config section of a module (see Example: Structure of NixOS Modules) if it is an attribute set. Enabling this only has a benefit when the submodule defines an option named config or options. In such a case it would allow the option to be set with the-submodule.config = \"value\" instead of requiring the-submodule.config.config = \"value\". This is because only when modules don’t set the config or options keys, all keys are interpreted as option definitions in the config section. Enabling this option implicitly puts all attributes in the config section.\n\nWith this option enabled, defining a non-config section requires using a function: the-submodule = { ... }: { options = { ... }; }.\n\ntypes.deferredModule\n\nWhereas submodule represents an option tree, deferredModule represents a module value, such as a module file or a configuration.\n\nIt can be set multiple times.\n\nModule authors can use its value in imports, in submoduleWith’s modules or in evalModules’ modules parameter, among other places.\n\nNote that imports must be evaluated before the module fixpoint. Because of this, deferred modules can only be imported into “other” fixpoints, such as submodules.\n\nOne use case for this type is the type of a “default” module that allow the user to affect all submodules in an attrsOf submodule at once. This is more convenient and discoverable than expecting the module user to type-merge with the attrsOf submodule option.\n\nComposed types \n\nComposed types are types that take a type as parameter. listOf int and either int str are examples of composed types.\n\ntypes.listOf t\n\nA list of t type, e.g. types.listOf int. Multiple definitions are merged with list concatenation.\n\ntypes.attrsOf t\n\nAn attribute set of where all the values are of t type. Multiple definitions result in the joined attribute set.\n\nNote\n\nThis type is strict in its values, which in turn means attributes cannot depend on other attributes. See types.lazyAttrsOf for a lazy version.\n\ntypes.lazyAttrsOf t\n\nAn attribute set of where all the values are of t type. Multiple definitions result in the joined attribute set. This is the lazy version of types.attrsOf, allowing attributes to depend on each other.\n\nWarning\n\nThis version does not fully support conditional definitions! With an option foo of this type and a definition foo.attr = lib.mkIf false 10, evaluating foo ? attr will return true even though it should be false. Accessing the value will then throw an error. For types t that have an emptyValue defined, that value will be returned instead of throwing an error. So if the type of foo.attr was lazyAttrsOf (nullOr int), null would be returned instead for the same mkIf false definition.\n\ntypes.nullOr t\n\nnull or type t. Multiple definitions are merged according to type t.\n\ntypes.uniq t\n\nEnsures that type t cannot be merged. It is used to ensure option definitions are declared only once.\n\ntypes.unique { message = m } t\n\nEnsures that type t cannot be merged. Prints the message m, after the line The option <option path> is defined multiple times. and before a list of definition locations.\n\ntypes.either t1 t2\n\nType t1 or type t2, e.g. with types; either int str. Multiple definitions cannot be merged.\n\ntypes.oneOf [ t1 t2 … ]\n\nType t1 or type t2 and so forth, e.g. with types; oneOf [ int str bool ]. Multiple definitions cannot be merged.\n\ntypes.coercedTo from f to\n\nType to or type from which will be coerced to type to using function f which takes an argument of type from and return a value of type to. Can be used to preserve backwards compatibility of an option if its type was changed.\n\nSubmodule \n\nsubmodule is a very powerful type that defines a set of sub-options that are handled like a separate module.\n\nIt takes a parameter o, that should be a set, or a function returning a set with an options key defining the sub-options. Submodule option definitions are type-checked accordingly to the options declarations. Of course, you can nest submodule option definitions for even higher modularity.\n\nThe option set can be defined directly (Example: Directly defined submodule) or as reference (Example: Submodule defined as a reference).\n\nNote that even if your submodule’s options all have a default value, you will still need to provide a default value (e.g. an empty attribute set) if you want to allow users to leave it undefined.\n\nExample 22. Directly defined submodule\n\noptions.mod = mkOption {\n  description = \"submodule example\";\n  type = with types; submodule {\n    options = {\n      foo = mkOption {\n        type = int;\n      };\n      bar = mkOption {\n        type = str;\n      };\n    };\n  };\n};\n\n\n\n\nExample 23. Submodule defined as a reference\n\nlet\n  modOptions = {\n    options = {\n      foo = mkOption {\n        type = int;\n      };\n      bar = mkOption {\n        type = int;\n      };\n    };\n  };\nin\noptions.mod = mkOption {\n  description = \"submodule example\";\n  type = with types; submodule modOptions;\n};\n\n\n\n\nThe submodule type is especially interesting when used with composed types like attrsOf or listOf. When composed with listOf (Example: Declaration of a list of submodules), submodule allows multiple definitions of the submodule option set (Example: Definition of a list of submodules).\n\nExample 24. Declaration of a list of submodules\n\noptions.mod = mkOption {\n  description = \"submodule example\";\n  type = with types; listOf (submodule {\n    options = {\n      foo = mkOption {\n        type = int;\n      };\n      bar = mkOption {\n        type = str;\n      };\n    };\n  });\n};\n\n\n\n\nExample 25. Definition of a list of submodules\n\nconfig.mod = [\n  { foo = 1; bar = \"one\"; }\n  { foo = 2; bar = \"two\"; }\n];\n\n\n\n\nWhen composed with attrsOf (Example: Declaration of attribute sets of submodules), submodule allows multiple named definitions of the submodule option set (Example: Definition of attribute sets of submodules).\n\nExample 26. Declaration of attribute sets of submodules\n\noptions.mod = mkOption {\n  description = \"submodule example\";\n  type = with types; attrsOf (submodule {\n    options = {\n      foo = mkOption {\n        type = int;\n      };\n      bar = mkOption {\n        type = str;\n      };\n    };\n  });\n};\n\n\n\n\nExample 27. Definition of attribute sets of submodules\n\nconfig.mod.one = { foo = 1; bar = \"one\"; };\nconfig.mod.two = { foo = 2; bar = \"two\"; };\n\n\n\nExtending types \n\nTypes are mainly characterized by their check and merge functions.\n\ncheck\n\nThe function to type check the value. Takes a value as parameter and return a boolean. It is possible to extend a type check with the addCheck function (Example: Adding a type check), or to fully override the check function (Example: Overriding a type check).\n\nExample 28. Adding a type check\n\nbyte = mkOption {\n  description = \"An integer between 0 and 255.\";\n  type = types.addCheck types.int (x: x >= 0 && x <= 255);\n};\n\n\n\n\nExample 29. Overriding a type check\n\nnixThings = mkOption {\n  description = \"words that start with 'nix'\";\n  type = types.str // {\n    check = (x: lib.hasPrefix \"nix\" x)\n  };\n};\n\n\n\nmerge\n\nFunction to merge the options values when multiple values are set. The function takes two parameters, loc the option path as a list of strings, and defs the list of defined values as a list. It is possible to override a type merge function for custom needs.\n\nCustom types \n\nCustom types can be created with the mkOptionType function. As type creation includes some more complex topics such as submodule handling, it is recommended to get familiar with types.nix code before creating a new type.\n\nThe only required parameter is name.\n\nname\n\nA string representation of the type function name.\n\ndescription\n\nDescription of the type used in documentation. Give information of the type and any of its arguments.\n\ncheck\n\nA function to type check the definition value. Takes the definition value as a parameter and returns a boolean indicating the type check result, true for success and false for failure.\n\nmerge\n\nA function to merge multiple definitions values. Takes two parameters:\n\nloc\n\nThe option path as a list of strings, e.g. [\"boot\" \"loader \"grub\" \"enable\"].\n\ndefs\n\nThe list of sets of defined value and file where the value was defined, e.g. [ { file = \"/foo.nix\"; value = 1; } { file = \"/bar.nix\"; value = 2 } ]. The merge function should return the merged value or throw an error in case the values are impossible or not meant to be merged.\n\ngetSubOptions\n\nFor composed types that can take a submodule as type parameter, this function generate sub-options documentation. It takes the current option prefix as a list and return the set of sub-options. Usually defined in a recursive manner by adding a term to the prefix, e.g. prefix: elemType.getSubOptions (prefix ++ [\"prefix\"]) where \"prefix\" is the newly added prefix.\n\ngetSubModules\n\nFor composed types that can take a submodule as type parameter, this function should return the type parameters submodules. If the type parameter is called elemType, the function should just recursively look into submodules by returning elemType.getSubModules;.\n\nsubstSubModules\n\nFor composed types that can take a submodule as type parameter, this function can be used to substitute the parameter of a submodule type. It takes a module as parameter and return the type with the submodule options substituted. It is usually defined as a type function call with a recursive call to substSubModules, e.g for a type composedType that take an elemtype type parameter, this function should be defined as m: composedType (elemType.substSubModules m).\n\ntypeMerge\n\nA function to merge multiple type declarations. Takes the type to merge functor as parameter. A null return value means that type cannot be merged.\n\nf\n\nThe type to merge functor.\n\nNote: There is a generic defaultTypeMerge that work with most of value and composed types.\n\nfunctor\n\nAn attribute set representing the type. It is used for type operations and has the following keys:\n\ntype\n\nThe type function.\n\nwrapped\n\nHolds the type parameter for composed types.\n\npayload\n\nHolds the value parameter for value types. The types that have a payload are the enum, separatedString and submodule types.\n\nbinOp\n\nA binary operation that can merge the payloads of two same types. Defined as a function that take two payloads as parameters and return the payloads merged.\n\nOption Definitions \n\nOption definitions are generally straight-forward bindings of values to option names, like\n\nconfig = {\n  services.httpd.enable = true;\n};\n\n\nHowever, sometimes you need to wrap an option definition or set of option definitions in a property to achieve certain effects:\n\nDelaying Conditionals \n\nIf a set of option definitions is conditional on the value of another option, you may need to use mkIf. Consider, for instance:\n\nconfig = if config.services.httpd.enable then {\n  environment.systemPackages = [ ... ];\n  ...\n} else {};\n\n\nThis definition will cause Nix to fail with an “infinite recursion” error. Why? Because the value of config.services.httpd.enable depends on the value being constructed here. After all, you could also write the clearly circular and contradictory:\n\nconfig = if config.services.httpd.enable then {\n  services.httpd.enable = false;\n} else {\n  services.httpd.enable = true;\n};\n\n\nThe solution is to write:\n\nconfig = mkIf config.services.httpd.enable {\n  environment.systemPackages = [ ... ];\n  ...\n};\n\n\nThe special function mkIf causes the evaluation of the conditional to be “pushed down” into the individual definitions, as if you had written:\n\nconfig = {\n  environment.systemPackages = if config.services.httpd.enable then [ ... ] else [];\n  ...\n};\n\nSetting Priorities \n\nA module can override the definitions of an option in other modules by setting an override priority. All option definitions that do not have the lowest priority value are discarded. By default, option definitions have priority 100 and option defaults have priority 1500. You can specify an explicit priority by using mkOverride, e.g.\n\nservices.openssh.enable = mkOverride 10 false;\n\n\nThis definition causes all other definitions with priorities above 10 to be discarded. The function mkForce is equal to mkOverride 50, and mkDefault is equal to mkOverride 1000.\n\nOrdering Definitions \n\nIt is also possible to influence the order in which the definitions for an option are merged by setting an order priority with mkOrder. The default order priority is 1000. The functions mkBefore and mkAfter are equal to mkOrder 500 and mkOrder 1500, respectively. As an example,\n\nhardware.firmware = mkBefore [ myFirmware ];\n\n\nThis definition ensures that myFirmware comes before other unordered definitions in the final list value of hardware.firmware.\n\nNote that this is different from override priorities: setting an order does not affect whether the definition is included or not.\n\nMerging Configurations \n\nIn conjunction with mkIf, it is sometimes useful for a module to return multiple sets of option definitions, to be merged together as if they were declared in separate modules. This can be done using mkMerge:\n\nconfig = mkMerge\n  [ # Unconditional stuff.\n    { environment.systemPackages = [ ... ];\n    }\n    # Conditional stuff.\n    (mkIf config.services.bla.enable {\n      environment.systemPackages = [ ... ];\n    })\n  ];\n\nWarnings and Assertions \n\nWhen configuration problems are detectable in a module, it is a good idea to write an assertion or warning. Doing so provides clear feedback to the user and prevents errors after the build.\n\nAlthough Nix has the abort and builtins.trace functions to perform such tasks, they are not ideally suited for NixOS modules. Instead of these functions, you can declare your warnings and assertions using the NixOS module system.\n\nWarnings \n\nThis is an example of using warnings.\n\n{ config, lib, ... }:\n{\n  config = lib.mkIf config.services.foo.enable {\n    warnings =\n      if config.services.foo.bar\n      then [ ''You have enabled the bar feature of the foo service.\n               This is known to cause some specific problems in certain situations.\n               '' ]\n      else [];\n  }\n}\n\nAssertions \n\nThis example, extracted from the syslogd module shows how to use assertions. Since there can only be one active syslog daemon at a time, an assertion is useful to prevent such a broken system from being built.\n\n{ config, lib, ... }:\n{\n  config = lib.mkIf config.services.syslogd.enable {\n    assertions =\n      [ { assertion = !config.services.rsyslogd.enable;\n          message = \"rsyslogd conflicts with syslogd\";\n        }\n      ];\n  }\n}\n\nMeta Attributes \n\nLike Nix packages, NixOS modules can declare meta-attributes to provide extra information. Module meta attributes are defined in the meta.nix special module.\n\nmeta is a top level attribute like options and config. Available meta-attributes are maintainers, doc, and buildDocsInSandbox.\n\nEach of the meta-attributes must be defined at most once per module file.\n\n{ config, lib, pkgs, ... }:\n{\n  options = {\n    ...\n  };\n\n  config = {\n    ...\n  };\n\n  meta = {\n    maintainers = with lib.maintainers; [ ericsagnes ];\n    doc = ./default.md;\n    buildDocsInSandbox = true;\n  };\n}\n\n\nmaintainers contains a list of the module maintainers.\n\ndoc points to a valid Nixpkgs-flavored CommonMark file containing the module documentation. Its contents is automatically added to Configuration. Changes to a module documentation have to be checked to not break building the NixOS manual:\n\n$ nix-build nixos/release.nix -A manual.x86_64-linux\n\n\nbuildDocsInSandbox indicates whether the option documentation for the module can be built in a derivation sandbox. This option is currently only honored for modules shipped by nixpkgs. User modules and modules taken from NIXOS_EXTRA_MODULE_PATH are always built outside of the sandbox, as has been the case in previous releases.\n\nBuilding NixOS option documentation in a sandbox allows caching of the built documentation, which greatly decreases the amount of time needed to evaluate a system configuration that has NixOS documentation enabled. The sandbox also restricts which attributes may be referenced by documentation attributes (such as option descriptions) to the options and lib module arguments and the pkgs.formats attribute of the pkgs argument, config and the rest of pkgs are disallowed and will cause doc build failures when used. This restriction is necessary because we cannot reproduce the full nixpkgs instantiation with configuration and overlays from a system configuration inside the sandbox. The options argument only includes options of modules that are also built inside the sandbox, referencing an option of a module that isn’t built in the sandbox is also forbidden.\n\nThe default is true and should usually not be changed; set it to false only if the module requires access to pkgs in its documentation (e.g. because it loads information from a linked package to build an option type) or if its documentation depends on other modules that also aren’t sandboxed (e.g. by using types defined in the other module).\n\nImporting Modules \n\nSometimes NixOS modules need to be used in configuration but exist outside of Nixpkgs. These modules can be imported:\n\n{ config, lib, pkgs, ... }:\n\n{\n  imports =\n    [ # Use a locally-available module definition in\n      # ./example-module/default.nix\n        ./example-module\n    ];\n\n  services.exampleModule.enable = true;\n}\n\n\nThe environment variable NIXOS_EXTRA_MODULE_PATH is an absolute path to a NixOS module that is included alongside the Nixpkgs NixOS modules. Like any NixOS module, this module can import additional modules:\n\n# ./module-list/default.nix\n[\n  ./example-module1\n  ./example-module2\n]\n\n# ./extra-module/default.nix\n{ imports = import ./module-list.nix; }\n\n# NIXOS_EXTRA_MODULE_PATH=/absolute/path/to/extra-module\n{ config, lib, pkgs, ... }:\n\n{\n  # No `imports` needed\n\n  services.exampleModule1.enable = true;\n}\n\nReplace Modules \n\nModules that are imported can also be disabled. The option declarations, config implementation and the imports of a disabled module will be ignored, allowing another to take its place. This can be used to import a set of modules from another channel while keeping the rest of the system on a stable release.\n\ndisabledModules is a top level attribute like imports, options and config. It contains a list of modules that will be disabled. This can either be:\n\nthe full path to the module,\n\nor a string with the filename relative to the modules path (eg. <nixpkgs/nixos/modules> for nixos),\n\nor an attribute set containing a specific key attribute.\n\nThe latter allows some modules to be disabled, despite them being distributed via attributes instead of file paths. The key should be globally unique, so it is recommended to include a file path in it, or rely on a framework to do it for you.\n\nThis example will replace the existing postgresql module with the version defined in the nixos-unstable channel while keeping the rest of the modules and packages from the original nixos channel. This only overrides the module definition, this won’t use postgresql from nixos-unstable unless explicitly configured to do so.\n\n{ config, lib, pkgs, ... }:\n\n{\n  disabledModules = [ \"services/databases/postgresql.nix\" ];\n\n  imports =\n    [ # Use postgresql service from nixos-unstable channel.\n      # sudo nix-channel --add https://nixos.org/channels/nixos-unstable nixos-unstable\n      <nixos-unstable/nixos/modules/services/databases/postgresql.nix>\n    ];\n\n  services.postgresql.enable = true;\n}\n\n\nThis example shows how to define a custom module as a replacement for an existing module. Importing this module will disable the original module without having to know its implementation details.\n\n{ config, lib, pkgs, ... }:\n\nwith lib;\n\nlet\n  cfg = config.programs.man;\nin\n\n{\n  disabledModules = [ \"services/programs/man.nix\" ];\n\n  options = {\n    programs.man.enable = mkOption {\n      type = types.bool;\n      default = true;\n      description = \"Whether to enable manual pages.\";\n    };\n  };\n\n  config = mkIf cfg.enabled {\n    warnings = [ \"disabled manpages for production deployments.\" ];\n  };\n}\n\nFreeform modules \n\nFreeform modules allow you to define values for option paths that have not been declared explicitly. This can be used to add attribute-specific types to what would otherwise have to be attrsOf options in order to accept all attribute names.\n\nThis feature can be enabled by using the attribute freeformType to define a freeform type. By doing this, all assignments without an associated option will be merged using the freeform type and combined into the resulting config set. Since this feature nullifies name checking for entire option trees, it is only recommended for use in submodules.\n\nExample 30. Freeform submodule\n\nThe following shows a submodule assigning a freeform type that allows arbitrary attributes with str values below settings, but also declares an option for the settings.port attribute to have it type-checked and assign a default value. See Example: Declaring a type-checked settings attribute for a more complete example.\n\n{ lib, config, ... }: {\n\n  options.settings = lib.mkOption {\n    type = lib.types.submodule {\n\n      freeformType = with lib.types; attrsOf str;\n\n      # We want this attribute to be checked for the correct type\n      options.port = lib.mkOption {\n        type = lib.types.port;\n        # Declaring the option also allows defining a default value\n        default = 8080;\n      };\n\n    };\n  };\n}\n\n\nAnd the following shows what such a module then allows\n\n{\n  # Not a declared option, but the freeform type allows this\n  settings.logLevel = \"debug\";\n\n  # Not allowed because the the freeform type only allows strings\n  # settings.enable = true;\n\n  # Allowed because there is a port option declared\n  settings.port = 80;\n\n  # Not allowed because the port option doesn't allow strings\n  # settings.port = \"443\";\n}\n\n\n\nNote\n\nFreeform attributes cannot depend on other attributes of the same set without infinite recursion:\n\n{\n  # This throws infinite recursion encountered\n  settings.logLevel = lib.mkIf (config.settings.port == 80) \"debug\";\n}\n\n\nTo prevent this, declare options for all attributes that need to depend on others. For above example this means to declare logLevel to be an option.\n\nOptions for Program Settings \n\nMany programs have configuration files where program-specific settings can be declared. File formats can be separated into two categories:\n\nNix-representable ones: These can trivially be mapped to a subset of Nix syntax. E.g. JSON is an example, since its values like {\"foo\":{\"bar\":10}} can be mapped directly to Nix: { foo = { bar = 10; }; }. Other examples are INI, YAML and TOML. The following section explains the convention for these settings.\n\nNon-nix-representable ones: These can’t be trivially mapped to a subset of Nix syntax. Most generic programming languages are in this group, e.g. bash, since the statement if true; then echo hi; fi doesn’t have a trivial representation in Nix.\n\nCurrently there are no fixed conventions for these, but it is common to have a configFile option for setting the configuration file path directly. The default value of configFile can be an auto-generated file, with convenient options for controlling the contents. For example an option of type attrsOf str can be used for representing environment variables which generates a section like export FOO=\"foo\". Often it can also be useful to also include an extraConfig option of type lines to allow arbitrary text after the autogenerated part of the file.\n\nNix-representable Formats (JSON, YAML, TOML, INI, …) \n\nBy convention, formats like this are handled with a generic settings option, representing the full program configuration as a Nix value. The type of this option should represent the format. The most common formats have a predefined type and string generator already declared under pkgs.formats:\n\npkgs.formats.javaProperties { comment ? \"Generated with Nix\" }\n\nA function taking an attribute set with values\n\ncomment\n\nA string to put at the start of the file in a comment. It can have multiple lines.\n\nIt returns the type: attrsOf str and a function generate to build a Java .properties file, taking care of the correct escaping, etc.\n\npkgs.formats.json { }\n\nA function taking an empty attribute set (for future extensibility) and returning a set with JSON-specific attributes type and generate as specified below.\n\npkgs.formats.yaml { }\n\nA function taking an empty attribute set (for future extensibility) and returning a set with YAML-specific attributes type and generate as specified below.\n\npkgs.formats.ini { listsAsDuplicateKeys ? false, listToValue ? null, ... }\n\nA function taking an attribute set with values\n\nlistsAsDuplicateKeys\n\nA boolean for controlling whether list values can be used to represent duplicate INI keys\n\nlistToValue\n\nA function for turning a list of values into a single value.\n\nIt returns a set with INI-specific attributes type and generate as specified below.\n\npkgs.formats.toml { }\n\nA function taking an empty attribute set (for future extensibility) and returning a set with TOML-specific attributes type and generate as specified below.\n\npkgs.formats.elixirConf { elixir ? pkgs.elixir }\n\nA function taking an attribute set with values\n\nelixir\n\nThe Elixir package which will be used to format the generated output\n\nIt returns a set with Elixir-Config-specific attributes type, lib, and generate as specified below.\n\nThe lib attribute contains functions to be used in settings, for generating special Elixir values:\n\nmkRaw elixirCode\n\nOutputs the given string as raw Elixir code\n\nmkGetEnv { envVariable, fallback ? null }\n\nMakes the configuration fetch an environment variable at runtime\n\nmkAtom atom\n\nOutputs the given string as an Elixir atom, instead of the default Elixir binary string. Note: lowercase atoms still needs to be prefixed with :\n\nmkTuple array\n\nOutputs the given array as an Elixir tuple, instead of the default Elixir list\n\nmkMap attrset\n\nOutputs the given attribute set as an Elixir map, instead of the default Elixir keyword list\n\nThese functions all return an attribute set with these values:\n\ntype\n\nA module system type representing a value of the format\n\nlib\n\nUtility functions for convenience, or special interactions with the format. This attribute is optional. It may contain inside a types attribute containing types specific to this format.\n\ngenerate filename jsonValue\n\nA function that can render a value of the format to a file. Returns a file path.\n\nNote\n\nThis function puts the value contents in the Nix store. So this should be avoided for secrets.\n\nExample 31. Module with conventional settings option\n\nThe following shows a module for an example program that uses a JSON configuration file. It demonstrates how above values can be used, along with some other related best practices. See the comments for explanations.\n\n{ options, config, lib, pkgs, ... }:\nlet\n  cfg = config.services.foo;\n  # Define the settings format used for this program\n  settingsFormat = pkgs.formats.json {};\nin {\n\n  options.services.foo = {\n    enable = lib.mkEnableOption \"foo service\";\n\n    settings = lib.mkOption {\n      # Setting this type allows for correct merging behavior\n      type = settingsFormat.type;\n      default = {};\n      description = ''\n        Configuration for foo, see\n        <link xlink:href=\"https://example.com/docs/foo\"/>\n        for supported settings.\n      '';\n    };\n  };\n\n  config = lib.mkIf cfg.enable {\n    # We can assign some default settings here to make the service work by just\n    # enabling it. We use `mkDefault` for values that can be changed without\n    # problems\n    services.foo.settings = {\n      # Fails at runtime without any value set\n      log_level = lib.mkDefault \"WARN\";\n\n      # We assume systemd's `StateDirectory` is used, so we require this value,\n      # therefore no mkDefault\n      data_path = \"/var/lib/foo\";\n\n      # Since we use this to create a user we need to know the default value at\n      # eval time\n      user = lib.mkDefault \"foo\";\n    };\n\n    environment.etc.\"foo.json\".source =\n      # The formats generator function takes a filename and the Nix value\n      # representing the format value and produces a filepath with that value\n      # rendered in the format\n      settingsFormat.generate \"foo-config.json\" cfg.settings;\n\n    # We know that the `user` attribute exists because we set a default value\n    # for it above, allowing us to use it without worries here\n    users.users.${cfg.settings.user} = { isSystemUser = true; };\n\n    # ...\n  };\n}\n\n\n\nOption declarations for attributes\n\nSome settings attributes may deserve some extra care. They may need a different type, default or merging behavior, or they are essential options that should show their documentation in the manual. This can be done using the section called “Freeform modules”.\n\nWe extend above example using freeform modules to declare an option for the port, which will enforce it to be a valid integer and make it show up in the manual.\n\nExample 32. Declaring a type-checked settings attribute\n\nsettings = lib.mkOption {\n  type = lib.types.submodule {\n\n    freeformType = settingsFormat.type;\n\n    # Declare an option for the port such that the type is checked and this option\n    # is shown in the manual.\n    options.port = lib.mkOption {\n      type = lib.types.port;\n      default = 8080;\n      description = ''\n        Which port this service should listen on.\n      '';\n    };\n\n  };\n  default = {};\n  description = ''\n    Configuration for Foo, see\n    <link xlink:href=\"https://example.com/docs/foo\"/>\n    for supported values.\n  '';\n};\n\n\n\nBuilding Specific Parts of NixOS \n\nWith the command nix-build, you can build specific parts of your NixOS configuration. This is done as follows:\n\n$ cd /path/to/nixpkgs/nixos\n$ nix-build -A config.option\n\n\nwhere option is a NixOS option with type “derivation” (i.e. something that can be built). Attributes of interest include:\n\nsystem.build.toplevel\n\nThe top-level option that builds the entire NixOS system. Everything else in your configuration is indirectly pulled in by this option. This is what nixos-rebuild builds and what /run/current-system points to afterwards.\n\nA shortcut to build this is:\n\n$ nix-build -A system\n\nsystem.build.manual.manualHTML\n\nThe NixOS manual.\n\nsystem.build.etc\n\nA tree of symlinks that form the static parts of /etc.\n\nsystem.build.initialRamdisk , system.build.kernel\n\nThe initial ramdisk and kernel of the system. This allows a quick way to test whether the kernel and the initial ramdisk boot correctly, by using QEMU’s -kernel and -initrd options:\n\n$ nix-build -A config.system.build.initialRamdisk -o initrd\n$ nix-build -A config.system.build.kernel -o kernel\n$ qemu-system-x86_64 -kernel ./kernel/bzImage -initrd ./initrd/initrd -hda /dev/null\n\nsystem.build.nixos-rebuild , system.build.nixos-install , system.build.nixos-generate-config\n\nThese build the corresponding NixOS commands.\n\nsystemd.units.unit-name.unit\n\nThis builds the unit with the specified name. Note that since unit names contain dots (e.g. httpd.service), you need to put them between quotes, like this:\n\n$ nix-build -A 'config.systemd.units.\"httpd.service\".unit'\n\n\nYou can also test individual units, without rebuilding the whole system, by putting them in /run/systemd/system:\n\n$ cp $(nix-build -A 'config.systemd.units.\"httpd.service\".unit')/httpd.service \\\n    /run/systemd/system/tmp-httpd.service\n# systemctl daemon-reload\n# systemctl start tmp-httpd.service\n\n\nNote that the unit must not have the same name as any unit in /etc/systemd/system since those take precedence over /run/systemd/system. That’s why the unit is installed as tmp-httpd.service here.\n\nExperimental feature: Bootspec \n\nTable of Contents\n\nSchema\nExtensions mechanism\nExternal bootloaders\n\nBootspec is a experimental feature, introduced in the RFC-0125 proposal, the reference implementation can be found there in order to standardize bootloader support and advanced boot workflows such as SecureBoot and potentially more.\n\nYou can enable the creation of bootspec documents through boot.bootspec.enable = true, which will prompt a warning until RFC-0125 is officially merged.\n\nSchema \n\nThe bootspec schema is versioned and validated against a CUE schema file which should considered as the source of truth for your applications.\n\nYou will find the current version here.\n\nExtensions mechanism \n\nBootspec cannot account for all usecases.\n\nFor this purpose, Bootspec offers a generic extension facility boot.bootspec.extensions which can be used to inject any data needed for your usecases.\n\nAn example for SecureBoot is to get the Nix store path to /etc/os-release in order to bake it into a unified kernel image:\n\n{ config, lib, ... }: {\n  boot.bootspec.extensions = {\n    \"org.secureboot.osRelease\" = config.environment.etc.\"os-release\".source;\n  };\n}\n\n\nTo reduce incompatibility and prevent names from clashing between applications, it is highly recommended to use a unique namespace for your extensions.\n\nExternal bootloaders \n\nIt is possible to enable your own bootloader through boot.loader.external.installHook which can wrap an existing bootloader.\n\nCurrently, there is no good story to compose existing bootloaders to enrich their features, e.g. SecureBoot, etc. It will be necessary to reimplement or reuse existing parts.\n\nWhat happens during a system switch? \n\nTable of Contents\n\nUnit handling\nActivation script\nNon Switchable Systems\n\nRunning nixos-rebuild switch is one of the more common tasks under NixOS. This chapter explains some of the internals of this command to make it simpler for new module developers to configure their units correctly and to make it easier to understand what is happening and why for curious administrators.\n\nnixos-rebuild, like many deployment solutions, calls switch-to-configuration which resides in a NixOS system at $out/bin/switch-to-configuration. The script is called with the action that is to be performed like switch, test, boot. There is also the dry-activate action which does not really perform the actions but rather prints what it would do if you called it with test. This feature can be used to check what service states would be changed if the configuration was switched to.\n\nIf the action is switch or boot, the bootloader is updated first so the configuration will be the next one to boot. Unless NIXOS_NO_SYNC is set to 1, /nix/store is synced to disk.\n\nIf the action is switch or test, the currently running system is inspected and the actions to switch to the new system are calculated. This process takes two data sources into account: /etc/fstab and the current systemd status. Mounts and swaps are read from /etc/fstab and the corresponding actions are generated. If the options of a mount are modified, for example, the proper .mount unit is reloaded (or restarted if anything else changed and it’s neither the root mount or the nix store). The current systemd state is inspected, the difference between the current system and the desired configuration is calculated and actions are generated to get to this state. There are a lot of nuances that can be controlled by the units which are explained here.\n\nAfter calculating what should be done, the actions are carried out. The order of actions is always the same:\n\nStop units (systemctl stop)\n\nRun activation script ($out/activate)\n\nSee if the activation script requested more units to restart\n\nRestart systemd if needed (systemd daemon-reexec)\n\nForget about the failed state of units (systemctl reset-failed)\n\nReload systemd (systemctl daemon-reload)\n\nReload systemd user instances (systemctl --user daemon-reload)\n\nSet up tmpfiles (systemd-tmpfiles --create)\n\nReload units (systemctl reload)\n\nRestart units (systemctl restart)\n\nStart units (systemctl start)\n\nInspect what changed during these actions and print units that failed and that were newly started\n\nBy default, some units are filtered from the outputs to make it less spammy. This can be disabled for development or testing by setting the environment variable STC_DISPLAY_ALL_UNITS=1\n\nMost of these actions are either self-explaining but some of them have to do with our units or the activation script. For this reason, these topics are explained in the next sections.\n\nUnit handling \n\nTo figure out what units need to be started/stopped/restarted/reloaded, the script first checks the current state of the system, similar to what systemctl list-units shows. For each of the units, the script goes through the following checks:\n\nIs the unit file still in the new system? If not, stop the service unless it sets X-StopOnRemoval in the [Unit] section to false.\n\nIs it a .target unit? If so, start it unless it sets RefuseManualStart in the [Unit] section to true or X-OnlyManualStart in the [Unit] section to true. Also stop the unit again unless it sets X-StopOnReconfiguration to false.\n\nAre the contents of the unit files different? They are compared by parsing them and comparing their contents. If they are different but only X-Reload-Triggers in the [Unit] section is changed, reload the unit. The NixOS module system allows setting these triggers with the option systemd.services.<name>.reloadTriggers. There are some additional keys in the [Unit] section that are ignored as well. If the unit files differ in any way, the following actions are performed:\n\n.path and .slice units are ignored. There is no need to restart them since changes in their values are applied by systemd when systemd is reloaded.\n\n.mount units are reloaded if only their Options changed. If anything else changed (like What), they are restarted unless they are the mount unit for / or /nix in which case they are reloaded to prevent the system from crashing. Note that this is the case for .mount units and not for mounts from /etc/fstab. These are explained in What happens during a system switch?.\n\n.socket units are currently ignored. This is to be fixed at a later point.\n\nThe rest of the units (mostly .service units) are then reloaded if X-ReloadIfChanged in the [Service] section is set to true (exposed via systemd.services.<name>.reloadIfChanged). A little exception is done for units that were deactivated in the meantime, for example because they require a unit that got stopped before. These are started instead of reloaded.\n\nIf the reload flag is not set, some more flags decide if the unit is skipped. These flags are X-RestartIfChanged in the [Service] section (exposed via systemd.services.<name>.restartIfChanged), RefuseManualStop in the [Unit] section, and X-OnlyManualStart in the [Unit] section.\n\nFurther behavior depends on the unit having X-StopIfChanged in the [Service] section set to true (exposed via systemd.services.<name>.stopIfChanged). This is set to true by default and must be explicitly turned off if not wanted. If the flag is enabled, the unit is stopped and then started. If not, the unit is restarted. The goal of the flag is to make sure that the new unit never runs in the old environment which is still in place before the activation script is run. This behavior is different when the service is socket-activated, as outlined in the following steps.\n\nThe last thing that is taken into account is whether the unit is a service and socket-activated. If X-StopIfChanged is not set, the service is restarted with the others. If it is set, both the service and the socket are stopped and the socket is started, leaving socket activation to start the service when it’s needed.\n\nActivation script \n\nThe activation script is a bash script called to activate the new configuration which resides in a NixOS system in $out/activate. Since its contents depend on your system configuration, the contents may differ. This chapter explains how the script works in general and some common NixOS snippets. Please be aware that the script is executed on every boot and system switch, so tasks that can be performed in other places should be performed there (for example letting a directory of a service be created by systemd using mechanisms like StateDirectory, CacheDirectory, … or if that’s not possible using preStart of the service).\n\nActivation scripts are defined as snippets using system.activationScripts. They can either be a simple multiline string or an attribute set that can depend on other snippets. The builder for the activation script will take these dependencies into account and order the snippets accordingly. As a simple example:\n\nsystem.activationScripts.my-activation-script = {\n  deps = [ \"etc\" ];\n  # supportsDryActivation = true;\n  text = ''\n    echo \"Hallo i bims\"\n  '';\n};\n\n\nThis example creates an activation script snippet that is run after the etc snippet. The special variable supportsDryActivation can be set so the snippet is also run when nixos-rebuild dry-activate is run. To differentiate between real and dry activation, the $NIXOS_ACTION environment variable can be read which is set to dry-activate when a dry activation is done.\n\nAn activation script can write to special files instructing switch-to-configuration to restart/reload units. The script will take these requests into account and will incorporate the unit configuration as described above. This means that the activation script will “fake” a modified unit file and switch-to-configuration will act accordingly. By doing so, configuration like systemd.services.<name>.restartIfChanged is respected. Since the activation script is run after services are already stopped, systemd.services.<name>.stopIfChanged cannot be taken into account anymore and the unit is always restarted instead of being stopped and started afterwards.\n\nThe files that can be written to are /run/nixos/activation-restart-list and /run/nixos/activation-reload-list with their respective counterparts for dry activation being /run/nixos/dry-activation-restart-list and /run/nixos/dry-activation-reload-list. Those files can contain newline-separated lists of unit names where duplicates are being ignored. These files are not create automatically and activation scripts must take the possibility into account that they have to create them first.\n\nNixOS snippets \n\nThere are some snippets NixOS enables by default because disabling them would most likely break your system. This section lists a few of them and what they do:\n\nbinsh creates /bin/sh which points to the runtime shell\n\netc sets up the contents of /etc, this includes systemd units and excludes /etc/passwd, /etc/group, and /etc/shadow (which are managed by the users snippet)\n\nhostname sets the system’s hostname in the kernel (not in /etc)\n\nmodprobe sets the path to the modprobe binary for module auto-loading\n\nnix prepares the nix store and adds a default initial channel\n\nspecialfs is responsible for mounting filesystems like /proc and sys\n\nusers creates and removes users and groups by managing /etc/passwd, /etc/group and /etc/shadow. This also creates home directories\n\nusrbinenv creates /usr/bin/env\n\nvar creates some directories in /var that are not service-specific\n\nwrappers creates setuid wrappers like sudo\n\nNon Switchable Systems \n\nIn certain systems, most notably image based appliances, updates are handled outside the system. This means that you do not need to rebuild your configuration on the system itself anymore.\n\nIf you want to build such a system, you can use the image-based-appliance profile:\n\n{ modulesPath, ... }: {\n  imports = [ \"${modulesPath}/profiles/image-based-appliance.nix\" ]\n}\n\n\nThe most notable deviation of this profile from a standard NixOS configuration is that after building it, you cannot switch to the configuration anymore. The profile sets config.system.switch.enable = false;, which excludes switch-to-configuration, the central script called by nixos-rebuild, from your system. Removing this script makes the image lighter and slightly more secure.\n\nWriting NixOS Documentation \n\nTable of Contents\n\nBuilding the Manual\nEditing DocBook XML\nCreating a Topic\nAdding a Topic to the Book\n\nAs NixOS grows, so too does the need for a catalogue and explanation of its extensive functionality. Collecting pertinent information from disparate sources and presenting it in an accessible style would be a worthy contribution to the project.\n\nBuilding the Manual \n\nThe DocBook sources of the NixOS Manual are in the nixos/doc/manual subdirectory of the Nixpkgs repository.\n\nYou can quickly validate your edits with make:\n\n$ cd /path/to/nixpkgs/nixos/doc/manual\n$ nix-shell\nnix-shell$ devmode\n\n\nOnce you are done making modifications to the manual, it’s important to build it before committing. You can do that as follows:\n\nnix-build nixos/release.nix -A manual.x86_64-linux\n\n\nWhen this command successfully finishes, it will tell you where the manual got generated. The HTML will be accessible through the result symlink at ./result/share/doc/nixos/index.html.\n\nEditing DocBook XML \n\nFor general information on how to write in DocBook, see DocBook 5: The Definitive Guide.\n\nEmacs nXML Mode is very helpful for editing DocBook XML because it validates the document as you write, and precisely locates errors. To use it, see the section called “Editing DocBook 5 XML Documents”.\n\nPandoc can generate DocBook XML from a multitude of formats, which makes a good starting point. Here is an example of Pandoc invocation to convert GitHub-Flavoured MarkDown to DocBook 5 XML:\n\npandoc -f markdown_github -t docbook5 docs.md -o my-section.md\n\n\nPandoc can also quickly convert a single section.xml to HTML, which is helpful when drafting.\n\nSometimes writing valid DocBook is too difficult. In this case, submit your documentation updates in a GitHub Issue and someone will handle the conversion to XML for you.\n\nCreating a Topic \n\nYou can use an existing topic as a basis for the new topic or create a topic from scratch.\n\nKeep the following guidelines in mind when you create and add a topic:\n\nThe NixOS book element is in nixos/doc/manual/manual.xml. It includes several parts which are in subdirectories.\n\nStore the topic file in the same directory as the part to which it belongs. If your topic is about configuring a NixOS module, then the XML file can be stored alongside the module definition nix file.\n\nIf you include multiple words in the file name, separate the words with a dash. For example: ipv6-config.xml.\n\nMake sure that the xml:id value is unique. You can use abbreviations if the ID is too long. For example: nixos-config.\n\nDetermine whether your topic is a chapter or a section. If you are unsure, open an existing topic file and check whether the main element is chapter or section.\n\nAdding a Topic to the Book \n\nOpen the parent CommonMark file and add a line to the list of chapters with the file name of the topic that you created. If you created a section, you add the file to the chapter file. If you created a chapter, you add the file to the part file.\n\nIf the topic is about configuring a NixOS module, it can be automatically included in the manual by using the meta.doc attribute. See the section called “Meta Attributes” for an explanation.\n\nNixOS Tests \n\nTable of Contents\n\nWriting Tests\nRunning Tests\nRunning Tests interactively\nLinking NixOS tests to packages\n\nWhen you add some feature to NixOS, you should write a test for it. NixOS tests are kept in the directory nixos/tests, and are executed (using Nix) by a testing framework that automatically starts one or more virtual machines containing the NixOS system(s) required for the test.\n\nWriting Tests \n\nA NixOS test is a module that has the following structure:\n\n{\n\n  # One or more machines:\n  nodes =\n    { machine =\n        { config, pkgs, ... }: { … };\n      machine2 =\n        { config, pkgs, ... }: { … };\n      …\n    };\n\n  testScript =\n    ''\n      Python code…\n    '';\n}\n\n\nWe refer to the whole test above as a test module, whereas the values in nodes.<name> are NixOS modules themselves.\n\nThe option testScript is a piece of Python code that executes the test (described below). During the test, it will start one or more virtual machines, the configuration of which is described by the option nodes.\n\nAn example of a single-node test is login.nix. It only needs a single machine to test whether users can log in on the virtual console, whether device ownership is correctly maintained when switching between consoles, and so on. An interesting multi-node test is nfs/simple.nix. It uses two client nodes to test correct locking across server crashes.\n\nCalling a test \n\nTests are invoked differently depending on whether the test is part of NixOS or lives in a different project.\n\nTesting within NixOS\n\nTests that are part of NixOS are added to nixos/tests/all-tests.nix.\n\n  hostname = runTest ./hostname.nix;\n\n\nOverrides can be added by defining an anonymous module in all-tests.nix.\n\n  hostname = runTest {\n    imports = [ ./hostname.nix ];\n    defaults.networking.firewall.enable = false;\n  };\n\n\nYou can run a test with attribute name hostname in nixos/tests/all-tests.nix by invoking:\n\ncd /my/git/clone/of/nixpkgs\nnix-build -A nixosTests.hostname\n\nTesting outside the NixOS project\n\nOutside the nixpkgs repository, you can instantiate the test by first importing the NixOS library,\n\nlet nixos-lib = import (nixpkgs + \"/nixos/lib\") { };\nin\n\nnixos-lib.runTest {\n  imports = [ ./test.nix ];\n  hostPkgs = pkgs;  # the Nixpkgs package set used outside the VMs\n  defaults.services.foo.package = mypkg;\n}\n\n\nrunTest returns a derivation that runs the test.\n\nConfiguring the nodes \n\nThere are a few special NixOS options for test VMs:\n\nvirtualisation.memorySize\n\nThe memory of the VM in megabytes.\n\nvirtualisation.vlans\n\nThe virtual networks to which the VM is connected. See nat.nix for an example.\n\nvirtualisation.writableStore\n\nBy default, the Nix store in the VM is not writable. If you enable this option, a writable union file system is mounted on top of the Nix store to make it appear writable. This is necessary for tests that run Nix operations that modify the store.\n\nFor more options, see the module qemu-vm.nix.\n\nThe test script is a sequence of Python statements that perform various actions, such as starting VMs, executing commands in the VMs, and so on. Each virtual machine is represented as an object stored in the variable name if this is also the identifier of the machine in the declarative config. If you specified a node nodes.machine, the following example starts the machine, waits until it has finished booting, then executes a command and checks that the output is more-or-less correct:\n\nmachine.start()\nmachine.wait_for_unit(\"default.target\")\nif not \"Linux\" in machine.succeed(\"uname\"):\n  raise Exception(\"Wrong OS\")\n\n\nThe first line is technically unnecessary; machines are implicitly started when you first execute an action on them (such as wait_for_unit or succeed). If you have multiple machines, you can speed up the test by starting them in parallel:\n\nstart_all()\n\n\nIf the hostname of a node contains characters that can’t be used in a Python variable name, those characters will be replaced with underscores in the variable name, so nodes.machine-a will be exposed to Python as machine_a.\n\nMachine objects \n\nThe following methods are available on machine objects:\n\nblock()\n\nSimulate unplugging the Ethernet cable that connects the machine to the other machines. This happens by shutting down eth1 (the multicast interface used to talk to the other VMs). eth0 is kept online to still enable the test driver to communicate with the machine.\n\nconsole_interact()\n\nAllows you to directly interact with QEMU’s stdin, by forwarding terminal input to the QEMU process. This is for use with the interactive test driver, not for production tests, which run unattended. Output from QEMU is only read line-wise. Ctrl-c kills QEMU and Ctrl-d closes console and returns to the test runner.\n\ncopy_from_host(source, target)\n\nCopies a file from host to machine, e.g., copy_from_host(\"myfile\", \"/etc/my/important/file\").\n\nThe first argument is the file on the host. Note that the “host” refers to the environment in which the test driver runs, which is typically the Nix build sandbox.\n\nThe second argument is the location of the file on the machine that will be written to.\n\nThe file is copied via the shared_dir directory which is shared among all the VMs (using a temporary directory). The access rights bits will mimic the ones from the host file and user:group will be root:root.\n\ncopy_from_host_via_shell(source, target)\n\nCopy a file from the host into the guest by piping it over the shell into the destination file. Works without host-guest shared folder. Prefer copy_from_host for whenever possible.\n\ncopy_from_vm(source, target_dir)\n\nCopy a file from the VM (specified by an in-VM source path) to a path relative to $out. The file is copied via the shared_dir shared among all the VMs (using a temporary directory).\n\ncrash()\n\nSimulate a sudden power failure, by telling the VM to exit immediately.\n\ndump_tty_contents(tty)\n\nDebugging: Dump the contents of the TTY<n>\n\nexecute(command, check_return, check_output, timeout)\n\nExecute a shell command, returning a list (status, stdout).\n\nCommands are run with set -euo pipefail set:\n\nIf several commands are separated by ; and one fails, the command as a whole will fail.\n\nFor pipelines, the last non-zero exit status will be returned (if there is one; otherwise zero will be returned).\n\nDereferencing unset variables fails the command.\n\nIt will wait for stdout to be closed.\n\nIf the command detaches, it must close stdout, as execute will wait for this to consume all output reliably. This can be achieved by redirecting stdout to stderr >&2, to /dev/console, /dev/null or a file. Examples of detaching commands are sleep 365d &, where the shell forks a new process that can write to stdout and xclip -i, where the xclip command itself forks without closing stdout.\n\nTakes an optional parameter check_return that defaults to True. Setting this parameter to False will not check for the return code and return -1 instead. This can be used for commands that shut down the VM and would therefore break the pipe that would be used for retrieving the return code.\n\nA timeout for the command can be specified (in seconds) using the optional timeout parameter, e.g., execute(cmd, timeout=10) or execute(cmd, timeout=None). The default is 900 seconds.\n\nfail()\n\nLike succeed, but raising an exception if the command returns a zero status.\n\nforward_port(host_port, guest_port)\n\nForward a TCP port on the host to a TCP port on the guest. Useful during interactive testing.\n\nget_screen_text()\n\nReturn a textual representation of what is currently visible on the machine’s screen using optical character recognition.\n\nNote\n\nThis requires enableOCR to be set to true.\n\nget_screen_text_variants()\n\nReturn a list of different interpretations of what is currently visible on the machine’s screen using optical character recognition. The number and order of the interpretations is not specified and is subject to change, but if no exception is raised at least one will be returned.\n\nNote\n\nThis requires enableOCR to be set to true.\n\nreboot()\n\nPress Ctrl+Alt+Delete in the guest.\n\nPrepares the machine to be reconnected which is useful if the machine was started with allow_reboot = True\n\nscreenshot(filename)\n\nTake a picture of the display of the virtual machine, in PNG format. The screenshot will be available in the derivation output.\n\nsend_chars(chars, delay)\n\nSimulate typing a sequence of characters on the virtual keyboard, e.g., send_chars(\"foobar \") will type the string foobar followed by the Enter key.\n\nsend_console(chars)\n\nSend keys to the kernel console. This allows interaction with the systemd emergency mode, for example. Takes a string that is sent, e.g., send_console(\"\\n\\nsystemctl default\\n\").\n\nsend_key(key, delay, log)\n\nSimulate pressing keys on the virtual keyboard, e.g., send_key(\"ctrl-alt-delete\").\n\nPlease also refer to the QEMU documentation for more information on the input syntax: https://en.wikibooks.org/wiki/QEMU/Monitor#sendkey_keys\n\nsend_monitor_command(command)\n\nSend a command to the QEMU monitor. This allows attaching virtual USB disks to a running machine, among other things.\n\nshell_interact(address)\n\nAllows you to directly interact with the guest shell. This should only be used during test development, not in production tests. Killing the interactive session with Ctrl-d or Ctrl-c also ends the guest session.\n\nshutdown()\n\nShut down the machine, waiting for the VM to exit.\n\nstart(allow_reboot)\n\nStart the virtual machine. This method is asynchronous — it does not wait for the machine to finish booting.\n\nsucceed()\n\nExecute a shell command, raising an exception if the exit status is not zero, otherwise returning the standard output. Similar to execute, except that the timeout is None by default. See execute for details on command execution.\n\nswitch_root()\n\nTransition from stage 1 to stage 2. This requires the machine to be configured with testing.initrdBackdoor = true and boot.initrd.systemd.enable = true.\n\nsystemctl(q, user)\n\nRuns systemctl commands with optional support for systemctl --user\n\n# run `systemctl list-jobs --no-pager`\nmachine.systemctl(\"list-jobs --no-pager\")\n\n# spawn a shell for `any-user` and run\n# `systemctl --user list-jobs --no-pager`\nmachine.systemctl(\"list-jobs --no-pager\", \"any-user\")\n\nunblock()\n\nUndo the effect of block.\n\nwait_for_closed_port(port, addr, timeout)\n\nWait until nobody is listening on the given TCP port and IP address (default localhost).\n\nwait_for_console_text(regex, timeout)\n\nWait until the supplied regular expressions match a line of the serial console output. This method is useful when OCR is not possible or inaccurate.\n\nwait_for_file(filename, timeout)\n\nWaits until the file exists in the machine’s file system.\n\nwait_for_open_port(port, addr, timeout)\n\nWait until a process is listening on the given TCP port and IP address (default localhost).\n\nwait_for_open_unix_socket(addr, is_datagram, timeout)\n\nWait until a process is listening on the given UNIX-domain socket (default to a UNIX-domain stream socket).\n\nwait_for_text(regex, timeout)\n\nWait until the supplied regular expressions matches the textual contents of the screen by using optical character recognition (see get_screen_text and get_screen_text_variants).\n\nNote\n\nThis requires enableOCR to be set to true.\n\nwait_for_unit(unit, user, timeout)\n\nWait for a systemd unit to get into “active” state. Throws exceptions on “failed” and “inactive” states as well as after timing out.\n\nwait_for_window(regexp, timeout)\n\nWait until an X11 window has appeared whose name matches the given regular expression, e.g., wait_for_window(\"Terminal\").\n\nwait_for_x(timeout)\n\nWait until it is possible to connect to the X server.\n\nwait_until_fails(command, timeout)\n\nLike wait_until_succeeds, but repeating the command until it fails.\n\nwait_until_succeeds(command, timeout)\n\nRepeat a shell command with 1-second intervals until it succeeds. Has a default timeout of 900 seconds which can be modified, e.g. wait_until_succeeds(cmd, timeout=10). See execute for details on command execution. Throws an exception on timeout.\n\nwait_until_tty_matches(tty, regexp, timeout)\n\nWait until the visible output on the chosen TTY matches regular expression. Throws an exception on timeout.\n\nTo test user units declared by systemd.user.services the optional user argument can be used:\n\nmachine.start()\nmachine.wait_for_x()\nmachine.wait_for_unit(\"xautolock.service\", \"x-session-user\")\n\n\nThis applies to systemctl, get_unit_info, wait_for_unit, start_job and stop_job.\n\nFor faster dev cycles it’s also possible to disable the code-linters (this shouldn’t be committed though):\n\n{\n  skipLint = true;\n  nodes.machine =\n    { config, pkgs, ... }:\n    { configuration…\n    };\n\n  testScript =\n    ''\n      Python code…\n    '';\n}\n\n\nThis will produce a Nix warning at evaluation time. To fully disable the linter, wrap the test script in comment directives to disable the Black linter directly (again, don’t commit this within the Nixpkgs repository):\n\n  testScript =\n    ''\n      # fmt: off\n      Python code…\n      # fmt: on\n    '';\n\n\nSimilarly, the type checking of test scripts can be disabled in the following way:\n\n{\n  skipTypeCheck = true;\n  nodes.machine =\n    { config, pkgs, ... }:\n    { configuration…\n    };\n}\n\nFailing tests early \n\nTo fail tests early when certain invariants are no longer met (instead of waiting for the build to time out), the decorator polling_condition is provided. For example, if we are testing a program foo that should not quit after being started, we might write the following:\n\n@polling_condition\ndef foo_running():\n    machine.succeed(\"pgrep -x foo\")\n\n\nmachine.succeed(\"foo --start\")\nmachine.wait_until_succeeds(\"pgrep -x foo\")\n\nwith foo_running:\n    ...  # Put `foo` through its paces\n\n\npolling_condition takes the following (optional) arguments:\n\nseconds_interval\n\nspecifies how often the condition should be polled:\n\n@polling_condition(seconds_interval=10)\ndef foo_running():\n    machine.succeed(\"pgrep -x foo\")\n\ndescription\n\nis used in the log when the condition is checked. If this is not provided, the description is pulled from the docstring of the function. These two are therefore equivalent:\n\n@polling_condition\ndef foo_running():\n    \"check that foo is running\"\n    machine.succeed(\"pgrep -x foo\")\n\n@polling_condition(description=\"check that foo is running\")\ndef foo_running():\n    machine.succeed(\"pgrep -x foo\")\n\nAdding Python packages to the test script \n\nWhen additional Python libraries are required in the test script, they can be added using the parameter extraPythonPackages. For example, you could add numpy like this:\n\n{\n  extraPythonPackages = p: [ p.numpy ];\n\n  nodes = { };\n\n  # Type checking on extra packages doesn't work yet\n  skipTypeCheck = true;\n\n  testScript = ''\n    import numpy as np\n    assert str(np.zeros(4) == \"array([0., 0., 0., 0.])\")\n  '';\n}\n\n\nIn that case, numpy is chosen from the generic python3Packages.\n\nTest Options Reference \n\nThe following options can be used when writing tests.\n\nenableOCR\n\nWhether to enable Optical Character Recognition functionality for testing graphical programs. See Machine objects.\n\nType: boolean\n\nDefault: false\n\nDeclared by:\n\nnixos/lib/testing/driver.nix\ndefaults\n\nNixOS configuration that is applied to all nodes.\n\nType: module\n\nDefault: { }\n\nDeclared by:\n\nnixos/lib/testing/nodes.nix\ndriver\n\nPackage containing a script that runs the test.\n\nType: package\n\nDefault: set by the test framework\n\nDeclared by:\n\nnixos/lib/testing/driver.nix\nextraBaseModules\n\nNixOS configuration that, like defaults, is applied to all nodes and can not be undone with specialisation.<name>.inheritParentConfig.\n\nType: module\n\nDefault: { }\n\nDeclared by:\n\nnixos/lib/testing/nodes.nix\nextraDriverArgs\n\nExtra arguments to pass to the test driver.\n\nThey become part of driver via wrapProgram.\n\nType: list of string\n\nDefault: [ ]\n\nDeclared by:\n\nnixos/lib/testing/driver.nix\nextraPythonPackages\n\nPython packages to add to the test driver.\n\nThe argument is a Python package set, similar to pkgs.pythonPackages.\n\nType: function that evaluates to a(n) list of package\n\nDefault: <function>\n\nExample:\n\np: [ p.numpy ]\n\n\n\nDeclared by:\n\nnixos/lib/testing/driver.nix\nglobalTimeout\n\nA global timeout for the complete test, expressed in seconds. Beyond that timeout, every resource will be killed and released and the test will fail.\n\nBy default, we use a 1 hour timeout.\n\nType: signed integer\n\nDefault: 3600\n\nExample: 600\n\nDeclared by:\n\nnixos/lib/testing/driver.nix\nhostPkgs\n\nNixpkgs attrset used outside the nodes.\n\nType: raw value\n\nExample:\n\nimport nixpkgs { inherit system config overlays; }\n\n\n\nDeclared by:\n\nnixos/lib/testing/driver.nix\ninteractive\n\nTests can be run interactively using the program in the test derivation’s .driverInteractive attribute.\n\nWhen they are, the configuration will include anything set in this submodule.\n\nYou can set any top-level test option here.\n\nExample test module:\n\n{ config, lib, ... }: {\n\n  nodes.rabbitmq = {\n    services.rabbitmq.enable = true;\n  };\n\n  # When running interactively ...\n  interactive.nodes.rabbitmq = {\n    # ... enable the web ui.\n    services.rabbitmq.managementPlugin.enable = true;\n  };\n}\n\n\nFor details, see the section about running tests interactively.\n\nType: submodule\n\nDeclared by:\n\nnixos/lib/testing/interactive.nix\nmeta\n\nThe meta attributes that will be set on the returned derivations.\n\nNot all meta attributes are supported, but more can be added as desired.\n\nType: submodule\n\nDefault: { }\n\nDeclared by:\n\nnixos/lib/testing/meta.nix\nmeta.broken\n\nSets the meta.broken attribute on the test derivation.\n\nType: boolean\n\nDefault: false\n\nDeclared by:\n\nnixos/lib/testing/meta.nix\nmeta.maintainers\n\nThe list of maintainers for this test.\n\nType: list of raw value\n\nDefault: [ ]\n\nDeclared by:\n\nnixos/lib/testing/meta.nix\nmeta.timeout\n\nThe test’s meta.timeout in seconds.\n\nType: null or signed integer\n\nDefault: 3600\n\nDeclared by:\n\nnixos/lib/testing/meta.nix\nname\n\nThe name of the test.\n\nThis is used in the derivation names of the driver and test runner.\n\nType: string\n\nDeclared by:\n\nnixos/lib/testing/name.nix\nnode.pkgs\n\nThe Nixpkgs to use for the nodes.\n\nSetting this will make the nixpkgs.* options read-only, to avoid mistakenly testing with a Nixpkgs configuration that diverges from regular use.\n\nType: null or Nixpkgs package set\n\nDefault: null, so construct pkgs according to the nixpkgs.* options as usual.\n\nDeclared by:\n\nnixos/lib/testing/nodes.nix\nnode.pkgsReadOnly\n\nWhether to make the nixpkgs.* options read-only. This is only relevant when node.pkgs is set.\n\nSet this to false when any of the nodes needs to configure any of the nixpkgs.* options. This will slow down evaluation of your test a bit.\n\nType: boolean\n\nDefault: node.pkgs != null\n\nDeclared by:\n\nnixos/lib/testing/nodes.nix\nnode.specialArgs\n\nAn attribute set of arbitrary values that will be made available as module arguments during the resolution of module imports.\n\nNote that it is not possible to override these from within the NixOS configurations. If you argument is not relevant to imports, consider setting defaults._module.args.<name> instead.\n\nType: lazy attribute set of raw value\n\nDefault: { }\n\nDeclared by:\n\nnixos/lib/testing/nodes.nix\nnodes\n\nAn attribute set of NixOS configuration modules.\n\nThe configurations are augmented by the defaults option.\n\nThey are assigned network addresses according to the nixos/lib/testing/network.nix module.\n\nA few special options are available, that aren’t in a plain NixOS configuration. See Configuring the nodes\n\nType: lazy attribute set of module\n\nDeclared by:\n\nnixos/lib/testing/nodes.nix\npassthru\n\nAttributes to add to the returned derivations, which are not necessarily part of the build.\n\nThis is a bit like doing drv // { myAttr = true; } (which would be lost by overrideAttrs). It does not change the actual derivation, but adds the attribute nonetheless, so that consumers of what would be drv have more information.\n\nType: lazy attribute set of raw value\n\nDeclared by:\n\nnixos/lib/testing/run.nix\nqemu.package\n\nWhich qemu package to use for the virtualisation of nodes.\n\nType: package\n\nDefault: \"hostPkgs.qemu_test\"\n\nDeclared by:\n\nnixos/lib/testing/driver.nix\nskipLint\n\nDo not run the linters. This may speed up your iteration cycle, but it is not something you should commit.\n\nType: boolean\n\nDefault: false\n\nDeclared by:\n\nnixos/lib/testing/driver.nix\nskipTypeCheck\n\nDisable type checking. This must not be enabled for new NixOS tests.\n\nThis may speed up your iteration cycle, unless you’re working on the testScript.\n\nType: boolean\n\nDefault: false\n\nDeclared by:\n\nnixos/lib/testing/driver.nix\ntest\n\nDerivation that runs the test as its “build” process.\n\nThis implies that NixOS tests run isolated from the network, making them more dependable.\n\nType: package\n\nDeclared by:\n\nnixos/lib/testing/run.nix\ntestScript\n\nA series of python declarations and statements that you write to perform the test.\n\nType: string or function that evaluates to a(n) string\n\nDeclared by:\n\nnixos/lib/testing/testScript.nix\nRunning Tests \n\nYou can run tests using nix-build. For example, to run the test login.nix, you do:\n\n$ cd /my/git/clone/of/nixpkgs\n$ nix-build -A nixosTests.login\n\n\nAfter building/downloading all required dependencies, this will perform a build that starts a QEMU/KVM virtual machine containing a NixOS system. The virtual machine mounts the Nix store of the host; this makes VM creation very fast, as no disk image needs to be created. Afterwards, you can view a log of the test:\n\n$ nix-store --read-log result\n\nRunning Tests interactively \n\nThe test itself can be run interactively. This is particularly useful when developing or debugging a test:\n\n$ nix-build . -A nixosTests.login.driverInteractive\n$ ./result/bin/nixos-test-driver\n[...]\n>>>\n\n\nYou can then take any Python statement, e.g.\n\n>>> start_all()\n>>> test_script()\n>>> machine.succeed(\"touch /tmp/foo\")\n>>> print(machine.succeed(\"pwd\")) # Show stdout of command\n\n\nThe function test_script executes the entire test script and drops you back into the test driver command line upon its completion. This allows you to inspect the state of the VMs after the test (e.g. to debug the test script).\n\nShell access in interactive mode \n\nThe function <yourmachine>.shell_interact() grants access to a shell running inside a virtual machine. To use it, replace <yourmachine> with the name of a virtual machine defined in the test, for example: machine.shell_interact(). Keep in mind that this shell may not display everything correctly as it is running within an interactive Python REPL, and logging output from the virtual machine may overwrite input and output from the guest shell:\n\n>>> machine.shell_interact()\nmachine: Terminal is ready (there is no initial prompt):\n$ hostname\nmachine\n\n\nAs an alternative, you can proxy the guest shell to a local TCP server by first starting a TCP server in a terminal using the command:\n\n$ socat 'READLINE,PROMPT=$ ' tcp-listen:4444,reuseaddr`\n\n\nIn the terminal where the test driver is running, connect to this server by using:\n\n>>> machine.shell_interact(\"tcp:127.0.0.1:4444\")\n\n\nOnce the connection is established, you can enter commands in the socat terminal where socat is running.\n\nPort forwarding to NixOS test VMs \n\nIf your test has only a single VM, you may use e.g.\n\n$ QEMU_NET_OPTS=\"hostfwd=tcp:127.0.0.1:2222-:22\" ./result/bin/nixos-test-driver\n\n\nto port-forward a port in the VM (here 22) to the host machine (here port 2222).\n\nThis naturally does not work when multiple machines are involved, since a single port on the host cannot forward to multiple VMs.\n\nIf the test defines multiple machines, you may opt to temporarily set virtualisation.forwardPorts in the test definition for debugging.\n\nSuch port forwardings connect via the VM’s virtual network interface. Thus they cannot connect to ports that are only bound to the VM’s loopback interface (127.0.0.1), and the VM’s NixOS firewall must be configured to allow these connections.\n\nReuse VM state \n\nYou can re-use the VM states coming from a previous run by setting the --keep-vm-state flag.\n\n$ ./result/bin/nixos-test-driver --keep-vm-state\n\n\nThe machine state is stored in the $TMPDIR/vm-state-machinename directory.\n\nInteractive-only test configuration \n\nThe .driverInteractive attribute combines the regular test configuration with definitions from the interactive submodule. This gives you a more usable, graphical, but slightly different configuration.\n\nYou can add your own interactive-only test configuration by adding extra configuration to the interactive submodule.\n\nTo interactively run only the regular configuration, build the <test>.driver attribute instead, and call it with the flag result/bin/nixos-test-driver --interactive.\n\nLinking NixOS tests to packages \n\nYou can link NixOS module tests to the packages that they exercised, so that the tests can be run automatically during code review when the package gets changed. This is described in the nixpkgs manual.\n\nDeveloping the NixOS Test Driver \n\nTable of Contents\n\nTesting changes to the test framework\n\nThe NixOS test framework is a project of its own.\n\nIt consists of roughly the following components:\n\nnixos/lib/test-driver: The Python framework that sets up the test and runs the testScript\n\nnixos/lib/testing: The Nix code responsible for the wiring, written using the (NixOS) Module System.\n\nThese components are exposed publicly through:\n\nnixos/lib/default.nix: The public interface that exposes the nixos/lib/testing entrypoint.\n\nflake.nix: Exposes the lib.nixos, including the public test interface.\n\nBeyond the test driver itself, its integration into NixOS and Nixpkgs is important.\n\npkgs/top-level/all-packages.nix: Defines the nixosTests attribute, used by the package tests attributes and OfBorg.\n\nnixos/release.nix: Defines the tests attribute built by Hydra, independently, but analogous to nixosTests\n\nnixos/release-combined.nix: Defines which tests are channel blockers.\n\nFinally, we have legacy entrypoints that users should move away from, but are cared for on a best effort basis. These include pkgs.nixosTest, testing-python.nix and make-test-python.nix.\n\nTesting changes to the test framework \n\nWe currently have limited unit tests for the framework itself. You may run these with nix-build -A nixosTests.nixos-test-driver.\n\nWhen making significant changes to the test framework, we run the tests on Hydra, to avoid disrupting the larger NixOS project.\n\nFor this, we use the python-test-refactoring branch in the NixOS/nixpkgs repository, and its corresponding Hydra jobset. This branch is used as a pointer, and not as a feature branch.\n\nRebase the PR onto a recent, good evaluation of nixos-unstable\n\nCreate a baseline evaluation by force-pushing this revision of nixos-unstable to python-test-refactoring.\n\nNote the evaluation number (we’ll call it <previous>)\n\nPush the PR to python-test-refactoring and evaluate the PR on Hydra\n\nCreate a comparison URL by navigating to the latest build of the PR and adding to the URL ?compare=<previous>. This is not necessary for the evaluation that comes right after the baseline.\n\nReview the removed tests and newly failed tests using the constructed URL; otherwise you will accidentally compare iterations of the PR instead of changes to the PR base.\n\nAs we currently have some flaky tests, newly failing tests are expected, but should be reviewed to make sure that\n\nThe number of failures did not increase significantly.\n\nAll failures that do occur can reasonably be assumed to fail for a different reason than the changes.\n\nTesting the Installer \n\nBuilding, burning, and booting from an installation CD is rather tedious, so here is a quick way to see if the installer works properly:\n\n# mount -t tmpfs none /mnt\n# nixos-generate-config --root /mnt\n$ nix-build '<nixpkgs/nixos>' -A config.system.build.nixos-install\n# ./result/bin/nixos-install\n\n\nTo start a login shell in the new NixOS installation in /mnt:\n\n$ nix-build '<nixpkgs/nixos>' -A config.system.build.nixos-enter\n# ./result/bin/nixos-enter\n\nContributing to this manual \n\nTable of Contents\n\nContributing to the configuration.nix options documentation\nContributing to nixos-* tools’ manpages\n\nThe [DocBook] and CommonMark sources of the NixOS manual are in the nixos/doc/manual subdirectory of the Nixpkgs repository. This manual uses the Nixpkgs manual syntax.\n\nYou can quickly check your edits with the following:\n\n$ cd /path/to/nixpkgs\n$ $EDITOR doc/nixos/manual/... # edit the manual\n$ nix-build nixos/release.nix -A manual.x86_64-linux\n\n\nIf the build succeeds, the manual will be in ./result/share/doc/nixos/index.html.\n\nThere’s also a convenient development daemon.\n\nThe above instructions don’t deal with the appendix of available configuration.nix options, and the manual pages related to NixOS. These are built, and written in a different location and in a different format, as explained in the next sections.\n\nContributing to the configuration.nix options documentation \n\nThe documentation for all the different configuration.nix options is automatically generated by reading the descriptions of all the NixOS options defined at nixos/modules/. If you want to improve such description, find it in the nixos/modules/ directory, and edit it and open a pull request.\n\nTo see how your changes render on the web, run again:\n\n$ nix-build nixos/release.nix -A manual.x86_64-linux\n\n\nAnd you’ll see the changes to the appendix in the path result/share/doc/nixos/options.html.\n\nYou can also build only the configuration.nix(5) manual page, via:\n\n$ cd /path/to/nixpkgs\n$ nix-build nixos/release.nix -A nixos-configuration-reference-manpage.x86_64-linux\n\n\nAnd observe the result via:\n\n$ man --local-file result/share/man/man5/configuration.nix.5\n\n\nIf you’re on a different architecture that’s supported by NixOS (check file nixos/release.nix on Nixpkgs’ repository) then replace x86_64-linux with the architecture. nix-build will complain otherwise, but should also tell you which architecture you have + the supported ones.\n\nContributing to nixos-* tools’ manpages \n\nThe manual pages for the tools available in the installation image can be found in Nixpkgs by running (e.g for nixos-rebuild):\n\n$ git ls | grep nixos-rebuild.8\n\n\nMan pages are written in mdoc(7) format and should be portable between mandoc and groff for rendering (except for minor differences, notably different spacing rules.)\n\nFor a preview, run man --local-file path/to/file.8.\n\nBeing written in mdoc, these manpages use semantic markup. This following subsections provides a guideline on where to apply which semantic elements.\n\nCommand lines and arguments \n\nIn any manpage, commands, flags and arguments to the current executable should be marked according to their semantics. Commands, flags and arguments passed to other executables should not be marked like this and should instead be considered as code examples and marked with Ql.\n\nUse Fl to mark flag arguments, Ar for their arguments.\n\nRepeating arguments should be marked by adding an ellipsis (spelled with periods, ...).\n\nUse Cm to mark literal string arguments, e.g. the boot command argument passed to nixos-rebuild.\n\nOptional flags or arguments should be marked with Op. This includes optional repeating arguments.\n\nRequired flags or arguments should not be marked.\n\nMutually exclusive groups of arguments should be enclosed in curly brackets, preferably created with Bro/Brc blocks.\n\nWhen an argument is used in an example it should be marked up with Ar again to differentiate it from a constant. For example, a command with a --host name option that calls ssh to retrieve the host’s local time would signify this thusly:\n\nThis will run\n.Ic ssh Ar name Ic time\nto retrieve the remote time.\n\nPaths, NixOS options, environment variables \n\nConstant paths should be marked with Pa, NixOS options with Va, and environment variables with Ev.\n\nGenerated paths, e.g. result/bin/run-hostname-vm (where hostname is a variable or arguments) should be marked as Ql inline literals with their variable components marked appropriately.\n\nWhen hostname refers to an argument, it becomes .Ql result/bin/run- Ns Ar hostname Ns -vm\n\nWhen hostname refers to a variable, it becomes .Ql result/bin/run- Ns Va hostname Ns -vm\n\nCode examples and other commands \n\nIn free text names and complete invocations of other commands (e.g. ssh or tar -xvf src.tar) should be marked with Ic, fragments of command lines should be marked with Ql.\n\nLarger code blocks or those that cannot be shown inline should use indented literal display block markup for their contents, i.e.\n\n.Bd -literal -offset indent\n...\n.Ed\n\n\nContents of code blocks may be marked up further, e.g. if they refer to arguments that will be substituted into them:\n\n.Bd -literal -offset indent\n{\n  config.networking.hostname = \"\\c\n.Ar hostname Ns \\c\n\";\n}\n.Ed\n"
  }
]