[
  {
    "title": "Home Manager Manual",
    "url": "https://nix-community.github.io/home-manager/index.html",
    "html": "Home Manager Manual\nPreface\n1. Installing Home Manager\n1.1. Standalone installation\n1.2. NixOS module\n1.3. nix-darwin module\n2. Using Home Manager\n2.1. Configuration Example\n2.2. Rollbacks\n2.3. Keeping your ~ safe from harm\n2.4. Graphical services\n2.5. Updating\n3. Nix Flakes\n3.1. Prerequisites\n3.2. Standalone setup\n3.3. NixOS module\n3.4. nix-darwin module\n4. Writing Home Manager Modules\n4.1. Option Types\n5. Contributing\n5.1. Getting started\n5.2. Guidelines\n5.2.1. Maintain backward compatibility\n5.2.2. Keep forward compatibility in mind\n5.2.3. Add only valuable options\n5.2.4. Add relevant tests\n5.2.5. Add relevant documentation\n5.2.6. Add yourself as a module maintainer\n5.2.7. Format your code\n5.2.8. Format your commit messages\n5.2.9. Format your news entries\n5.2.10. Use conditional modules and news\n5.2.11. Mind the license\n5.3. Commits\n5.4. Code Style\n5.5. News\n5.6. Tests\n6. Third-Party Tools and Extensions\n6.1. Module Collections\n7. Frequently Asked Questions (FAQ)\n7.1. Why is there a collision error when switching generation?\n7.2. Why are the session variables not set?\n7.3. How to set up a configuration for multiple users/machines?\n7.4. Why do I get an error message about ca.desrt.dconf or dconf.service?\n7.5. How do I install packages from Nixpkgs unstable?\n7.6. How do I override the package used by a module?\nA. Configuration Options\nB. NixOS Module Options\nC. nix-darwin Module Options\nD. Tools\nhome-manager — reconfigure a user environment\nE. Release Notes\nE.1. Release 23.11\nE.1.1. Highlights\nE.1.2. State Version Changes\nE.2. Release 23.05\nE.2.1. Highlights\nE.2.2. State Version Changes\nE.3. Release 22.11\nE.3.1. Highlights\nE.3.2. State Version Changes\nE.4. Release 22.05\nE.4.1. Highlights\nE.4.2. State Version Changes\nE.5. Release 21.11\nE.5.1. Highlights\nE.5.2. State Version Changes\nE.6. Release 21.05\nE.6.1. Highlights\nE.6.2. State Version Changes\nE.7. Release 20.09\nE.7.1. Highlights\nE.7.2. State Version Changes\nE.8. Release 20.03\nE.8.1. Highlights\nE.8.2. State Version Changes\nE.9. Release 19.09\nE.9.1. Highlights\nE.9.2. State Version Changes\nE.10. Release 19.03\nE.10.1. Highlights\nE.10.2. State Version Changes\nE.11. Release 18.09\nPreface\n\nThis manual will eventually describe how to install, use, and extend Home Manager.\n\nIf you encounter problems then please reach out on the IRC channel #home-manager hosted by OFTC. There is also a Matrix room, which is bridged to the IRC channel. If your problem is caused by a bug in Home Manager then it should be reported on the Home Manager issue tracker.\n\nCommands prefixed with $ sudo have to be run as root, either requiring to login as root user or temporarily switching to it using sudo for example.\n\nChapter 1. Installing Home Manager\n\nHome Manager can be used in three primary ways:\n\nUsing the standalone home-manager tool. For platforms other than NixOS and Darwin, this is the only available choice. It is also recommended for people on NixOS or Darwin that want to manage their home directory independently of the system as a whole. See Section 1.1, “Standalone installation” for instructions on how to perform this installation.\nAs a module within a NixOS system configuration. This allows the user profiles to be built together with the system when running nixos-rebuild. See Section 1.2, “NixOS module” for a description of this setup.\nAs a module within a nix-darwin system configuration. This allows the user profiles to be built together with the system when running darwin-rebuild. See Section 1.3, “nix-darwin module” for a description of this setup.\n\nIn this chapter we describe how to install Home Manager in the standard way using channels. If you prefer to use Nix Flakes then please see the instructions in Chapter 3, Nix Flakes.\n\n1.1. Standalone installation\nMake sure you have a working Nix installation. Specifically, make sure that your user is able to build and install Nix packages. For example, you should be able to successfully run a command like nix-instantiate '<nixpkgs>' -A hello without having to switch to the root user. For a multi-user install of Nix this means that your user must be covered by the allowed-users Nix option. On NixOS you can control this option using the nix.settings.allowed-users system option.\n\nAdd the appropriate Home Manager channel. If you are following Nixpkgs master or an unstable channel you can run\n\n$ nix-channel --add https://github.com/nix-community/home-manager/archive/master.tar.gz home-manager\n$ nix-channel --update\n\nand if you follow a Nixpkgs version 23.05 channel you can run\n\n$ nix-channel --add https://github.com/nix-community/home-manager/archive/release-23.05.tar.gz home-manager\n$ nix-channel --update\n\nRun the Home Manager installation command and create the first Home Manager generation:\n\n$ nix-shell '<home-manager>' -A install\n\nOnce finished, Home Manager should be active and available in your user environment.\n\nIf you do not plan on having Home Manager manage your shell configuration then you must source the\n\n$HOME/.nix-profile/etc/profile.d/hm-session-vars.sh\n\nfile in your shell configuration. Alternatively source\n\n/etc/profiles/per-user/$USER/etc/profile.d/hm-session-vars.sh\n\nwhen managing home configuration together with system configuration.\n\nThis file can be sourced directly by POSIX.2-like shells such as Bash or Z shell. Fish users can use utilities such as foreign-env or babelfish.\n\nFor example, if you use Bash then add\n\n. \"$HOME/.nix-profile/etc/profile.d/hm-session-vars.sh\"\n\nto your ~/.profile file.\n\nIf instead of using channels you want to run Home Manager from a Git checkout of the repository then you can use the programs.home-manager.path option to specify the absolute path to the repository.\n\nOnce installed you can see Chapter 2, Using Home Manager for a more detailed description of Home Manager and how to use it.\n\n1.2. NixOS module\n\nHome Manager provides a NixOS module that allows you to prepare user environments directly from the system configuration file, which often is more convenient than using the home-manager tool. It also opens up additional possibilities, for example, to automatically configure user environments in NixOS declarative containers or on systems deployed through NixOps.\n\nTo make the NixOS module available for use you must import it into your system configuration. This is most conveniently done by adding a Home Manager channel to the root user. For example, if you are following Nixpkgs master or an unstable channel, you can run\n\n$ sudo nix-channel --add https://github.com/nix-community/home-manager/archive/master.tar.gz home-manager\n$ sudo nix-channel --update\n\nand if you follow a Nixpkgs version 23.05 channel, you can run\n\n$ sudo nix-channel --add https://github.com/nix-community/home-manager/archive/release-23.05.tar.gz home-manager\n$ sudo nix-channel --update\n\nIt is then possible to add\n\nimports = [ <home-manager/nixos> ];\n\nto your system configuration.nix file, which will introduce a new NixOS option called home-manager.users whose type is an attribute set that maps user names to Home Manager configurations.\n\nFor example, a NixOS configuration may include the lines\n\nusers.users.eve.isNormalUser = true;\nhome-manager.users.eve = { pkgs, ... }: {\n  home.packages = [ pkgs.atool pkgs.httpie ];\n  programs.bash.enable = true;\n\n  # The state version is required and should stay at the version you\n  # originally installed.\n  home.stateVersion = \"23.05\";\n};\n\nand after a sudo nixos-rebuild switch the user eve’s environment should include a basic Bash configuration and the packages atool and httpie.\n\nIf nixos-rebuild switch does not result in the environment you expect, you can take a look at the output of the Home Manager activation script output using\n\n$ systemctl status \"home-manager-$USER.service\"\n\nIf you do not plan on having Home Manager manage your shell configuration then you must add either\n\n. \"$HOME/.nix-profile/etc/profile.d/hm-session-vars.sh\"\n\nor\n\n. \"/etc/profiles/per-user/$USER/etc/profile.d/hm-session-vars.sh\"\n\nto your shell configuration, depending on whether home-manager.useUserPackages is enabled. This file can be sourced directly by POSIX.2-like shells such as Bash or Z shell. Fish users can use utilities such as foreign-env or babelfish.\n\nBy default packages will be installed to $HOME/.nix-profile but they can be installed to /etc/profiles if\n\nhome-manager.useUserPackages = true;\n\nis added to the system configuration. This is necessary if, for example, you wish to use nixos-rebuild build-vm. This option may become the default value in the future.\n\nBy default, Home Manager uses a private pkgs instance that is configured via the home-manager.users.<name>.nixpkgs options. To instead use the global pkgs that is configured via the system level nixpkgs options, set\n\nhome-manager.useGlobalPkgs = true;\n\nThis saves an extra Nixpkgs evaluation, adds consistency, and removes the dependency on NIX_PATH, which is otherwise used for importing Nixpkgs.\n\nHome Manager will pass osConfig as a module argument to any modules you create. This contains the system’s NixOS configuration.\n\n{ lib, pkgs, osConfig, ... }:\n\nOnce installed you can see Chapter 2, Using Home Manager for a more detailed description of Home Manager and how to use it.\n\n1.3. nix-darwin module\n\nHome Manager provides a module that allows you to prepare user environments directly from the nix-darwin configuration file, which often is more convenient than using the home-manager tool.\n\nTo make the NixOS module available for use you must import it into your system configuration. This is most conveniently done by adding a Home Manager channel. For example, if you are following Nixpkgs master or an unstable channel, you can run\n\n$ nix-channel --add https://github.com/nix-community/home-manager/archive/master.tar.gz home-manager\n$ nix-channel --update\n\nand if you follow a Nixpkgs version 23.05 channel, you can run\n\n$ nix-channel --add https://github.com/nix-community/home-manager/archive/release-23.05.tar.gz home-manager\n$ nix-channel --update\n\nIt is then possible to add\n\nimports = [ <home-manager/nix-darwin> ];\n\nto your nix-darwin configuration.nix file, which will introduce a new NixOS option called home-manager whose type is an attribute set that maps user names to Home Manager configurations.\n\nFor example, a nix-darwin configuration may include the lines\n\nusers.users.eve = {\n  name = \"eve\";\n  home = \"/Users/eve\";\n}\nhome-manager.users.eve = { pkgs, ... }: {\n  home.packages = [ pkgs.atool pkgs.httpie ];\n  programs.bash.enable = true;\n\n  # The state version is required and should stay at the version you\n  # originally installed.\n  home.stateVersion = \"23.05\";\n};\n\nand after a darwin-rebuild switch the user eve’s environment should include a basic Bash configuration and the packages atool and httpie.\n\nIf you do not plan on having Home Manager manage your shell configuration then you must add either\n\n. \"$HOME/.nix-profile/etc/profile.d/hm-session-vars.sh\"\n\nor\n\n. \"/etc/profiles/per-user/$USER/etc/profile.d/hm-session-vars.sh\"\n\nto your shell configuration, depending on whether home-manager.useUserPackages is enabled. This file can be sourced directly by POSIX.2-like shells such as Bash or Z shell. Fish users can use utilities such as foreign-env or babelfish.\n\nBy default user packages will not be ignored in favor of environment.systemPackages, but they will be installed to /etc/profiles/per-user/$USERNAME if\n\nhome-manager.useUserPackages = true;\n\nis added to the nix-darwin configuration. This option may become the default value in the future.\n\nBy default, Home Manager uses a private pkgs instance that is configured via the home-manager.users.<name>.nixpkgs options. To instead use the global pkgs that is configured via the system level nixpkgs options, set\n\nhome-manager.useGlobalPkgs = true;\n\nThis saves an extra Nixpkgs evaluation, adds consistency, and removes the dependency on NIX_PATH, which is otherwise used for importing Nixpkgs.\n\nHome Manager will pass osConfig as a module argument to any modules you create. This contains the system’s nix-darwin configuration.\n\n{ lib, pkgs, osConfig, ... }:\n\nOnce installed you can see Chapter 2, Using Home Manager for a more detailed description of Home Manager and how to use it.\n\nChapter 2. Using Home Manager\n\nYour use of Home Manager is centered around the configuration file, which is typically found at ~/.config/home-manager/home.nix in the standard installation or ~/.config/home-manager/flake.nix in a Nix flake based installation.\n\nThe default configuration used to be placed in ~/.config/nixpkgs¸ so you may see references to that elsewhere. The old directory still works but Home Manager will print a warning message when used.\n\nThis configuration file can be built and activated.\n\nBuilding a configuration produces a directory in the Nix store that contains all files and programs that should be available in your home directory and Nix user profile, respectively. The build step also checks that the configuration is valid and it will fail with an error if you, for example, assign a value to an option that does not exist or assign a value of the wrong type. Some modules also have custom assertions that perform more detailed, module specific, checks.\n\nConcretely, if your configuration contains\n\nprograms.emacs.enable = \"yes\";\n\nthen building it, for example using home-manager build, will result in an error message saying something like\n\n$ home-manager build\nerror: A definition for option `programs.emacs.enable' is not of type `boolean'. Definition values:\n- In `/home/jdoe/.config/home-manager/home.nix': \"yes\"\n(use '--show-trace' to show detailed location information)\n\nThe message indicates that you must provide a Boolean value for this option, that is, either true or false. The documentation of each option will state the expected type, for programs.emacs.enable you will see “Type: boolean”. You there also find information about the default value and a description of the option. You can find the complete option documentation in Appendix A, Configuration Options or directly in the terminal by running\n\nman home-configuration.nix\n\nOnce a configuration is successfully built, it can be activated. The activation performs the steps necessary to make the files, programs, and services available in your user environment. The home-manager switch command performs a combined build and activation.\n\n2.1. Configuration Example\n\nA fresh install of Home Manager will generate a minimal ~/.config/home-manager/home.nix file containing something like\n\n{ config, pkgs, ... }:\n\n{\n  # Home Manager needs a bit of information about you and the\n  # paths it should manage.\n  home.username = \"jdoe\";\n  home.homeDirectory = \"/home/jdoe\";\n\n  # This value determines the Home Manager release that your\n  # configuration is compatible with. This helps avoid breakage\n  # when a new Home Manager release introduces backwards\n  # incompatible changes.\n  #\n  # You can update Home Manager without changing this value. See\n  # the Home Manager release notes for a list of state version\n  # changes in each release.\n  home.stateVersion = \"23.05\";\n\n  # Let Home Manager install and manage itself.\n  programs.home-manager.enable = true;\n}\n\nYou can use this as a base for your further configurations.\n\nIf you are not very familiar with the Nix language and NixOS modules then it is encouraged to start with small and simple changes. As you learn you can gradually grow the configuration with confidence.\n\nAs an example, let us expand the initial configuration file to also install the htop and fortune packages, install Emacs with a few extra packages available, and enable the user gpg-agent service.\n\nTo satisfy the above setup we should elaborate the home.nix file as follows:\n\n{ config, pkgs, ... }:\n\n{\n  # Home Manager needs a bit of information about you and the\n  # paths it should manage.\n  home.username = \"jdoe\";\n  home.homeDirectory = \"/home/jdoe\";\n\n  # Packages that should be installed to the user profile.\n  home.packages = [                               \n    pkgs.htop\n    pkgs.fortune\n  ];\n\n  # This value determines the Home Manager release that your\n  # configuration is compatible with. This helps avoid breakage\n  # when a new Home Manager release introduces backwards\n  # incompatible changes.\n  #\n  # You can update Home Manager without changing this value. See\n  # the Home Manager release notes for a list of state version\n  # changes in each release.\n  home.stateVersion = \"23.05\";\n\n  # Let Home Manager install and manage itself.\n  programs.home-manager.enable = true;\n\n  programs.emacs = {                              \n    enable = true;\n    extraPackages = epkgs: [\n      epkgs.nix-mode\n      epkgs.magit\n    ];\n  };\n\n  services.gpg-agent = {                          \n    enable = true;\n    defaultCacheTtl = 1800;\n    enableSshSupport = true;\n  };\n}\n\n\t\n\nNixpkgs packages can be installed to the user profile using home.packages.\n\n\n\n\n\t\n\nThe option names of a program module typically start with programs.<package name>.\n\n\n\n\n\t\n\nSimilarly, for a service module, the names start with services.<package name>. Note in some cases a package has both programs and service options – Emacs is such an example.\n\nTo activate this configuration you can run\n\nhome-manager switch\n\nor if you are not feeling so lucky,\n\nhome-manager build\n\nwhich will create a result link to a directory containing an activation script and the generated home directory files.\n\n2.2. Rollbacks\n\nWhile the home-manager tool does not explicitly support rollbacks at the moment it is relatively easy to perform one manually. The steps to do so are\n\nRun home-manager generations to determine which generation you wish to rollback to:\n\n$ home-manager generations\n2018-01-04 11:56 : id 765 -> /nix/store/kahm1rxk77mnvd2l8pfvd4jkkffk5ijk-home-manager-generation\n2018-01-03 10:29 : id 764 -> /nix/store/2wsmsliqr5yynqkdyjzb1y57pr5q2lsj-home-manager-generation\n2018-01-01 12:21 : id 763 -> /nix/store/mv960kl9chn2lal5q8lnqdp1ygxngcd1-home-manager-generation\n2017-12-29 21:03 : id 762 -> /nix/store/6c0k1r03fxckql4vgqcn9ccb616ynb94-home-manager-generation\n2017-12-25 18:51 : id 761 -> /nix/store/czc5y6vi1rvnkfv83cs3rn84jarcgsgh-home-manager-generation\n…\n\nCopy the Nix store path of the generation you chose, e.g.,\n\n/nix/store/mv960kl9chn2lal5q8lnqdp1ygxngcd1-home-manager-generation\n\nfor generation 763.\n\nRun the activate script inside the copied store path:\n\n$ /nix/store/mv960kl9chn2lal5q8lnqdp1ygxngcd1-home-manager-generation/activate\nStarting home manager activation\n…\n2.3. Keeping your ~ safe from harm\n\nTo configure programs and services Home Manager must write various things to your home directory. To prevent overwriting any existing files when switching to a new generation, Home Manager will attempt to detect collisions between existing files and generated files. If any such collision is detected the activation will terminate before changing anything on your computer.\n\nFor example, suppose you have a wonderful, painstakingly created ~/.config/git/config and add\n\n{\n  # …\n\n  programs.git = {\n    enable = true;\n    userName = \"Jane Doe\";\n    userEmail = \"jane.doe@example.org\";\n  };\n\n  # …\n}\n\nto your configuration. Attempting to switch to the generation will then result in\n\n$ home-manager switch\n…\nActivating checkLinkTargets\nExisting file '/home/jdoe/.config/git/config' is in the way\nPlease move the above files and try again\n2.4. Graphical services\n\nHome Manager includes a number of services intended to run in a graphical session, for example xscreensaver and dunst. Unfortunately, such services will not be started automatically unless you let Home Manager start your X session. That is, you have something like\n\n{\n  # …\n\n  services.xserver.enable = true;\n\n  # …\n}\n\nin your system configuration and\n\n{\n  # …\n\n  xsession.enable = true;\n  xsession.windowManager.command = \"…\";\n\n  # …\n}\n\nin your Home Manager configuration.\n\n2.5. Updating\n\nIf you have installed Home Manager using the Nix channel method then updating Home Manager is done by first updating the channel. You can then switch to the updated Home Manager environment.\n\n$ nix-channel --update\n…\nunpacking channels...\n$ home-manager switch\nChapter 3. Nix Flakes\n\nHome Manager is compatible with Nix Flakes. But please be aware that the support it is still experimental and may change in backwards incompatible ways.\n\nJust like in the standard installation you can use the Home Manager flake in three ways:\n\nUsing the standalone home-manager tool. For platforms other than NixOS and Darwin, this is the only available choice. It is also recommended for people on NixOS or Darwin that want to manage their home directory independently of the system as a whole. See Section 3.2, “Standalone setup” for instructions on how to perform this installation.\nAs a module within a NixOS system configuration. This allows the user profiles to be built together with the system when running nixos-rebuild. See Section 3.3, “NixOS module” for a description of this setup.\nThis allows the user profiles to be built together with the system when running darwin-rebuild. See Section 3.4, “nix-darwin module” for a description of this setup.\n3.1. Prerequisites\nInstall Nix 2.4 or later, or have it in nix-shell.\n\nEnable experimental features nix-command and flakes.\n\nWhen using NixOS, add the following to your configuration.nix and rebuild your system.\n\nnix = {\n  package = pkgs.nixFlakes;\n  extraOptions = ''\n    experimental-features = nix-command flakes\n  '';\n};\n\nIf you are not using NixOS, add the following to nix.conf (located at ~/.config/nix/ or /etc/nix/nix.conf).\n\nexperimental-features = nix-command flakes\n\nYou may need to restart the Nix daemon with, for example, sudo systemctl restart nix-daemon.service.\n\nAlternatively, you can enable flakes on a per-command basis with the following additional flags to nix and home-manager:\n\n$ nix --extra-experimental-features \"nix-command flakes\" <sub-commands>\n$ home-manager --extra-experimental-features \"nix-command flakes\" <sub-commands>\n\nPrepare your Home Manager configuration (home.nix).\n\nUnlike the channel-based setup, home.nix will be evaluated when the flake is built, so it must be present before bootstrap of Home Manager from the flake. See Section 2.1, “Configuration Example” for introduction about writing a Home Manager configuration.\n\n3.2. Standalone setup\n\nTo prepare an initial Home Manager configuration for your logged in user, you can run the Home Manager init command directly from its flake.\n\nFor example, if you are using the unstable version of Nixpkgs or NixOS, then to generate and activate a basic configuration run the command\n\n$ nix run home-manager/master -- init --switch\n\nFor Nixpkgs or NixOS version 23.05 run\n\n$ nix run home-manager/release-23.05 -- init --switch\n\nThis will generate a flake.nix and a home.nix file in ~/.config/home-manager, creating the directory if it does not exist.\n\nIf you omit the --switch option then the activation will not happen. This is useful if you want to inspect and edit the configuration before activating it.\n\n$ nix run home-manager/$branch -- init\n$ # Edit files in ~/.config/home-manager\n$ nix run home-manager/$branch -- init --switch\n\nWhere $branch is one of master or release-23.05.\n\nAfter the initial activation has completed successfully then building and activating your flake-based configuration is as simple as\n\n$ home-manager switch\n\nIt is possible to override the default configuration directory, if you want. For example,\n\n$ nix run home-manager/$branch -- init --switch ~/hmconf\n$ # And after the initial activation.\n$ home-manager switch --flake ~/hmconf\n\nThe flake inputs are not automatically updated by Home Manager. You need to use the standard nix flake update command for that.\n\nIf you only want to update a single flake input, then the command nix flake lock --update-input <input> can be used.\n\nYou can also pass flake-related options such as --recreate-lock-file or --update-input <input> to home-manager when building or switching, and these options will be forwarded to nix build. See the NixOS Wiki page for details.\n\n3.3. NixOS module\n\nTo use Home Manager as a NixOS module, a bare-minimum flake.nix would be as follows:\n\n{\n  description = \"NixOS configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    home-manager.url = \"github:nix-community/home-manager\";\n    home-manager.inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  outputs = inputs@{ nixpkgs, home-manager, ... }: {\n    nixosConfigurations = {\n      hostname = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n        modules = [\n          ./configuration.nix\n          home-manager.nixosModules.home-manager\n          {\n            home-manager.useGlobalPkgs = true;\n            home-manager.useUserPackages = true;\n            home-manager.users.jdoe = import ./home.nix;\n\n            # Optionally, use home-manager.extraSpecialArgs to pass\n            # arguments to home.nix\n          }\n        ];\n      };\n    };\n  };\n}\n\nThe Home Manager configuration is then part of the NixOS configuration and is automatically rebuilt with the system when using the appropriate command for the system, such as nixos-rebuild switch --flake <flake-uri>.\n\nYou can use the above flake.nix as a template in /etc/nixos by\n\n$ nix flake new /etc/nixos -t github:nix-community/home-manager#nixos\n3.4. nix-darwin module\n\nThe flake-based setup of the Home Manager nix-darwin module is similar to that of NixOS. The flake.nix would be:\n\n{\n  description = \"Darwin configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    darwin.url = \"github:lnl7/nix-darwin\";\n    darwin.inputs.nixpkgs.follows = \"nixpkgs\";\n    home-manager.url = \"github:nix-community/home-manager\";\n    home-manager.inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  outputs = inputs@{ nixpkgs, home-manager, darwin, ... }: {\n    darwinConfigurations = {\n      hostname = darwin.lib.darwinSystem {\n        system = \"x86_64-darwin\";\n        modules = [\n          ./configuration.nix\n          home-manager.darwinModules.home-manager\n          {\n            home-manager.useGlobalPkgs = true;\n            home-manager.useUserPackages = true;\n            home-manager.users.jdoe = import ./home.nix;\n\n            # Optionally, use home-manager.extraSpecialArgs to pass\n            # arguments to home.nix\n          }\n        ];\n      };\n    };\n  };\n}\n\nand it is also rebuilt with the nix-darwin generations. The rebuild command here may be darwin-rebuild switch --flake <flake-uri>.\n\nYou can use the above flake.nix as a template in ~/.config/darwin by\n\n$ nix flake new ~/.config/darwin -t github:nix-community/home-manager#nix-darwin\nChapter 4. Writing Home Manager Modules\n\nThe module system in Home Manager is based entirely on the NixOS module system so we will here only highlight aspects that are specific for Home Manager. For information about the module system as such please refer to the Writing NixOS Modules chapter of the NixOS manual.\n\n4.1. Option Types\n\nOverall the basic option types are the same in Home Manager as NixOS. A few Home Manager options, however, make use of custom types that are worth describing in more detail. These are the option types dagOf and gvariant that are used, for example, by programs.ssh.matchBlocks and dconf.settings.\n\nhm.types.dagOf\n\nOptions of this type have attribute sets as values where each member is a node in a directed acyclic graph (DAG). This allows the attribute set entries to express dependency relations among themselves. This can, for example, be used to control the order of match blocks in a OpenSSH client configuration or the order of activation script blocks in home.activation.\n\nA number of functions are provided to create DAG nodes. The functions are shown below with examples using an option foo.bar of type hm.types.dagOf types.int.\n\nhm.dag.entryAnywhere (value: T) : DagEntry<T>\n\nIndicates that value can be placed anywhere within the DAG. This is also the default for plain attribute set entries, that is\n\nfoo.bar = {\n  a = hm.dag.entryAnywhere 0;\n}\n\nand\n\nfoo.bar = {\n  a = 0;\n}\n\nare equivalent.\n\nhm.dag.entryAfter (afters: list string) (value: T) : DagEntry<T>\n\nIndicates that value must be placed after each of the attribute names in the given list. For example\n\nfoo.bar = {\n  a = 0;\n  b = hm.dag.entryAfter [ \"a\" ] 1;\n}\n\nwould place b after a in the graph.\n\nhm.dag.entryBefore (befores: list string) (value: T) : DagEntry<T>\n\nIndicates that value must be placed before each of the attribute names in the given list. For example\n\nfoo.bar = {\n  b = hm.dag.entryBefore [ \"a\" ] 1;\n  a = 0;\n}\n\nwould place b before a in the graph.\n\nhm.dag.entryBetween (befores: list string) (afters: list string) (value: T) : DagEntry<T>\n\nIndicates that value must be placed before the attribute names in the first list and after the attribute names in the second list. For example\n\nfoo.bar = {\n  a = 0;\n  c = hm.dag.entryBetween [ \"b\" ] [ \"a\" ] 2;\n  b = 1;\n}\n\nwould place c before b and after a in the graph.\n\nThere are also a set of functions that generate a DAG from a list. These are convenient when you just want to have a linear list of DAG entries, without having to manually enter the relationship between each entry. Each of these functions take a tag as argument and the DAG entries will be named ${tag}-${index}.\n\nhm.dag.entriesAnywhere (tag: string) (values: [T]) : Dag<T>\n\nCreates a DAG with the given values with each entry labeled using the given tag. For example\n\nfoo.bar = hm.dag.entriesAnywhere \"a\" [ 0 1 ];\n\nis equivalent to\n\nfoo.bar = {\n  a-0 = 0;\n  a-1 = hm.dag.entryAfter [ \"a-0\" ] 1;\n}\nhm.dag.entriesAfter (tag: string) (afters: list string) (values: [T]) : Dag<T>\n\nCreates a DAG with the given values with each entry labeled using the given tag. The list of values are placed are placed after each of the attribute names in afters. For example\n\nfoo.bar =\n  { b = 0; }\n  // hm.dag.entriesAfter \"a\" [ \"b\" ] [ 1 2 ];\n\nis equivalent to\n\nfoo.bar = {\n  b = 0;\n  a-0 = hm.dag.entryAfter [ \"b\" ] 1;\n  a-1 = hm.dag.entryAfter [ \"a-0\" ] 2;\n}\nhm.dag.entriesBefore (tag: string) (befores: list string) (values: [T]) : Dag<T>\n\nCreates a DAG with the given values with each entry labeled using the given tag. The list of values are placed before each of the attribute names in befores. For example\n\nfoo.bar =\n  { b = 0; }\n  // hm.dag.entriesBefore \"a\" [ \"b\" ] [ 1 2 ];\n\nis equivalent to\n\nfoo.bar = {\n  b = 0;\n  a-0 = 1;\n  a-1 = hm.dag.entryBetween [ \"b\" ] [ \"a-0\" ] 2;\n}\nhm.dag.entriesBetween (tag: string) (befores: list string) (afters: list string) (values: [T]) : Dag<T>\n\nCreates a DAG with the given values with each entry labeled using the given tag. The list of values are placed before each of the attribute names in befores and after each of the attribute names in afters. For example\n\nfoo.bar =\n  { b = 0; c = 3; }\n  // hm.dag.entriesBetween \"a\" [ \"b\" ] [ \"c\" ] [ 1 2 ];\n\nis equivalent to\n\nfoo.bar = {\n  b = 0;\n  c = 3;\n  a-0 = hm.dag.entryAfter [ \"c\" ] 1;\n  a-1 = hm.dag.entryBetween [ \"b\" ] [ \"a-0\" ] 2;\n}\nhm.types.gvariant\n\nThis type is useful for options representing GVariant values. The type accepts all primitive GVariant types as well as arrays, tuples, “maybe” types, and dictionaries.\n\nSome Nix values are automatically coerced to matching GVariant value but the GVariant model is richer so you may need to use one of the provided constructor functions. Examples assume an option foo.bar of type hm.types.gvariant.\n\nhm.gvariant.mkBoolean (v: bool)\n\nTakes a Nix value v to a GVariant boolean value (GVariant format string b). Note, Nix booleans are automatically coerced using this function. That is,\n\nfoo.bar = hm.gvariant.mkBoolean true;\n\nis equivalent to\n\nfoo.bar = true;\nhm.gvariant.mkString (v: string)\n\nTakes a Nix value v to a GVariant string value (GVariant format string s). Note, Nix strings are automatically coerced using this function. That is,\n\nfoo.bar = hm.gvariant.mkString \"a string\";\n\nis equivalent to\n\nfoo.bar = \"a string\";\nhm.gvariant.mkObjectpath (v: string)\nTakes a Nix value v to a GVariant objectpath value (GVariant format string o).\nhm.gvariant.mkUchar (v: string)\nTakes a Nix value v to a GVariant uchar value (GVariant format string y).\nhm.gvariant.mkInt16 (v: int)\nTakes a Nix value v to a GVariant int16 value (GVariant format string n).\nhm.gvariant.mkUint16 (v: int)\nTakes a Nix value v to a GVariant uint16 value (GVariant format string q).\nhm.gvariant.mkInt32 (v: int)\n\nTakes a Nix value v to a GVariant int32 value (GVariant format string i). Note, Nix integers are automatically coerced using this function. That is,\n\nfoo.bar = hm.gvariant.mkInt32 7;\n\nis equivalent to\n\nfoo.bar = 7;\nhm.gvariant.mkUint32 (v: int)\nTakes a Nix value v to a GVariant uint32 value (GVariant format string u).\nhm.gvariant.mkInt64 (v: int)\nTakes a Nix value v to a GVariant int64 value (GVariant format string x).\nhm.gvariant.mkUint64 (v: int)\nTakes a Nix value v to a GVariant uint64 value (GVariant format string t).\nhm.gvariant.mkDouble (v: double)\n\nTakes a Nix value v to a GVariant double value (GVariant format string d). Note, Nix floats are automatically coerced using this function. That is,\n\nfoo.bar = hm.gvariant.mkDouble 3.14;\n\nis equivalent to\n\nfoo.bar = 3.14;\nhm.gvariant.mkArray type elements\n\nBuilds a GVariant array containing the given list of elements, where each element is a GVariant value of the given type (GVariant format string a${type}). The type value can be constructed using\n\nhm.gvariant.type.string (GVariant format string s)\nhm.gvariant.type.boolean (GVariant format string b)\nhm.gvariant.type.uchar (GVariant format string y)\nhm.gvariant.type.int16 (GVariant format string n)\nhm.gvariant.type.uint16 (GVariant format string q)\nhm.gvariant.type.int32 (GVariant format string i)\nhm.gvariant.type.uint32 (GVariant format string u)\nhm.gvariant.type.int64 (GVariant format string x)\nhm.gvariant.type.uint64 (GVariant format string t)\nhm.gvariant.type.double (GVariant format string d)\nhm.gvariant.type.variant (GVariant format string v)\nhm.gvariant.type.arrayOf type (GVariant format string a${type})\nhm.gvariant.type.maybeOf type (GVariant format string m${type})\nhm.gvariant.type.tupleOf types (GVariant format string (${lib.concatStrings types}))\nhm.gvariant.type.dictionaryEntryOf [keyType valueType] (GVariant format string {${keyType}${valueType}})\n\nwhere type and types are themselves a type and list of types, respectively.\n\nhm.gvariant.mkEmptyArray type\nAn alias of hm.gvariant.mkArray type [].\nhm.gvariant.mkNothing type\nBuilds a GVariant maybe value (GVariant format string m${type}) whose (non-existent) element is of the given type. The type value is constructed as described for the mkArray function above.\nhm.gvariant.mkJust element\nBuilds a GVariant maybe value (GVariant format string m${element.type}) containing the given GVariant element.\nhm.gvariant.mkTuple elements\nBuilds a GVariant tuple containing the given list of elements, where each element is a GVariant value.\nhm.gvariant.mkVariant element\nBuilds a GVariant variant (GVariant format string v) which contains the value of a GVariant element.\nhm.gvariant.mkDictionaryEntry [key value]\nBuilds a GVariant dictionary entry containing the given list of elements (GVariant format string {${key.type}${value.type}}), where each element is a GVariant value.\nChapter 5. Contributing\n\nContributions to Home Manager are very welcome. To make the process as smooth as possible for both you and the Home Manager maintainers we provide some guidelines that we ask you to follow. See Section 5.1, “Getting started” for information on how to set up a suitable development environment and Section 5.2, “Guidelines” for the actual guidelines.\n\nThis text is mainly directed at those who would like to make code contributions to Home Manager. If you just want to report a bug then first look among the already open issues, if you find one matching yours then feel free to comment on it to add any additional information you may have. If no matching issue exists then go to the new issue page and write a description of your problem. Include as much information as you can, ideally also include relevant excerpts from your Home Manager configuration.\n\n5.1. Getting started\n\nIf you have not previously forked Home Manager then you need to do that first. Have a look at GitHub’s Fork a repo for instructions on how to do this.\n\nOnce you have a fork of Home Manager you should create a branch starting at the most recent master branch. Give your branch a reasonably descriptive name. Commit your changes to this branch and when you are happy with the result and it fulfills Section 5.2, “Guidelines” then push the branch to GitHub and create a pull request.\n\nAssuming your clone is at $HOME/devel/home-manager then you can make the home-manager command use it by either\n\noverriding the default path by using the -I command line option:\n\n$ home-manager -I home-manager=$HOME/devel/home-manager\n\nor, if using flakes:\n\n$ home-manager --override-input home-manager ~/devel/home-manager\n\nor\n\nchanging the default path by ensuring your configuration includes\n\nprograms.home-manager.enable = true;\nprograms.home-manager.path = \"$HOME/devel/home-manager\";\n\nand running home-manager switch to activate the change. Afterwards, home-manager build and home-manager switch will use your cloned repository.\n\nThe first option is good if you only temporarily want to use your clone.\n\n5.2. Guidelines\n\nIf your contribution satisfy the following rules then there is a good chance it will be merged without too much trouble. The rules are enforced by the Home Manager maintainers and to a lesser extent the Home Manager CI system.\n\nIf you are uncertain how these rules affect the change you would like to make then feel free to start a discussion in the #home-manager IRC channel, ideally before you start developing.\n\n5.2.1. Maintain backward compatibility\n\nYour contribution should not cause another user’s existing configuration to break unless there is a very good reason and the change should be announced to the user through an assertion or similar.\n\nRemember that Home Manager is used in many different environments and you should consider how your change may effect others. For example,\n\nDoes your change work for people that do not use NixOS? Consider other GNU/Linux distributions and macOS.\nDoes your change work for people whose configuration is built on one system and deployed on another system?\n5.2.2. Keep forward compatibility in mind\n\nThe master branch of Home Manager tracks the unstable channel of Nixpkgs, which may update package versions at any time. It is therefore important to consider how a package update may affect your code and try to reduce the risk of breakage.\n\nThe most effective way to reduce this risk is to follow the advice in Section 5.2.3, “Add only valuable options”.\n\n5.2.3. Add only valuable options\n\nWhen creating a new module it is tempting to include every option supported by the software. This is strongly discouraged. Providing many options increases maintenance burden and risk of breakage considerably. This is why only the most important software options should be modeled explicitly. Less important options should be expressible through an extraConfig escape hatch.\n\nA good rule of thumb for the first implementation of a module is to only add explicit options for those settings that absolutely must be set for the software to function correctly. It follows that a module for software that provides sensible default values for all settings would require no explicit options at all.\n\nIf the software uses a structured configuration format like a JSON, YAML, INI, TOML, or even a plain list of key/value pairs then consider using a settings option as described in Nix RFC 42.\n\n5.2.4. Add relevant tests\n\nIf at all possible, make sure to add new tests and expand existing tests so that your change will keep working in the future. See Section 5.6, “Tests” for more information about the Home Manager test suite.\n\nAll contributed code must pass the test suite.\n\n5.2.5. Add relevant documentation\n\nMany code changes require changing the documentation as well. Module options should be documented with Nixpkgs-flavoured Markdown. Home Manager is itself documented using a combination of DocBook and AsciiDoc. All text is hosted in Home Manager’s Git repository.\n\nThe HTML version of the manual containing both the module option descriptions and the documentation of Home Manager can be generated and opened by typing the following in a shell within a clone of the Home Manager Git repository:\n\n$ nix-build -A docs.html\n$ xdg-open ./result/share/doc/home-manager/index.html\n\nWhen you have made changes to a module, it is a good idea to check that the man page version of the module options looks good:\n\n$ nix-build -A docs.manPages\n$ man ./result/share/man/man5/home-configuration.nix.5.gz\n5.2.6. Add yourself as a module maintainer\n\nEvery new module must include a named maintainer using the meta.maintainers attribute. If you are a user of a module that currently lacks a maintainer then please consider adopting it.\n\nIf you are present in the nixpkgs maintainer list then you can use that entry. If you are not then you can add yourself to modules/lib/maintainers.nix in the Home Manager project.\n\nMaintainers are encouraged to join the IRC or Matrix channel and participate when they have opportunity.\n\n5.2.7. Format your code\n\nMake sure your code is formatted as described in Section 5.4, “Code Style”. To maintain consistency throughout the project you are encouraged to browse through existing code and adopt its style also in new code.\n\n5.2.8. Format your commit messages\n\nSimilar to Section 5.2.7, “Format your code” we encourage a consistent commit message format as described in Section 5.3, “Commits”.\n\n5.2.9. Format your news entries\n\nIf your contribution includes a change that should be communicated to users of Home Manager then you can add a news entry. The entry must be formatted as described in Section 5.5, “News”.\n\nWhen new modules are added a news entry should be included but you do not need to create this entry manually. The merging maintainer will create the entry for you. This is to reduce the risk of merge conflicts.\n\n5.2.10. Use conditional modules and news\n\nHome Manager includes a number of modules that are only usable on some of the supported platforms. The most common example of platform specific modules are those that define systemd user services, which only works on Linux systems.\n\nIf you add a module that is platform specific then make sure to include a condition in the loadModule function call. This will make the module accessible only on systems where the condition evaluates to true.\n\nSimilarly, if you are adding a news entry then it should be shown only to users that may find it relevant, see Section 5.5, “News” for a description of conditional news.\n\n5.2.11. Mind the license\n\nThe Home Manager project is covered by the MIT license and we can only accept contributions that fall under this license, or are licensed in a compatible way. When you contribute self written code and documentation it is assumed that you are doing so under the MIT license.\n\nA potential gotcha with respect to licensing are option descriptions. Often it is convenient to copy from the upstream software documentation. When this is done it is important to verify that the license of the upstream documentation allows redistribution under the terms of the MIT license.\n\n5.3. Commits\n\nThe commits in your pull request should be reasonably self-contained, that is, each commit should make sense in isolation. In particular, you will be asked to amend any commit that introduces syntax errors or similar problems even if they are fixed in a later commit.\n\nThe commit messages should follow the seven rules, except for \"Capitalize the subject line\". We also ask you to include the affected code component or module in the first line. That is, a commit message should follow the template\n\n{component}: {description}\n\n{long description}\n\nwhere {component} refers to the code component (or module) your change affects, {description} is a very brief description of your change, and {long description} is an optional clarifying description. As a rare exception, if there is no clear component, or your change affects many components, then the {component} part is optional. See Example 5.1, “Compliant commit message” for a commit message that fulfills these requirements.\n\nExample 5.1. Compliant commit message\n\nThe commit 69f8e47e9e74c8d3d060ca22e18246b7f7d988ef contains the commit message\n\nstarship: allow running in Emacs if vterm is used\n\nThe vterm buffer is backed by libvterm and can handle Starship prompts\nwithout issues.\n\nwhich ticks all the boxes necessary to be accepted in Home Manager.\n\n\n\n\nFinally, when adding a new module, say programs/foo.nix, we use the fixed commit format foo: add module. You can, of course, still include a long description if you wish.\n\n5.4. Code Style\n\nThe code in Home Manager is formatted by the nixfmt tool and the formatting is checked in the pull request tests. Run the format tool inside the project repository before submitting your pull request.\n\nKeep lines at a reasonable width, ideally 80 characters or less. This also applies to string literals.\n\nWe prefer lowerCamelCase for variable and attribute names with the accepted exception of variables directly referencing packages in Nixpkgs which use a hyphenated style. For example, the Home Manager option services.gpg-agent.enableSshSupport references the gpg-agent package in Nixpkgs.\n\n5.5. News\n\nHome Manager includes a system for presenting news to the user. When making a change you, therefore, have the option to also include an associated news entry. In general, a news entry should only be added for truly noteworthy news. For example, a bug fix or new option does generally not need a news entry.\n\nIf you do have a change worthy of a news entry then please add one in news.nix but you should follow some basic guidelines:\n\nThe entry timestamp should be in ISO-8601 format having \"+00:00\" as time zone. For example, \"2017-09-13T17:10:14+00:00\". A suitable timestamp can be produced by the command\n\n$ date --iso-8601=second --universal\nThe entry condition should be as specific as possible. For example, if you are changing or deprecating a specific option then you could restrict the news to those users who actually use this option.\nWrap the news message so that it will fit in the typical terminal, that is, at most 80 characters wide. Ideally a bit less.\nUnlike commit messages, news will be read without any connection to the Home Manager source code. It is therefore important to make the message understandable in isolation and to those who do not have knowledge of the Home Manager internals. To this end it should be written in more descriptive, prose like way.\n\nIf you refer to an option then write its full attribute path. That is, instead of writing\n\nThe option 'foo' has been deprecated, please use 'bar' instead.\n\nit should read\n\nThe option 'services.myservice.foo' has been deprecated, please\nuse 'services.myservice.bar' instead.\n\nA new module, say foo.nix, should always include a news entry that has a message along the lines of\n\nA new module is available: 'services.foo'.\n\nIf the module is platform specific, e.g., a service module using systemd, then a condition like\n\ncondition = hostPlatform.isLinux;\n\nshould be added. If you contribute a module then you don’t need to add this entry, the merger will create an entry for you.\n\n5.6. Tests\n\nHome Manager includes a basic test suite and it is highly recommended to include at least one test when adding a module. Tests are typically in the form of \"golden tests\" where, for example, a generated configuration file is compared to a known correct file.\n\nIt is relatively easy to create tests by modeling the existing tests, found in the tests project directory. For a full reference to the functions available in test scripts, you can look at NMT’s bash-lib.\n\nThe full Home Manager test suite can be run by executing\n\n$ nix-shell --pure tests -A run.all\n\nin the project root. List all test cases through\n\n$ nix-shell --pure tests -A list\n\nand run an individual test, for example alacritty-empty-settings, through\n\n$ nix-shell --pure tests -A run.alacritty-empty-settings\n\nHowever, those invocations will impurely source the system’s nixpkgs, and may cause failures. To run against the nixpkgs from the flake.lock, use instead e.g.\n\n$ nix develop --ignore-environment .#all\nChapter 6. Third-Party Tools and Extensions\n\nHere is a collection of tools and extensions that relate to Home Manager. Note, these are maintained outside the regular Home Manager flow so quality and support may vary wildly. If you encounter problems then please raise them in the corresponding project, not as issues in the Home Manager tracker.\n\nIf you have made something interesting related to Home Manager then you are encouraged to create a PR that expands this chapter.\n\n6.1. Module Collections\n\nxhmm — extra Home Manager modules\n\nA collection of modules maintained by Anselm Schüler.\n\nStylix — System-wide colorscheming and typography\n\nConfigure your applications to get coherent color scheme and font.\n\nChapter 7. Frequently Asked Questions (FAQ)\n7.1. Why is there a collision error when switching generation?\n\nHome Manager currently installs packages into the user environment, precisely as if the packages were installed through nix-env --install. This means that you will get a collision error if your Home Manager configuration attempts to install a package that you already have installed manually, that is, packages that shows up when you run nix-env --query.\n\nFor example, imagine you have the hello package installed in your environment\n\n$ nix-env --query\nhello-2.10\n\nand your Home Manager configuration contains\n\nhome.packages = [ pkgs.hello ];\n\nThen attempting to switch to this configuration will result in an error similar to\n\n$ home-manager switch\nthese derivations will be built:\n  /nix/store/xg69wsnd1rp8xgs9qfsjal017nf0ldhm-home-manager-path.drv\n[…]\nActivating installPackages\nreplacing old ‘home-manager-path’\ninstalling ‘home-manager-path’\nbuilding path(s) ‘/nix/store/b5c0asjz9f06l52l9812w6k39ifr49jj-user-environment’\nWide character in die at /nix/store/64jc9gd2rkbgdb4yjx3nrgc91bpjj5ky-buildenv.pl line 79.\ncollision between ‘/nix/store/fmwa4axzghz11cnln5absh31nbhs9lq1-home-manager-path/bin/hello’ and ‘/nix/store/c2wyl8b9p4afivpcz8jplc9kis8rj36d-hello-2.10/bin/hello’; use ‘nix-env --set-flag priority NUMBER PKGNAME’ to change the priority of one of the conflicting packages\nbuilder for ‘/nix/store/b37x3s7pzxbasfqhaca5dqbf3pjjw0ip-user-environment.drv’ failed with exit code 2\nerror: build of ‘/nix/store/b37x3s7pzxbasfqhaca5dqbf3pjjw0ip-user-environment.drv’ failed\n\nThe solution is typically to uninstall the package from the environment using nix-env --uninstall and reattempt the Home Manager generation switch.\n\nYou could also opt to unistall all of the packages from your profile with nix-env --uninstall '*'.\n\n7.2. Why are the session variables not set?\n\nHome Manager is only able to set session variables automatically if it manages your Bash, Z shell, or fish shell configuration. To enable such management you use programs.bash.enable, programs.zsh.enable, or programs.fish.enable.\n\nIf you don’t want to let Home Manager manage your shell then you will have to manually source the ~/.nix-profile/etc/profile.d/hm-session-vars.sh file in an appropriate way. In Bash and Z shell this can be done by adding\n\n. \"$HOME/.nix-profile/etc/profile.d/hm-session-vars.sh\"\n\nto your .profile and .zshrc files, respectively. The hm-session-vars.sh file should work in most Bourne-like shells. For fish shell, it is possible to source it using the foreign-env plugin\n\nfenv source \"$HOME/.nix-profile/etc/profile.d/hm-session-vars.sh\" > /dev/null\n7.3. How to set up a configuration for multiple users/machines?\n\nA typical way to prepare a repository of configurations for multiple logins and machines is to prepare one \"top-level\" file for each unique combination.\n\nFor example, if you have two machines, called \"kronos\" and \"rhea\" on which you want to configure your user \"jane\" then you could create the files\n\nkronos-jane.nix,\nrhea-jane.nix, and\ncommon.nix\n\nin your repository. On the kronos and rhea machines you can then make ~jane/.config/home-manager/home.nix be a symbolic link to the corresponding file in your configuration repository.\n\nThe kronos-jane.nix and rhea-jane.nix files follow the format\n\n{ ... }:\n\n{\n  imports = [ ./common.nix ];\n\n  # Various options that are specific for this machine/user.\n}\n\nwhile the common.nix file contains configuration shared across the two logins. Of course, instead of just a single common.nix file you can have multiple ones, even one per program or service.\n\nYou can get some inspiration from the Post your home-manager home.nix file! Reddit thread.\n\n7.4. Why do I get an error message about ca.desrt.dconf or dconf.service?\n\nYou are most likely trying to configure something that uses dconf but the DBus session is not aware of the dconf service. The full error you might get is\n\nerror: GDBus.Error:org.freedesktop.DBus.Error.ServiceUnknown: The name ca.desrt.dconf was not provided by any .service files\n\nor\n\nerror: GDBus.Error:org.freedesktop.systemd1.NoSuchUnit: Unit dconf.service not found.\n\nThe solution on NixOS is to add\n\nprograms.dconf.enable = true;\n\nto your system configuration.\n\n7.5. How do I install packages from Nixpkgs unstable?\n\nIf you are using a stable version of Nixpkgs but would like to install some particular packages from Nixpkgs unstable – or some other channel – then you can import the unstable Nixpkgs and refer to its packages within your configuration. Something like\n\n{ pkgs, config, ... }:\n\nlet\n\n  pkgsUnstable = import <nixpkgs-unstable> {};\n\nin\n\n{\n  home.packages = [\n    pkgsUnstable.foo\n  ];\n\n  # …\n}\n\nshould work provided you have a Nix channel called nixpkgs-unstable.\n\nYou can add the nixpkgs-unstable channel by running\n\n$ nix-channel --add https://nixos.org/channels/nixpkgs-unstable nixpkgs-unstable\n$ nix-channel --update\n\nNote, the package will not be affected by any package overrides, overlays, etc.\n\n7.6. How do I override the package used by a module?\n\nBy default Home Manager will install the package provided by your chosen nixpkgs channel but occasionally you might end up needing to change this package. This can typically be done in two ways.\n\nIf the module provides a package option, such as programs.beets.package, then this is the recommended way to perform the override. For example,\n\nprograms.beets.package = pkgs.beets.override { enableCheck = true; };\n\nIf no package option is available then you can typically override the relevant package using an overlay.\n\nFor example, if you want to use the programs.skim module but use the skim package from Nixpkgs unstable, then a configuration like\n\n{ pkgs, config, ... }:\n\nlet\n\n  pkgsUnstable = import <nixpkgs-unstable> {};\n\nin\n\n{\n  programs.skim.enable = true;\n\n  nixpkgs.overlays = [\n    (self: super: {\n      skim = pkgsUnstable.skim;\n    })\n  ];\n\n  # …\n}\n\nshould work OK."
  }
]