[
  {
    "title": "常见问题 FAQ | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/faq/",
    "html": "常见问题 FAQ\n​\nNixOS 的回滚能力与 btrfs / zfs 系统快照回滚有何不同？\n​\n\n很多使用 Arch Linux / Ubuntu 等常规 Linux 发行版的用户，习惯于使用 btrfs / zfs 等文件系统提供的快照作为「后悔药」，这样系统出了问题能回滚修复。 而本书介绍的 NixOS 也提供了系统状态回滚能力，因此很容易会有这样的疑问：这两种系统回滚功能有何不同？\n\n这里简单解释下，主要区别在于，快照内容不包含如何从零构建这个快照的「知识」，是不可解释的，而且其内容与当前硬件环境强相关，很难在其他机器上复现。\n\n而 NixOS 的配置是一份从零构建出一个一模一样的 OS 的「知识」，是可解释的，而且可以通过简单几行命令就自动完成这个构建。NixOS 配置本身既是一份记录你的 NixOS 系统都做过哪些变更的文档，也可直接用于自动构建出你当前的 NixOS 系统。\n\nNixOS 的配置文件就像是程序的源代码，只要源代码没丢，修改程序、审查程序，或者重新构建出一个一模一样的程序都很简单。 而系统快照就像是源代码编译出来的二进制程序，要对它做修改、审查，都要难得多。而且这个快照很大，分享或者迁移它的成本都要比源代码高得多。\n\n但这并不是说有了 NixOS 就不需要系统快照了，本书第一章就介绍了 NixOS 只能保证在声明式配置中声明的所有内容都是可复现的，而其他未声明式配置覆盖到的系统状态是不受它管辖的。比如 MySQL/PostgreSQL 的动态数据、用户上传的文件、系统日志等等，用户 Home 目录下的视频、音乐、图片等等，这些内容都还是需要文件系统快照或者其他手段来备份。\n\nNix 与 Ansible 等传统的系统运维工具相比有何优劣？\n​\n\nNix 不仅可用于管理桌面电脑的环境，也有很多人用它批量管理云服务器，Nix 官方的 NixOps 与社区的 colmena 都是专为这个场景开发的工具。\n\nNix 与 Ansible 这类被广泛应用的传统工具比，主要优势就在：\n\nAnible 这类工具一个最大的问题就是，它每次部署都是基于系统当前状态的增量修改。而系统的当前状态就如同前面提到的系统快照，是不可解释的，也很难复现。而 NixOS 是通过配置文件声明系统的目标状态，可以做到部署结果与系统当前状态无关，重复部署也不会导致任何问题。\nNix Flakes 通过一个版本锁文件 flake.lock 锁定了所有依赖的 hash 值、版本号、数据源等信息，这极大地提升了系统的可复现能力。而传统的 Ansible 等工具没有此功能，所以它们的可复现能力很差。\n这也是为什么 Docker 这么受欢迎的原因——它以较低的代价提供了 Ansible 等传统运维工具提供不了的可在各种机器上复现的系统环境。\nNix 通过一层声明式的抽象屏蔽了其底层的实现细节，使用户只需要关心自己最核心的需求，从而带来了高度便捷的系统自定义能力。而 Ansible 这类工具的抽象能力要弱得多。\n如果你有使用过 terraform/kubernetes 等声明式配置工具，应该很容易理解这一点。需求越是复杂的情况下，声明式配置带来的好处就越大。\nNix 与 Docker 容器技术相比有何优势？\n​\n\nNix 与以 Docker 为代表的容器技术的应用场景也存在一定重合，比如说：\n\n有很多人用 Nix 来管理开发编译环境，本书就对此做过介绍。但另一方面也有像 Dev Containers 这种基于容器搭建开发环境的技术，而且非常流行。\n目前整个 DevOps/SRE 领域基本已经是基于 Dockerfile 的容器技术的天下，容器中常用 Ubuntu/Debian 等发行版，宿主机也同样有很多成熟的发行版可选，改用 NixOS 有什么明显的优势呢？\n\n其中第一点「管理开发编译环境」，Nix 创建的开发环境体验非常接近直接在宿主机进行开发，这要比 Dev Containers 好很多，举例如下：\n\nNix 不使用名字空间进行文件系统、网络环境等各方面的隔离，在 Nix 创建的开发环境中也可以很方便地与宿主机文件系统（包括 /dev 宿主机外接设备）、网络环境等等进行交互。而容器要通过各种映射才能宿主机文件系统互通，即使这样也可能会遇到一些文件权限问题。\n因为没做啥强隔离，Nix 开发环境对 GUI 程序的支持也没任何问题，在这个环境中跑个 GUI 程序的体验就跟在系统环境中跑个 GUI 程序没任何区别。\n\n也就是说，Nix 能提供最接近宿主机的开发体验，不存在什么强隔离，开发人员能在这个环境中使用各种熟悉的开发调试工具，过往的开发经验基本都能无痛迁移过来。 而如果使用 Dev Containers，那开发人员很可能会遭遇强隔离导致的各种文件系统不互通、网络环境问题、用户权限问题、无法使用 GUI 调试工具等等各种毛病。\n\n而如果我们决定了使用 Nix 来管理所有的开发环境，那么在构建 Docker 容器时也基于 Nix 去构建，显然能提供最强的一致性，同时所有环境都统一了技术架构，这也能明显降低整个基础设施的维护成本。 这就回答了前面提到的第二点，在使用 Nix 管理开发环境的前提下，容器基础镜像与云服务器都使用 NixOS 会存在明显的优势。"
  },
  {
    "title": "进阶玩法 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/advanced-topics/",
    "html": "进阶玩法\n​\n\n逐渐熟悉 Nix 这一套工具链后，可以进一步读一读 Nix 的三本手册以及其他社区文档，挖掘更多的玩法：\n\nNix Reference Manual: Nix 包管理器使用手册，主要包含 Nix 包管理器的设计、命令行使用说明。\nnixpkgs Manual: 主要介绍 Nixpkgs 的参数、Nix 包的使用、修改、打包方法。\nNixOS Manual: NixOS 系统使用手册，主要包含 Wayland/X11, GPU 等系统级别的配置说明。\nnix-pills: Nix Pills 对如何使用 Nix 构建软件包进行了深入的阐述，写得比官方文档清晰易懂，而且也足够深入，值得一读。\nnixos-in-production: 这是一本介绍如何在生产环境中使用 NixOS 的书籍，目前还在编写中，不过已经有了一些很棒的内容。\n\n在对 Nix Flakes 熟悉到一定程度后，你可以尝试一些 Flakes 的进阶玩法，如下是一些比较流行的社区项目，可以试用：\n\nflake-parts: 通过 Module 模块系统简化配置的编写与维护。\nflake-utils-plus:同样是用于简化 Flake 配置的第三方包，不过貌似更强大些\n[digga][https://github.com/divnix/digga]: 一个大而全的 Flake 模板，揉合了各种实用 Nix 工具包的功能，不过结构比较复杂，需要一定经验才能玩得转。\n......\n\n以及其他许多实用的社区项目可探索，我比较关注的有这几个：\n\nnixpak: 一个使用沙箱运行任何 Nix 应用程序的工具（包括 GUI 应用程序），提升系统安全性\nnix-output-monitor: 美化 nix build 命令的输出日志，同时打印出更详细的日志信息，以及构建计时器等额外信息，强烈推荐使用！\nagenix: secrets 管理工具\nnixos-generator: 镜像生成工具，从 nixos 配置生成 iso/qcow2 等格式的镜像\nlanzaboote: 启用 secure boot\nimpermanence: 用于配置无状态系统。可用它持久化你指定的文件或文件夹，同时再将 /home 目录挂载为 tmpfs 或者每次启动时用工具擦除一遍。这样所有不受 impermanence 管理的数据都将成为临时数据，如果它们导致了任何问题，重启下系统这些数据就全部还原到初始状态了！\ncolmena: NixOS 主机部署工具\ndevbox: 一个基于 Nix 的轻量级开发环境管理工具，类似 earthly，目标是统一开发环境与部署环境，使得开发环境与部署环境一致\nnixpacks: 一个将任何代码自动打包为 OCI 容器镜像的工具，类似 buildpacks\n...\n\n想了解更多内容，可以看看 awesome-nix.\n\n也可以加入中文社区的NixOS 讨论群参与讨论:\n\nTelegram: https://t.me/nixos_zhcn\nMatrix: https://matrix.to/#/#nixos_zhcn:matrix.org"
  },
  {
    "title": "Nix 语言入门 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/the-nix-language/",
    "html": "Nix 语言入门\n​\n\nNix 语言是 Nix 包管理器的基础，要想玩得转 NixOS 与 Nix Flakes，享受到它们带来的诸多好处，就必须学会这门语言。\n\nNix 是一门比较简单的函数式语言，在已有一定编程基础的情况下，过一遍这些语法用时应该在 2 个小时以内，本文假设你具有一定编程基础（也就是说写得不会很细）。\n\n先把语法过一遍，有个大概的印象就行，后面需要用到时再根据右侧目录回来复习。\n\n注：如下内容有选择地介绍了 Nix 语言的常用语法，仅适合新手快速入门，请阅读官方文档 Nix Language 了解 Nix 语言的完整语法！\n\n基础数据类型一览\n​\n\n下面通过一个 attribute set （这类似 json 或者其他语言中的 map/dict）来简要说明所有基础数据类型：\n\nnix\n{\n  string = \"hello\";\n  integer = 1;\n  float = 3.141;\n  bool = true;\n  null = null;\n  list = [ 1 \"two\" false ];\n  attribute-set = {\n    a = \"hello\";\n    b = 2;\n    c = 2.718;\n    d = false;\n  }; # comments are supported\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n以及一些基础操作符（普通的算术运算、布尔运算就跳过不介绍了）：\n\nnix\n# 列表拼接\n[ 1 2 3 ] ++ [ 4 5 6 ] # [ 1 2 3 4 5 6 ]\n\n# 将 // 后面的 attribut set 中的内容，全部更新到 // 前面的 attribute set 中\n{ a = 1; b = 2; } // { b = 3; c = 4; } # 结果为 { a = 1; b = 3; c = 4; }\n\n# 逻辑隐含，等同于 !b1 || b2.\nbool -> bool\n1\n2\n3\n4\n5\n6\n7\n8\n\nlet ... in ...\n​\n\nNix 的 let ... in ... 语法被称作「let 表达式」或者「let 绑定」，它用于创建临时使用的局部变量：\n\nnix\nlet\n  a = 1;\nin\na + a  # 结果是 2\n1\n2\n3\n4\n\n\nlet 表达式中的变量只能在 in 之后的表达式中使用，理解成临时变量就行。\n\nif...then...else...\n​\n\nif...then...else... 用于条件判断，它是一个有返回值的表达式，语法如下：\n\nnix\nif 3 > 4 then \"yes\" else \"no\" # 结果为 \"no\"\n1\n\n\n也可以与 let...in... 一起使用：\n\nnix\nlet\n  x = 3;\nin\n  if x > 4 then \"yes\" else \"no\" # 结果为 \"no\"\n1\n2\n3\n4\n\nattribute set 说明\n​\n\n花括号 {} 用于创建 attribute set，也就是 key-value 对的集合，类似于 JSON 中的对象。\n\nattribute set 默认不支持递归引用，如下内容会报错：\n\nnix\n{\n  a = 1;\n  b = a + 1; # error: undefined variable 'a'\n}\n1\n2\n3\n4\n\n\n不过 Nix 提供了 rec 关键字（recursive attribute set），可用于创建递归引用的 attribute set：\n\nnix\nrec {\n  a = 1;\n  b = a + 1; # ok\n}\n1\n2\n3\n4\n\n\n在递归引用的情况下，Nix 会按照声明的顺序进行求值，所以如果 a 在 b 之后声明，那么 b 会报错。\n\n可以使用 . 操作符来访问 attribute set 的成员：\n\nnix\nlet\n  a = {\n    b = {\n      c = 1;\n    };\n  };\nin\na.b.c # 结果是 1\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n. 操作符也可直接用于赋值：\n\nnix\n{ a.b.c = 1; }\n1\n\n\n此外 attribute set 还支持一个 has attribute 操作符，它可用于检测 attribute set 中是否包含某个属性，返回 bool 值：\n\nnix\nlet\n  a = {\n    b = {\n      c = 1;\n    };\n  };\nin\na?b  # 结果是 true，因为 a.b 这个属性确实存在\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nhas attribute 操作符在 nixpkgs 库中常被用于检测处理 args?system 等参数，以 (args?system) 或 (! args?system) 的形式作为函数参数使用（叹号表示对 bool 值取反，是常见 bool 值运算符）。\n\nwith 语句\n​\n\nwith 语句的语法如下：\n\nnix\nwith <attribute-set> ; <expression>\n1\n\n\nwith 语句会将 <attribute-set> 中的所有成员添加到当前作用域中，这样在 <expression> 中就可以直接使用 <attribute-set> 中的成员了，简化 attribute set 的访问语法，比如：\n\nnix\nlet\n  a = {\n    x = 1;\n    y = 2;\n    z = 3;\n  };\nin\nwith a; [ x y z ]  # 结果是 [ 1 2 3 ], 等价于 [ a.x a.y a.z ]\n1\n2\n3\n4\n5\n6\n7\n8\n\n继承 inherit ...\n​\n\ninherit 语句用于从 attribute set 中继承成员，同样是一个简化代码的语法糖，比如：\n\nnix\nlet\n  x = 1;\n  y = 2;\nin\n{\n  inherit x y;\n}  # 结果是 { x = 1; y = 2; }\n1\n2\n3\n4\n5\n6\n7\n\n\ninherit 还能直接从某个 attribute set 中继承成员，语法为 inherit (<attribute-set>) <member-name>;，比如：\n\nnix\nlet\n  a = {\n    x = 1;\n    y = 2;\n    z = 3;\n  };\nin\n{\n  inherit (a) x y;\n}  # 结果是 { x = 1; y = 2; }\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n${ ... } 字符串插值\n​\n\n${ ... } 用于字符串插值，懂点编程的应该都很容易理解这个，比如：\n\nnix\nlet\n  a = \"1\";\nin\n\"the value of a is ${a}\"  # 结果是 \"the value of a is 1\"\n1\n2\n3\n4\n\n文件系统路径\n​\n\nNix 中不带引号的字符串会被解析为文件系统路径，路径的语法与 Unix 系统相同。\n\n搜索路径\n​\n\n请不要使用这个功能，它会导致不可预期的行为。\n\nNix 会在看到 <nixpkgs> 这类三角括号语法时，会在 NIX_PATH 环境变量中指定的路径中搜索该路径。\n\n因为环境变量 NIX_PATH 是可变更的值，所以这个功能是不纯的，会导致不可预期的行为。\n\n在这里做个介绍，只是为了让你在看到别人使用类似的语法时不至于抓瞎。\n\n多行字符串\n​\n\n多行字符串的语法为 ''，比如：\n\nnix\n''\n  this is a\n  multi-line\n  string\n''\n1\n2\n3\n4\n5\n\n多行字符串的转义\n​\n\n在单行字符串中，Nix 的转义语法与许多其他语言相同，\" \\ ${ 以及其他 \\n \\t 等特殊字符，都可直接使用 \\ 进行转义，比如：\n\nnix\n\"this is a \\\"string\\\" \\\\\"  # 结果是: this is a \"string\" \\\n1\n\n\n但在多行字符串中，情况会有点特殊。Nix 规定在多行字符串中需要使用两个单引号 '' 来转义。\n\n比如如下表示输出原始字符 ${a}，而不是字符串插值：\n\nnix\nlet\n  a = \"1\";\nin\n''the value of a is:\n  ''${a}\n''  # 结果是 \"the value of a is ''${a}\"\n1\n2\n3\n4\n5\n6\n\n\n其他 \\n \\t 等特殊字符的转义也类似，必须使用两个单引号来转义，如\n\nnix\n''\n  this is a\n  multi-line\n  string\n  ''\\n\n''\n1\n2\n3\n4\n5\n6\n\n\n如果我们希望在字符串中使用原始字符 ''，则需要再为它添加一个 '，比如：\n\nnix\nlet\n  a = \"1\";\nin\n''the value of a is:\n  '''${a}'''\n''  # 结果是 \"the value of a is ''1''\"\n1\n2\n3\n4\n5\n6\n\n函数\n​\n\n函数的声明语法为：\n\nnix\n<arg1>:\n  <body>\n1\n2\n\n\n举几个常见的例子：\n\nnix\n# 单参数函数\na: a + a\n\n# 嵌套函数\na: b: a + b\n\n# 双参数函数\n{ a, b }: a + b\n\n# 双参数函数，带默认值。问号后面的是参数的默认值\n{ a ? 1, b ? 2 }: a + b\n\n# 带有命名 attribute set 作为参数的函数，并且使用 ... 收集其他可选参数\n# 命名 args 与 ... 可选参数通常被一起作为函数的参数定义使用\nargs@{ a, b, ... }: a + b + args.c\n# 如下内容等价于上面的内容,\n{ a, b, ... }@args: a + b + args.c\n\n# 但是要注意命名参数仅绑定了输入的 attribute set，默认参数不在其中，举例\nlet\n  f = { a ? 1, b ? 2, ... }@args: args;\nin\n  f {}  # 结果是 {}，说明默认参数不在 args 中\n\n# 函数的调用方式就是把参数放在后面，比如下面的 2 就是前面这个函数的参数\na: a + a 2  # 结果是 4\n\n# 还可以给函数命名，不过必须使用 let 表达式\nlet\n  f = a: a + a;\nin\n  f 2  # 结果是 4\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n内置函数\n​\n\nNix 内置了一些函数，可通过 builtins.<function-name> 来调用，比如：\n\nnix\nbuiltins.add 1 2  # 结果是 3\n1\n\n\n详细的内置函数列表参见 Built-in Functions - Nix Reference Mannual\n\nimport 表达式\n​\n\nimport 表达式以其他 Nix 文件的路径作为参数，返回该 Nix 文件的执行结果。\n\nimport 的参数如果为文件夹路径，那么会返回该文件夹下的 default.nix 文件的执行结果。\n\n举个例子，首先创建一个 file.nix 文件：\n\nshell\n$ echo \"x: x + 1\" > file.nix\n1\n\n\n然后使用 import 执行它：\n\nnix\nimport ./file.nix 1  # 结果是 2\n1\n\npkgs.lib 函数包\n​\n\n除了 builtins 之外，Nix 的 nixpkgs 仓库还提供了一个名为 lib 的 attribute set，它包含了一些常用的函数，它通常被以如下的形式被使用：\n\nnix\nlet\n  pkgs = import <nixpkgs> {};\nin\npkgs.lib.strings.toUpper \"search paths considered harmful\"  # 结果是 \"SEARCH PATHS CONSIDERED HARMFUL\"\n1\n2\n3\n4\n\n\n可以通过 Nixpkgs Library Functions - Nixpkgs Manual 查看 lib 函数包的详细内容。\n\n不纯（Impurities）\n​\n\nNix 语言本身是纯函数式的，是纯的，「纯」是指它就跟数学中的函数一样，同样的输入永远得到同样的输出。\n\nNix 有两种构建输入，一种是从文件系统路径等输入源中读取文件，另一种是将其他函数作为输入。\n\nNix 唯一的不纯之处在这里：从文件系统路径或者其他输入源中读取文件作为构建任务的输入，这些输入源参数可能没变化，但是文件内容或数据源的返回内容可能会变化，这就会导致输入相同，Nix 函数的输出却可能不同——函数变得不纯了。\n\nNix 中的搜索路径与 builtins.currentSystem 也是不纯的，但是这两个功能都不建议使用，所以这里略过了。\n\nFetchers\n​\n\n构建输入除了直接来自文件系统路径之外，还可以通过 Fetchers 来获取，Fetcher 是一种特殊的函数，它的输入是一个 attribute set，输出是 Nix Store 中的一个系统路径。\n\nNix 提供了四个内置的 Fetcher，分别是：\n\nbuiltins.fetchurl：从 url 中下载文件\nbuiltins.fetchTarball：从 url 中下载 tarball 文件\nbuiltins.fetchGit：从 git 仓库中下载文件\nbuiltins.fetchClosure：从 Nix Store 中获取 Derivation\n\n举例：\n\nnix\nbuiltins.fetchurl \"https://github.com/NixOS/nix/archive/7c3ab5751568a0bc63430b33a5169c5e4784a0ff.tar.gz\"\n# result example => \"/nix/store/7dhgs330clj36384akg86140fqkgh8zf-7c3ab5751568a0bc63430b33a5169c5e4784a0ff.tar.gz\"\n\nbuiltins.fetchTarball \"https://github.com/NixOS/nix/archive/7c3ab5751568a0bc63430b33a5169c5e4784a0ff.tar.gz\"\n# result example(auto unzip the tarball) => \"/nix/store/d59llm96vgis5fy231x6m7nrijs0ww36-source\"\n1\n2\n3\n4\n5\n\nDerivations\n​\n\n官方 Nixpkgs 包仓库中的软件包已经能满足绝大部分用户的使用，在学习 NixOS 的前期不太需要深入了解 Derivation 的使用细节，有个印象就行。 本书会在后面 Nix 软件打包入门 中详细介绍相关内容，这里仅做简要介绍。\n\nDerivation 描述了如何构建一个软件包，是一个软件包构建流程的 Nix 语言描述，它声明了构建时需要有哪些依赖项、需要什么构建工具链、要设置哪些环境变量、哪些构建参数、先干啥后干啥等等。\n\nDerivation 的构建结果是一个 Store Object，其中包含了软件包的所有二进制程序、配置文件等等内容。 Store Object 的存放路径格式为 /nix/store/<hash>-<name>，其中 <hash> 是构建结果的 hash 值，<name> 是它的名字。路径 hash 值确保了每个构建结果都是唯一的，因此可以多版本共存，而且不会出现依赖冲突的问题。\n\n/nix/store 是一个特殊的文件路径，它被称为 Store，存放所有的 Store Objects，这个路径被设置为只读，只有 Nix 本身才能修改这个路径下的内容，以保证系统的可复现性。\n\nDerivation 实质上只是一个 attribute set，Nix 底层会使用内置函数 builtins.derivation 将这个 attribute set 构建为一个 Store Object。 我们实际编写 Derivation 时，通常使用的是 stdenv.mkDerivation，它是前述内置函数 builtins.derivation 的 Nix 语言 wrapper，屏蔽了底层的细节，简化了用法。\n\n一个简单的 Derivation 如下，它声明了一个名为 hello 的应用程序（摘抄自 nixpkgs/pkgs/hello）：\n\nnix\n{ callPackage\n, lib\n, stdenv\n, fetchurl\n, nixos\n, testers\n, hello\n}:\n\nstdenv.mkDerivation (finalAttrs: {\n  pname = \"hello\";\n  version = \"2.12.1\";\n\n  src = fetchurl {\n    url = \"mirror://gnu/hello/hello-${finalAttrs.version}.tar.gz\";\n    sha256 = \"sha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=\";\n  };\n\n  doCheck = true;\n\n  passthru.tests = {\n    version = testers.testVersion { package = hello; };\n\n    invariant-under-noXlibs =\n      testers.testEqualDerivation\n        \"hello must not be rebuilt when environment.noXlibs is set.\"\n        hello\n        (nixos { environment.noXlibs = true; }).pkgs.hello;\n  };\n\n  passthru.tests.run = callPackage ./test.nix { hello = finalAttrs.finalPackage; };\n\n  meta = with lib; {\n    description = \"A program that produces a familiar, friendly greeting\";\n    longDescription = ''\n      GNU Hello is a program that prints \"Hello, world!\" when you run it.\n      It is fully customizable.\n    '';\n    homepage = \"https://www.gnu.org/software/hello/manual/\";\n    changelog = \"https://git.savannah.gnu.org/cgit/hello.git/plain/NEWS?h=v${finalAttrs.version}\";\n    license = licenses.gpl3Plus;\n    maintainers = [ maintainers.eelco ];\n    platforms = platforms.all;\n  };\n})\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n参考\n​\nNix language basics - nix.dev"
  },
  {
    "title": "Advanced Topics | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/advanced-topics/#VPContent",
    "html": "Advanced Topics\n​\n\nOnce you have become familiar with NixOS, you can explore advanced topics and dive deeper into the Nix ecosystem. Here are some resources and community projects that can help you expand your knowledge:\n\nDocumentation\n​\nNix Reference Manual: A comprehensive guide to the Nix package manager, covering its design and usage from the command line.\nnixpkgs Manual: The manual for nixpkgs, which introduces its parameters, explains how to use, modify, and package Nix packages.\nNixOS Manual: A user manual for NixOS, providing configuration instructions for system-level components such as Wayland/X11 and GPU.\nnix-pills: \"Nix Pills\" is a series of guides that provide an in-depth explanation of building software packages with Nix. It offers clear and understandable explanations.\nnixos-in-production: This is a work-in-progress book hosted on LeanPub about introducing and maintaining NixOS in a production environment.\nAdvanced Techniques and Community Projects\n​\n\nOnce you are comfortable with Flakes, you can explore more advanced techniques and community projects. Here are some popular ones to try out:\n\nflake-parts: Simplifies the writing and maintenance of configurations using the Module module system.\nflake-utils-plus: A third-party package that enhances Flake configuration and provides additional powerful features.\ndigga: A comprehensive Flake template that combines functionality from various useful Nix toolkits. Note that it has a complex structure and may require some experience to navigate.\n\nThere are many other valuable community projects worth exploring. Here are a few examples:\n\nnixpak: A tool to sandbox all sorts of Nix-packaged applications, including graphical ones.\nnix-output-monitor: Beautifully displays the build progress of Nix packages, with additional information such as build time and build log.\nagenix: A tool for secrets management.\ncolmena: Tools for NixOS deployment.\nnixos-generators: A tool to generate ISO/qcow2/... from NixOS configurations.\nlanzaboote: Enables secure boot for NixOS.\nimpermanence: Helps make NixOS stateless and improves system reproducibility.\ndevbox: Lightweight, repeatable dev environments without container woes, internally powered by nix, similar to earthly.\nnixpacks: Nixpacks takes a source directory and produces an OCI compliant image that can be deployed anywhere, similar to buildpacks.\n...\n\nThese projects offer additional functionality and tools that can enhance your NixOS experience.\n\nFor more information, see the awesome-nix."
  },
  {
    "title": "Basics of the Nix Language | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/the-nix-language/#VPContent",
    "html": "Basics of the Nix Language\n​\n\nThe Nix language is essential for declaring configurations to be built by Nix. To fully enjoy the benefits of NixOS and Flakes, it is necessary to grasp the fundamentals of this language.\n\nThe Nix language is a straightforward functional language. If you have some programming experience, it should take you less than 2 hours to grasp its basics.\n\nTo get started, I recommend reading the following resources for a solid introduction to the Nix language:\n\nNix Language Basics - nix.dev: This tutorial provides a comprehensive overview of the basics of the Nix language.\nNix - A One Pager: A one page introduction to the Nix language.\nYou can safely skip the section on callPackage/Overriding/Overlays for now. We will cover it in the next chapter.\nNix Language: The official documentation of the Nix language.\nnix.dev & nix-1p are suitable for starter reading only, and neither of them fully introduces the full syntax of Nix. If you encounter a new syntax that you have not come across before, please refer to this official document.\n\nBy going through these materials, you will develop a solid foundation in the Nix language, allowing you to effectively utilize NixOS and Flakes."
  },
  {
    "title": "进阶玩法 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/advanced-topics/",
    "html": "进阶玩法\n​\n\n逐渐熟悉 Nix 这一套工具链后，可以进一步读一读 Nix 的三本手册以及其他社区文档，挖掘更多的玩法：\n\nNix Reference Manual: Nix 包管理器使用手册，主要包含 Nix 包管理器的设计、命令行使用说明。\nnixpkgs Manual: 主要介绍 Nixpkgs 的参数、Nix 包的使用、修改、打包方法。\nNixOS Manual: NixOS 系统使用手册，主要包含 Wayland/X11, GPU 等系统级别的配置说明。\nnix-pills: Nix Pills 对如何使用 Nix 构建软件包进行了深入的阐述，写得比官方文档清晰易懂，而且也足够深入，值得一读。\nnixos-in-production: 这是一本介绍如何在生产环境中使用 NixOS 的书籍，目前还在编写中，不过已经有了一些很棒的内容。\n\n在对 Nix Flakes 熟悉到一定程度后，你可以尝试一些 Flakes 的进阶玩法，如下是一些比较流行的社区项目，可以试用：\n\nflake-parts: 通过 Module 模块系统简化配置的编写与维护。\nflake-utils-plus:同样是用于简化 Flake 配置的第三方包，不过貌似更强大些\n[digga][https://github.com/divnix/digga]: 一个大而全的 Flake 模板，揉合了各种实用 Nix 工具包的功能，不过结构比较复杂，需要一定经验才能玩得转。\n......\n\n以及其他许多实用的社区项目可探索，我比较关注的有这几个：\n\nnixpak: 一个使用沙箱运行任何 Nix 应用程序的工具（包括 GUI 应用程序），提升系统安全性\nnix-output-monitor: 美化 nix build 命令的输出日志，同时打印出更详细的日志信息，以及构建计时器等额外信息，强烈推荐使用！\nagenix: secrets 管理工具\nnixos-generator: 镜像生成工具，从 nixos 配置生成 iso/qcow2 等格式的镜像\nlanzaboote: 启用 secure boot\nimpermanence: 用于配置无状态系统。可用它持久化你指定的文件或文件夹，同时再将 /home 目录挂载为 tmpfs 或者每次启动时用工具擦除一遍。这样所有不受 impermanence 管理的数据都将成为临时数据，如果它们导致了任何问题，重启下系统这些数据就全部还原到初始状态了！\ncolmena: NixOS 主机部署工具\ndevbox: 一个基于 Nix 的轻量级开发环境管理工具，类似 earthly，目标是统一开发环境与部署环境，使得开发环境与部署环境一致\nnixpacks: 一个将任何代码自动打包为 OCI 容器镜像的工具，类似 buildpacks\n...\n\n想了解更多内容，可以看看 awesome-nix.\n\n也可以加入中文社区的NixOS 讨论群参与讨论:\n\nTelegram: https://t.me/nixos_zhcn\nMatrix: https://matrix.to/#/#nixos_zhcn:matrix.org"
  },
  {
    "title": "常见问题 FAQ | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/faq",
    "html": "常见问题 FAQ\n​\nNixOS 的回滚能力与 btrfs / zfs 系统快照回滚有何不同？\n​\n\n很多使用 Arch Linux / Ubuntu 等常规 Linux 发行版的用户，习惯于使用 btrfs / zfs 等文件系统提供的快照作为「后悔药」，这样系统出了问题能回滚修复。 而本书介绍的 NixOS 也提供了系统状态回滚能力，因此很容易会有这样的疑问：这两种系统回滚功能有何不同？\n\n这里简单解释下，主要区别在于，快照内容不包含如何从零构建这个快照的「知识」，是不可解释的，而且其内容与当前硬件环境强相关，很难在其他机器上复现。\n\n而 NixOS 的配置是一份从零构建出一个一模一样的 OS 的「知识」，是可解释的，而且可以通过简单几行命令就自动完成这个构建。NixOS 配置本身既是一份记录你的 NixOS 系统都做过哪些变更的文档，也可直接用于自动构建出你当前的 NixOS 系统。\n\nNixOS 的配置文件就像是程序的源代码，只要源代码没丢，修改程序、审查程序，或者重新构建出一个一模一样的程序都很简单。 而系统快照就像是源代码编译出来的二进制程序，要对它做修改、审查，都要难得多。而且这个快照很大，分享或者迁移它的成本都要比源代码高得多。\n\n但这并不是说有了 NixOS 就不需要系统快照了，本书第一章就介绍了 NixOS 只能保证在声明式配置中声明的所有内容都是可复现的，而其他未声明式配置覆盖到的系统状态是不受它管辖的。比如 MySQL/PostgreSQL 的动态数据、用户上传的文件、系统日志等等，用户 Home 目录下的视频、音乐、图片等等，这些内容都还是需要文件系统快照或者其他手段来备份。\n\nNix 与 Ansible 等传统的系统运维工具相比有何优劣？\n​\n\nNix 不仅可用于管理桌面电脑的环境，也有很多人用它批量管理云服务器，Nix 官方的 NixOps 与社区的 colmena 都是专为这个场景开发的工具。\n\nNix 与 Ansible 这类被广泛应用的传统工具比，主要优势就在：\n\nAnible 这类工具一个最大的问题就是，它每次部署都是基于系统当前状态的增量修改。而系统的当前状态就如同前面提到的系统快照，是不可解释的，也很难复现。而 NixOS 是通过配置文件声明系统的目标状态，可以做到部署结果与系统当前状态无关，重复部署也不会导致任何问题。\nNix Flakes 通过一个版本锁文件 flake.lock 锁定了所有依赖的 hash 值、版本号、数据源等信息，这极大地提升了系统的可复现能力。而传统的 Ansible 等工具没有此功能，所以它们的可复现能力很差。\n这也是为什么 Docker 这么受欢迎的原因——它以较低的代价提供了 Ansible 等传统运维工具提供不了的可在各种机器上复现的系统环境。\nNix 通过一层声明式的抽象屏蔽了其底层的实现细节，使用户只需要关心自己最核心的需求，从而带来了高度便捷的系统自定义能力。而 Ansible 这类工具的抽象能力要弱得多。\n如果你有使用过 terraform/kubernetes 等声明式配置工具，应该很容易理解这一点。需求越是复杂的情况下，声明式配置带来的好处就越大。\nNix 与 Docker 容器技术相比有何优势？\n​\n\nNix 与以 Docker 为代表的容器技术的应用场景也存在一定重合，比如说：\n\n有很多人用 Nix 来管理开发编译环境，本书就对此做过介绍。但另一方面也有像 Dev Containers 这种基于容器搭建开发环境的技术，而且非常流行。\n目前整个 DevOps/SRE 领域基本已经是基于 Dockerfile 的容器技术的天下，容器中常用 Ubuntu/Debian 等发行版，宿主机也同样有很多成熟的发行版可选，改用 NixOS 有什么明显的优势呢？\n\n其中第一点「管理开发编译环境」，Nix 创建的开发环境体验非常接近直接在宿主机进行开发，这要比 Dev Containers 好很多，举例如下：\n\nNix 不使用名字空间进行文件系统、网络环境等各方面的隔离，在 Nix 创建的开发环境中也可以很方便地与宿主机文件系统（包括 /dev 宿主机外接设备）、网络环境等等进行交互。而容器要通过各种映射才能宿主机文件系统互通，即使这样也可能会遇到一些文件权限问题。\n因为没做啥强隔离，Nix 开发环境对 GUI 程序的支持也没任何问题，在这个环境中跑个 GUI 程序的体验就跟在系统环境中跑个 GUI 程序没任何区别。\n\n也就是说，Nix 能提供最接近宿主机的开发体验，不存在什么强隔离，开发人员能在这个环境中使用各种熟悉的开发调试工具，过往的开发经验基本都能无痛迁移过来。 而如果使用 Dev Containers，那开发人员很可能会遭遇强隔离导致的各种文件系统不互通、网络环境问题、用户权限问题、无法使用 GUI 调试工具等等各种毛病。\n\n而如果我们决定了使用 Nix 来管理所有的开发环境，那么在构建 Docker 容器时也基于 Nix 去构建，显然能提供最强的一致性，同时所有环境都统一了技术架构，这也能明显降低整个基础设施的维护成本。 这就回答了前面提到的第二点，在使用 Nix 管理开发环境的前提下，容器基础镜像与云服务器都使用 NixOS 会存在明显的优势。"
  },
  {
    "title": "Kernel Development | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/development/kernel-development",
    "html": "Kernel Development\n​\n\nWIP 本文还有待完善\n\n一个我 licheepi4a 官方内核开发调试环境的 flake.nix 如下\n\nnix\n{\n  description = \"NixOS running on LicheePi 4A\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-23.05-small\";\n\n    # custom kernel's source\n    thead-kernel = {\n      url = \"github:revyos/thead-kernel/lpi4a\";\n      flake = false;\n    };\n  };\n\n  outputs = inputs@{\n    self\n    ,nixpkgs\n    ,thead-kernel\n    ,... }:\n  let\n    pkgsKernel = import nixpkgs {\n      localSystem = \"x86_64-linux\";\n      crossSystem = {\n        config = \"riscv64-unknown-linux-gnu\";\n      };\n\n      overlays = [\n        (self: super: {\n          # use gcc 13 to compile this custom kernel\n          linuxPackages_thead = super.linuxPackagesFor (super.callPackage ./pkgs/kernel {\n            src = thead-kernel;\n            stdenv = super.gcc13Stdenv;\n            kernelPatches = with super.kernelPatches; [\n              bridge_stp_helper\n              request_key_helper\n            ];\n          });\n        })\n      ];\n    };\n  in\n  {\n    nixosConfigurations.lp4a = nixpkgs.lib.nixosSystem {\n      system = \"x86_64-linux\";\n\n      specialArgs = {\n        inherit nixpkgs pkgsKernel;\n      };\n      modules = [\n        {\n          # cross-compile this flake.\n          nixpkgs.crossSystem = {\n            system = \"riscv64-linux\";\n          };\n        }\n\n        ./modules/licheepi4a.nix\n        ./modules/sd-image-lp4a.nix\n      ];\n    };\n\n    # use `nix develop .#kernel` to enter the environment with the custom kernel build environment available.\n    # and then use `unpackPhase` to unpack the kernel source code and cd into it.\n    # then you can use `make menuconfig` to configure the kernel.\n    #\n    # problem\n    #   - using `make menuconfig` - Unable to find the ncurses package.\n    devShells.x86_64-linux.kernel = pkgsKernel.linuxPackages_thead.kernel.dev;\n\n    # use `nix develop .#fhs` to enter the fhs test environment defined here.\n    devShells.x86_64-linux.fhs = let\n      pkgs = import nixpkgs {\n        system = \"x86_64-linux\";\n      };\n    in\n      # the code here is mainly copied from:\n      #   https://nixos.wiki/wiki/Linux_kernel#Embedded_Linux_Cross-compile_xconfig_and_menuconfig\n      (pkgs.buildFHSUserEnv {\n        name = \"kernel-build-env\";\n        targetPkgs = pkgs_: (with pkgs_;\n          [\n            # we need theses packages to run `make menuconfig` successfully.\n            pkgconfig\n            ncurses\n\n            pkgsKernel.gcc13Stdenv.cc\n            gcc\n          ]\n          ++ pkgs.linux.nativeBuildInputs);\n        runScript = pkgs.writeScript \"init.sh\" ''\n          # set the cross-compilation environment variables.\n          export CROSS_COMPILE=riscv64-unknown-linux-gnu-\n          export ARCH=riscv\n          export PKG_CONFIG_PATH=\"${pkgs.ncurses.dev}/lib/pkgconfig:\"\n          exec bash\n        '';\n      }).env;\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n\n\n通过上面的 flake.nix，我可以通过 nix develop .#kernel 进入到内核的构建环境中，执行 unpackPhase 解压出内核源码。\n\n但是不能执行 make menuconfig 进行内核的配置，因为该环境中缺少 ncurses 等包。\n\n所以我第二步是退出再通过 nix develop .#fhs 进入到另一个添加了必需包的 FHS 环境中，再执行 make menuconfig 进行内核的配置，以及后续的构建调试。\n\nReferences\n​\nLinux kernel - NixOS Wiki\nhttps://github.com/jordanisaacs/kernel-module-flake"
  },
  {
    "title": "分布式构建 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/development/distributed-building",
    "html": "分布式构建\n​\n\n分布式构建可以通过多台机器来分担本地的编译压力，加快构建速度。\n\nNixOS 官方的 cache.nixos.org 中提供了绝大多数 X86_64 架构的缓存，因此对于普通 X86_64 的用户，一般不需要分布式构建。\n\n分布式构建只在没有缓存可用的场景下才有较大应用价值，主要有这几种应用场景：\n\nRISC-V 或 ARM64 架构的用户（尤其是 RISC-V），因为官方缓存仓库中这两个架构的缓存很少，导致经常需要大量本地编译。\n对系统进行大量定制的用户，因为官方缓存仓库中的 packages 都是默认配置，如果你改了构建参数，那么官方缓存就不适用了，这时候就需要本地编译。\n比如嵌入式场景下往往对底层内核、驱动等有定制需求，导致需要本地编译。\n配置分布式构建\n​\n\n官方没有详细文档讲这个，我在文末列出了一些建议阅读的参考文档，同时如下是我的分布式构建配置（一个 NixOS Module）：\n\nnix\n{ ... }: {\n\n  ####################################################################\n  #\n  #  NixOS's Configuration for Remote Building / Distributed Building\n  #\n  ####################################################################\n\n  # set local's max-job to 0 to force remote building(disable local building)\n  # nix.settings.max-jobs = 0;\n  nix.distributedBuilds = true;\n  nix.buildMachines =\n    let\n      sshUser = \"ryan\";\n      # ssh key's path on local machine\n      sshKey = \"/home/ryan/.ssh/ai-idols\";\n      systems = [\n        # native arch\n        \"x86_64-linux\"\n\n        # emulated arch using binfmt_misc and qemu-user\n        \"aarch64-linux\"\n        \"riscv64-linux\"\n      ];\n      # all available system features are poorly documentd here:\n      #  https://github.com/NixOS/nix/blob/e503ead/src/libstore/globals.hh#L673-L687\n      supportedFeatures = [\n        \"benchmark\"\n        \"big-parallel\"\n        \"kvm\"\n      ];\n    in\n      [\n        # Nix seems always give priority to trying to build remotely\n        # to make use of the local machine's high-performance CPU, do not set remote builder's maxJobs too high.\n        {\n          # some of my remote builders are running NixOS\n          # and has the same sshUser, sshKey, systems, etc.\n          inherit sshUser sshKey systems supportedFeatures;\n\n          # the hostName should be:\n          #   1. a hostname that can be resolved by DNS\n          #   2. the ip address of the remote builder\n          #   3. a host alias defined globally in /etc/ssh/ssh_config\n          hostName = \"aquamarine\";\n          # remote builder's max-job\n          maxJobs = 3;\n          # speedFactor's a signed integer\n          # but it seems that it's not used by Nix, takes no effect\n          speedFactor = 1;\n        }\n        {\n          inherit sshUser sshKey systems supportedFeatures;\n          hostName = \"ruby\";\n          maxJobs = 2;\n          speedFactor = 1;\n        }\n        {\n          inherit sshUser sshKey systems supportedFeatures;\n          hostName = \"kana\";\n          maxJobs = 2;\n          speedFactor = 1;\n        }\n      ];\n  # optional, useful when the builder has a faster internet connection than yours\n\tnix.extraOptions = ''\n\t\tbuilders-use-substitutes = true\n\t'';\n\n  # define the host alias for remote builders\n  # this config will be written to /etc/ssh/ssh_config\n  programs.ssh.extraConfig = ''\n    Host ai\n      HostName 192.168.5.100\n      Port 22\n\n    Host aquamarine\n      HostName 192.168.5.101\n      Port 22\n\n    Host ruby\n      HostName 192.168.5.102\n      Port 22\n\n    Host kana\n      HostName 192.168.5.103\n      Port 22\n  '';\n\n  # define the host key for remote builders so that nix can verify all the remote builders\n  # this config will be written to /etc/ssh/ssh_known_hosts\n  programs.ssh.knownHosts = {\n    # 星野 愛久愛海, Hoshino Aquamarine\n    aquamarine = {\n      hostNames = [ \"aquamarine\" \"192.168.5.101\" ];\n      publicKey = \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIDnCQXlllHoLX5EvU+t6yP/npsmuxKt0skHVeJashizE\";\n    };\n\n    # 星野 瑠美衣, Hoshino Rubii\n    ruby = {\n      hostNames = [ \"ruby\" \"192.168.5.102\" ];\n      publicKey = \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIE7n11XxB8B3HjdyAsL3PuLVDZxWCzEOUTJAY8+goQmW\";\n    };\n\n    # 有馬 かな, Arima Kana\n    kana = {\n      hostNames = [ \"kana\" \"192.168.5.103\" ];\n      publicKey = \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIJ3dDLOZERP1nZfRz3zIeVDm1q2Trer+fWFVvVXrgXM1\";\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n\n缺陷\n​\n\n目前我观察到的问题有：\n\n无法在构建时指定使用哪些主机，只能在配置文件中指定一个主机列表，然后 nix 会自动选择可用的主机。\n在选择主机时，我发现 Nix 总是优先选择远程主机，而我本地主机的性能最强，这导致本地主机的 CPU 无法充分利用。\n多机远程构建是以 Derivation 为单位的，因此在构建一些比较大的包时，其他机器可能会空闲很久，一直等这个大包构建完毕，这导致了资源的浪费。\n在构建的 packages 较多并且可以并行执行时，可以轻松将所有主机的 CPU 都用上，这确实非常爽。\nReferences\n​\nDistributed build - NixOS Wiki\nDocument available system features - nix#7380\nDistributed builds seem to disable local builds nix#2589\nOffloading NixOS builds to a faster machine\ntests/nixos/remote-builds.nix - Nix Source Code"
  },
  {
    "title": "跨平台编译 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/development/cross-platform-compilation",
    "html": "跨平台编译\n​\n\n首先在任何 Linux 平台上，都有两种方法进行跨平台构建。 以在 x86_64 架构上构建 aarch64 架构程序为例，两种构建方法说明如下：\n\n使用 QEMU 模拟 aarch64 架构，然后在模拟器中编译程序\n缺点是指令集模拟，性能低下\n优点是能利用上 NixOS 的 binary cache，不需要自己编译所有内容\n使用交叉编译器编译 aarch64 架构的程序\n缺点是无法利用 NixOS 的 binary cache，需要自己编译所有内容（交叉编译也有 cache，但是里面基本没啥东西）\n优点是不需要指令集模拟，性能高\n\n如果使用方法一，则需要在构建机的 NixOS 配置中启用 aarch64 架构的 binfmt_misc\n\n如果使用方法二，就不需要启用 binfmt_misc 了，但是需要通过交叉编译工具链来执行编译。\n\n交叉编译\n​\n\nnixpkgs 包含了一系列预定义好的交叉编译工具链，其名为 pkgsCross，我们先通过 nix repl 来看看有哪些工具链：\n\nshell\n› nix repl '<nixpkgs>'\nwarning: future versions of Nix will require using `--file` to load a file\nWelcome to Nix 2.13.3. Type :? for help.\n\nLoading installable ''...\nAdded 19273 variables.\nnix-repl> pkgsCross.<TAB>\npkgsCross.aarch64-android             pkgsCross.msp430\npkgsCross.aarch64-android-prebuilt    pkgsCross.musl-power\npkgsCross.aarch64-darwin              pkgsCross.musl32\npkgsCross.aarch64-embedded            pkgsCross.musl64\npkgsCross.aarch64-multiplatform       pkgsCross.muslpi\npkgsCross.aarch64-multiplatform-musl  pkgsCross.or1k\npkgsCross.aarch64be-embedded          pkgsCross.pogoplug4\npkgsCross.arm-embedded                pkgsCross.powernv\npkgsCross.armhf-embedded              pkgsCross.ppc-embedded\npkgsCross.armv7a-android-prebuilt     pkgsCross.ppc64\npkgsCross.armv7l-hf-multiplatform     pkgsCross.ppc64-musl\npkgsCross.avr                         pkgsCross.ppcle-embedded\npkgsCross.ben-nanonote                pkgsCross.raspberryPi\npkgsCross.fuloongminipc               pkgsCross.remarkable1\npkgsCross.ghcjs                       pkgsCross.remarkable2\npkgsCross.gnu32                       pkgsCross.riscv32\npkgsCross.gnu64                       pkgsCross.riscv32-embedded\npkgsCross.i686-embedded               pkgsCross.riscv64\npkgsCross.iphone32                    pkgsCross.riscv64-embedded\npkgsCross.iphone32-simulator          pkgsCross.rx-embedded\npkgsCross.iphone64                    pkgsCross.s390\npkgsCross.iphone64-simulator          pkgsCross.s390x\npkgsCross.loongarch64-linux           pkgsCross.sheevaplug\npkgsCross.m68k                        pkgsCross.vc4\npkgsCross.mingw32                     pkgsCross.wasi32\npkgsCross.mingwW64                    pkgsCross.x86_64-darwin\npkgsCross.mips-linux-gnu              pkgsCross.x86_64-embedded\npkgsCross.mips64-linux-gnuabi64       pkgsCross.x86_64-freebsd\npkgsCross.mips64-linux-gnuabin32      pkgsCross.x86_64-netbsd\npkgsCross.mips64el-linux-gnuabi64     pkgsCross.x86_64-netbsd-llvm\npkgsCross.mips64el-linux-gnuabin32    pkgsCross.x86_64-unknown-redox\npkgsCross.mipsel-linux-gnu\npkgsCross.mmix\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n如果想将一个 flake 全局的 pkgs 设置为交叉编译工具链，只需要在 flake.nix 中添加一个 Module，示例如下：\n\nnix\n{\n  description = \"NixOS running on LicheePi 4A\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-23.05\";\n  };\n\n  outputs = inputs@{ self, nixpkgs, ... }: {\n    nixosConfigurations.lp4a = nixpkgs.lib.nixosSystem {\n      # native platform\n      system = \"x86_64-linux\";\n      modules = [\n\n        # add this module, to enable cross-compilation.\n        {\n          nixpkgs.crossSystem = {\n            # target platform\n            system = \"riscv64-linux\";\n          };\n        }\n\n        # ...... other modules\n      ];\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n模块中的 nixpkgs.crossSystem 参数用于将 pkgs 设置为交叉编译工具链，这样构建出的内容全都会是 riscv64-linux 架构的。\n\n通过模拟系统进行跨平台编译\n​\n\n第二种方法是通过模拟系统进行跨平台编译，这种方法不需要交叉编译工具链。\n\n要使用这种方法，首先你的构建机需要在配置中启用 binfmt_misc 模块，如果你的构建机是 NixOS，将如下配置添加到你的 NixOS Module 即可启用 aarch64-linux 与 riscv64-linux 两种架构的模拟构建系统：\n\nnix\n{ ... }:\n{\n  # ......\n\n  # Enable binfmt emulation.\n  boot.binfmt.emulatedSystems = [ \"aarch64-linux\" \"riscv64-linux\" ];\n\n  # ......\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n至于 flake.nix，它的设置方法非常简单，比前面交叉编译的设置还要简单，示例如下：\n\nnix\n{\n  description = \"NixOS running on LicheePi 4A\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-23.05\";\n  };\n\n  outputs = inputs@{ self, nixpkgs, ... }: {\n    nixosConfigurations.lp4a = nixpkgs.lib.nixosSystem {\n      # native platform\n      system = \"riscv64-linux\";\n      modules = [\n        # ...... other modules\n      ];\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n可以看到我们未添加任何额外的模块，仅仅是指定了 system 为 riscv64-linux. Nix 在构建时会自动检测当前系统是否为 riscv64-linux，如果不是，它会自动通过 QEMU 模拟系统进行构建，对用户而言这些底层操作完全是透明的。\n\nLinux binfmt_misc\n​\n\n前面只说了怎么用，如果你想了解更底层的细节，这里也简单介绍一下。\n\nbinfmt_misc 是 Linux 内核的一项功能，全称是混杂二进制格式的内核支持（Kernel Support for miscellaneous Binary Formats），它能够使 Linux 支持运行几乎任何 CPU 架构的程序，包括 X86_64、ARM64、RISCV64 等。\n\n为了能够让 binfmt_misc 运行任意格式的程序，至少需要做到两点：特定格式二进制程序的识别方式，以及其对应的解释器位置。虽然 binfmt_misc 听上去很强大，其实现的方式却意外地很容易理解，类似于 bash 解释器通过脚本文件的第一行（如#!/usr/bin/python3）得知该文件需要通过什么解释器运行，binfmt_misc 也预设了一系列的规则，如读取二进制文件头部特定位置的魔数，或者根据文件扩展名（如.exe、.py）以判断可执行文件的格式，随后调用对应的解释器去运行该程序。Linux 默认的可执行文件格式是 elf，而 binfmt_misc 的出现拓宽了 Linux 的执行限制，将一点展开成一个面，使得各种各样的二进制文件都能选择它们对应的解释器执行。\n\n注册一种格式的二进制程序需要将一行有 :name:type:offset:magic:mask:interpreter:flags 格式的字符串写入 /proc/sys/fs/binfmt_misc/register 中，格式的详细解释这里就略过了。\n\n由于人工写入上述 binfmt_misc 的注册信息比较麻烦，社区提供了一个容器来帮助我们自动注册，这个容器就是 binfmt，运行一下该容器就能安装各种格式的 binfmt_misc 模拟器了，举个例子：\n\nshell\n# 注册所有架构\npodman run --privileged --rm tonistiigi/binfmt:latest --install all\n\n# 仅注册常见的 arm/riscv 架构\ndocker run --privileged --rm tonistiigi/binfmt --install arm64,riscv64,arm\n1\n2\n3\n4\n5\n\n\nbinfmt_misc 模块自 Linux 2.6.12-rc2 版本中引入，先后经历了几次功能上的略微改动。 Linux 4.8 中新增“F”（fix binary，固定二进制）标志位，使 mount 命名空间变更和 chroot 后的环境中依然能够正常调用解释器执行二进制程序。由于我们需要构建多架构容器，必须使用“F”标志位才能 binfmt_misc 在容器中正常工作，因此内核版本需要在 4.8 以上才可以。\n\n总的来说，比起一般情况显式调用解释器去执行非原生架构程序，binfmt_misc 产生的一个重要意义在于透明性。有了 binfmt_misc 后，用户在执行程序时不需要再关心要用什么解释器去执行，好像任何架构的程序都能够直接执行一样，而可配置的“F”标志位更是锦上添花，使解释器程序在安装时立即就被加载进内存，后续的环境改变也不会影响执行过程。\n\n自定义构建工具链\n​\n\n有时候我们会需要使用自定义的工具链进行构建，比如使用自己编译的 gcc，或者使用自己编译的 musl libc 等等，这种修改可以通过 overlays 来实现。\n\n举个例子，我们来尝试下使用使用不同的 gcc 版本，通过 nix repl 来测试下：\n\nshell\n› nix repl -f '<nixpkgs>'\nWelcome to Nix 2.13.3. Type :? for help.\n\nLoading installable ''...\nAdded 17755 variables.\n\n# 通过 overlays 替换掉 gcc\nnix-repl> a = import <nixpkgs> { crossSystem = { config = \"riscv64-unknown-linux-gnu\"; }; overlays = [ (self: super: { gcc = self.gcc12; }) ]; }\n\n# 查看下 gcc 版本，确实改成 12.2 了\nnix-repl> a.pkgsCross.riscv64.stdenv.cc\n«derivation /nix/store/jjvvwnf3hzk71p65x1n8bah3hrs08bpf-riscv64-unknown-linux-gnu-stage-final-gcc-wrapper-12.2.0.drv»\n\n# 再看下未修改的 gcc 版本，还是 11.3\nnix-repl> pkgs.pkgsCross.riscv64.stdenv.cc\n«derivation /nix/store/pq3g0wq3yfc4hqrikr03ixmhqxbh35q7-riscv64-unknown-linux-gnu-stage-final-gcc-wrapper-11.3.0.drv»\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n那么如何在 Flakes 中使用这种方法呢？示例 flake.nix 内容如下:\n\nnix\n{\n  description = \"NixOS running on LicheePi 4A\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-23.05-small\";\n  };\n\n  outputs = { self, nixpkgs, ... }:\n  {\n    nixosConfigurations.lp4a = nixpkgs.lib.nixosSystem {\n      system = \"x86_64-linux\";\n      modules = [\n        {\n          nigpkgs.crossSystem = {\n            config = \"riscv64-unknown-linux-gnu\";\n          };\n\n          # 改用 gcc12\n          nixpkgs.overlays = [ (self: super: { gcc = self.gcc12; }) ];\n        }\n\n        # other moduels ......\n      ];\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n上面的方法会替换掉全局的 pkgs.gcc，很可能会导致大量的缓存失效，从而需要在本地本地构建非常多的 Nix 包。\n\n为了避免这个问题，更好的办法是创建一个新的 pkgs 实例，仅在构建我们想修改的包时才使用这个实例，flake.nix 示例如下：\n\nnix\n{\n  description = \"NixOS running on LicheePi 4A\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-23.05-small\";\n  };\n\n  outputs = { self, nixpkgs, ... }: let\n    # 自定义一个新的 pkgs 实例，使用 gcc12\n    pkgs-gcc12 = import nixpkgs {\n      localSystem = \"x86_64-linux\";\n      crossSystem = {\n        config = \"riscv64-unknown-linux-gnu\";\n      };\n\n      overlays = [\n        (self: super: { gcc = self.gcc12; })\n      ];\n    };\n  in {\n    nixosConfigurations.lp4a = nixpkgs.lib.nixosSystem {\n      system = \"x86_64-linux\";\n      specialArgs = {\n        # pass the new pkgs instance to the module\n        inherit pkgs-gcc12;\n      };\n      modules = [\n        {\n          nigpkgs.crossSystem = {\n            config = \"riscv64-unknown-linux-gnu\";\n          };\n        }\n\n        ({pkgs-gcc12, ...}: {\n          # 使用 pkgs-gcc12 实例\n          environment.systemPackages = [ pkgs-gcc12.hello ];\n        })\n\n        # other moduels ......\n      ];\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n通过上述方法，我们可以很方便地自定义部分软件包的构建工具链，而不影响其他软件包的构建。\n\nReferences\n​\nCross compilation - nix.dev\n容器镜像多架构支持介绍"
  },
  {
    "title": "Nix 软件打包入门 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/development/packaging-101",
    "html": "Nix 软件打包入门\n​\n\nTODO\n\n1. stdenv 构建介绍\n​\n\nTODO\n\n2. language specific frameworks\n​\n\nTODO\n\nReferences\n​\nNixOS 系列（三）：软件打包，从入门到放弃 - LanTian\nHow to Learn Nix, Part 28: The standard environment\nstdenv - Nixpkgs Manual\nlanguages-frameworks - Nixpkgs Manual\nUseful tools:\nnurl: Generate Nix fetcher calls from repository URLs\nnix-init: Generate Nix packages from URLs with hash prefetching, dependency inference, license detection, and more"
  },
  {
    "title": "在 NixOS 上进行开发工作 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/development/intro",
    "html": "在 NixOS 上进行开发工作\n​\n\n由于 NixOS 自身可复现的特性，它非常适合用于搭建开发环境。 但是如果你想直接将在其他发行版上的环境搭建经验用在 NixOS 上，可能会遇到许多问题，因为 NixOS 有自己的一套逻辑在，下面我们先对此稍作说明。\n\n在 NixOS 上，全局环境中只建议安装一些通用的工具，比如 git、vim、emacs、tmux、zsh 等等，而各语言的开发环境，最好是每个项目都有一个独立的环境。 为了简便，你也可以考虑提前为常用语言创建一些通用的开发环境，在需要时切换进去。\n\n总而言之，NixOS 上的开发环境不应该装在全局，应该是一个个独立的项目环境，或许还带有一些通用的语言环境，但是它们都是完全隔离的，不会相互影响。\n\n在本章中我们先学习一下 Nix Flakes 开发环境的实现原理，后面的章节再按使用场景介绍一些更具体的内容。\n\n创建与使用开发环境\n​\n\n在 Nix Flakes 中，我们可以通过 pkgs.mkShell { ... } 来定义一个项目环境，通过 nix develop 来打开一个该开发环境的交互式 Bash Shell.\n\n为了更好的使用上述两个功能，我们先来看看它们的原理。\n\npkgs.mkShell 的源码如下：\n\nnix\n{ lib, stdenv, buildEnv }:\n\n# A special kind of derivation that is only meant to be consumed by the\n# nix-shell.\n{ name ? \"nix-shell\"\n, # a list of packages to add to the shell environment\n  packages ? [ ]\n, # propagate all the inputs from the given derivations\n  inputsFrom ? [ ]\n, buildInputs ? [ ]\n, nativeBuildInputs ? [ ]\n, propagatedBuildInputs ? [ ]\n, propagatedNativeBuildInputs ? [ ]\n, ...\n}@attrs:\nlet\n  mergeInputs = name:\n    (attrs.${name} or [ ]) ++\n    (lib.subtractLists inputsFrom (lib.flatten (lib.catAttrs name inputsFrom)));\n\n  rest = builtins.removeAttrs attrs [\n    \"name\"\n    \"packages\"\n    \"inputsFrom\"\n    \"buildInputs\"\n    \"nativeBuildInputs\"\n    \"propagatedBuildInputs\"\n    \"propagatedNativeBuildInputs\"\n    \"shellHook\"\n  ];\nin\n\nstdenv.mkDerivation ({\n  inherit name;\n\n  buildInputs = mergeInputs \"buildInputs\";\n  nativeBuildInputs = packages ++ (mergeInputs \"nativeBuildInputs\");\n  propagatedBuildInputs = mergeInputs \"propagatedBuildInputs\";\n  propagatedNativeBuildInputs = mergeInputs \"propagatedNativeBuildInputs\";\n\n  shellHook = lib.concatStringsSep \"\\n\" (lib.catAttrs \"shellHook\"\n    (lib.reverseList inputsFrom ++ [ attrs ]));\n\n  phases = [ \"buildPhase\" ];\n\n  # ......\n\n  # when distributed building is enabled, prefer to build locally\n  preferLocalBuild = true;\n} // rest)\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n可以看到 pkgs.mkShell { ... } 本质上就是一个特殊的 Derivation（Nix 包），它的 name buildInputs 等参数都是可自定义的，而 shellHook 则是一个特殊的参数，它会在 nix develop 进入该环境时被执行。\n\n如下是一份 flake.nix 文件，它定义了一个 nodejs 18 的开发环境：\n\nnix\n{\n  description = \"A Nix-flake-based Node.js development environment\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-23.05\";\n  };\n\n  outputs = { self , nixpkgs ,... }: let\n    # system should match the system you are running on\n    # system = \"x86_64-linux\";\n    system = \"x86_64-darwin\";\n  in {\n    devShells.\"${system}\".default = let\n      pkgs = import nixpkgs {\n        inherit system;\n        overlays = [\n          (self: super: rec {\n            nodejs = super.nodejs-18_x;\n            pnpm = super.nodePackages.pnpm;\n            yarn = (super.yarn.override { inherit nodejs; });\n          })\n        ];\n      };\n    in pkgs.mkShell {\n      # create an environment with nodejs-18_x, pnpm, and yarn\n      packages = with pkgs; [\n        node2nix\n        nodejs\n        pnpm\n        yarn\n      ];\n\n      shellHook = ''\n        echo \"node `${pkgs.nodejs}/bin/node --version`\"\n      '';\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n建个空文件夹，将上面的配置保存为 flake.nix，然后执行 nix develop（或者更精确点，可以用 nix develop .#default），你会发现你已经进入了一个 nodejs 18 的开发环境，可以使用 node npm pnpm yarn 等命令了。而且刚进入时，shellHook 也被执行了，输出了当前 nodejs 的版本。\n\n在开发环境中使用 zsh/fish 等其他 shell\n​\n\npkgs.mkShell 默认使用 bash，但是你也可以通过在 shellHook 中添加 exec <your-shell> 来使用 zsh 或者 fish 等其他 shell。\n\n示例如下：\n\nnix\n{\n  description = \"A Nix-flake-based Node.js development environment\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-23.05\";\n  };\n\n  outputs = { self , nixpkgs ,... }: let\n    # system should match the system you are running on\n    # system = \"x86_64-linux\";\n    system = \"x86_64-darwin\";\n  in {\n    devShells.\"${system}\".default = let\n      pkgs = import nixpkgs {\n        inherit system;\n        overlays = [\n          (self: super: rec {\n            nodejs = super.nodejs-18_x;\n            pnpm = super.nodePackages.pnpm;\n            yarn = (super.yarn.override { inherit nodejs; });\n          })\n        ];\n      };\n    in pkgs.mkShell {\n      # create an environment with nodejs-18_x, pnpm, and yarn\n      packages = with pkgs; [\n        node2nix\n        nodejs\n        pnpm\n        yarn\n        nushell\n      ];\n\n      shellHook = ''\n        echo \"node `${pkgs.nodejs}/bin/node --version`\"\n        exec nu\n      '';\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n使用上面的 flake.nix 配置，nix develop 将进入一个 nodejs 18 的开发环境，同时使用 nushell 作为交互式 shell.\n\n进入任何 Nix 包的构建环境\n​\n\n现在再来看看 nix develop，先读下 nix develop --help 输出的帮助文档：\n\nName\n    nix develop - run a bash shell that provides the build environment of a derivation\n\nSynopsis\n    nix develop [option...] installable\n# ......\n1\n2\n3\n4\n5\n6\n\n\n可以看到 nix develop 接受的参数是 installable，这说明我们可以通过它进入任何一个 installable 的 Nix 包的开发环境，而不仅仅是 pkgs.mkShell 创建的环境。\n\n默认情况下，nix develop 命令会尝试 flake outputs 中的如下属性：\n\ndevShells.<system>.default\npackages.<system>.default\n\n而如果我们通过 nix develop /path/to/flake#<name> 来指定了 flake 包地址以及 flake output name，那么 nix develop 命令会尝试 flake outputs 中的如下属性：\n\ndevShells.<system>.<name>\npackages.<system>.<name>\nlegacyPackages.<system>.<name>\n\n现在来尝试一下，首先测试下，确认我当前环境中没有 c++ g++ 这这些编译相关的命令：\n\nshell\nryan in 🌐 aquamarine in ~\n› c++\nc++: command not found\n\nryan in 🌐 aquamarine in ~\n› g++\ng++: command not found\n1\n2\n3\n4\n5\n6\n7\n\n\n现在通过 nix develop 进入到 hello 的构建环境，然后再次测试下：\n\nshell\n# login to the build environment of the package `hello`\nryan in 🌐 aquamarine in ~\n› nix develop nixpkgs#hello\n\nryan in 🌐 aquamarine in ~ via ❄️  impure (hello-2.12.1-env)\n› env | grep CXX\nCXX=g++\n\nryan in 🌐 aquamarine in ~ via ❄️  impure (hello-2.12.1-env)\n› c++ --version\ng++ (GCC) 12.3.0\nCopyright (C) 2022 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\nryan in 🌐 aquamarine in ~ via ❄️  impure (hello-2.12.1-env)\n› g++ --version\ng++ (GCC) 12.3.0\nCopyright (C) 2022 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n可以看到 CXX CXXCPP 环境变量已经被设置好了，而且 c++ g++ 等命令也可以正常使用了。\n\n此外我们还可以正常调用 hello 这个 Nix 包的各构建阶段命令：\n\n提前说明下，一个 Nix 包的所有构建阶段及其默认的执行顺序为：$prePhases unpackPhase patchPhase $preConfigurePhases configurePhase $preBuildPhases buildPhase checkPhase $preInstallPhases installPhase fixupPhase installCheckPhase $preDistPhases distPhase $postPhases\n\nshell\n# 解压源码包\nryan in 🌐 aquamarine in /tmp/xxx via ❄️  impure (hello-2.12.1-env)\n› unpackPhase\nunpacking source archive /nix/store/pa10z4ngm0g83kx9mssrqzz30s84vq7k-hello-2.12.1.tar.gz\nsource root is hello-2.12.1\nsetting SOURCE_DATE_EPOCH to timestamp 1653865426 of file hello-2.12.1/ChangeLog\n\nryan in 🌐 aquamarine in /tmp/xxx via ❄️  impure (hello-2.12.1-env)\n› ls\nhello-2.12.1\n\nryan in 🌐 aquamarine in /tmp/xxx via ❄️  impure (hello-2.12.1-env)\n› cd hello-2.12.1/\n\n# generate Makefile\nryan in 🌐 aquamarine in /tmp/xxx/hello-2.12.1 via ❄️  impure (hello-2.12.1-env)\n› configurePhase\nconfigure flags: --prefix=/tmp/xxx/outputs/out --prefix=/tmp/xxx/outputs/out\nchecking for a BSD-compatible install... /nix/store/02dr9ymdqpkb75vf0v1z2l91z2q3izy9-coreutils-9.3/bin/install -c\nchecking whether build environment is sane... yes\nchecking for a thread-safe mkdir -p... /nix/store/02dr9ymdqpkb75vf0v1z2l91z2q3izy9-coreutils-9.3/bin/mkdir -p\nchecking for gawk... gawk\nchecking whether make sets $(MAKE)... yes\nchecking whether make supports nested variables... yes\nchecking for gcc... gcc\n# ......\nchecking that generated files are newer than configure... done\nconfigure: creating ./config.status\nconfig.status: creating Makefile\nconfig.status: creating po/Makefile.in\nconfig.status: creating config.h\nconfig.status: config.h is unchanged\nconfig.status: executing depfiles commands\nconfig.status: executing po-directories commands\nconfig.status: creating po/POTFILES\nconfig.status: creating po/Makefile\n\n# build the package\nryan in 🌐 aquamarine in /tmp/xxx/hello-2.12.1 via C v12.3.0-gcc via ❄️  impure (hello-2.12.1-env) took 2s\n› buildPhase\nbuild flags: SHELL=/run/current-system/sw/bin/bash\nmake  all-recursive\nmake[1]: Entering directory '/tmp/xxx/hello-2.12.1'\n# ......\nranlib lib/libhello.a\ngcc  -g -O2   -o hello src/hello.o  ./lib/libhello.a\nmake[2]: Leaving directory '/tmp/xxx/hello-2.12.1'\nmake[1]: Leaving directory '/tmp/xxx/hello-2.12.1'\n\n# run the built program\nryan in 🌐 aquamarine in /tmp/xxx/hello-2.12.1 via C v12.3.0-gcc via ❄️  impure (hello-2.12.1-env)\n› ./hello\nHello, world!\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n这种用法的主要应用场景是调试某个 Nix 包的构建过程，或者在某个 Nix 包的构建环境中执行一些命令。\n\nnix build\n​\n\nnix build 用于构建一个软件包，并在当前目录下创建一个名为 result 的符号链接，链接到该构建结果。\n\n一个示例：\n\nbash\n# 构建 `nixpkgs` flake 中的 `ponysay` 这个包\nnix build \"nixpkgs#ponysay\"\n# 使用构建出来的 ponysay 命令\n› ./result/bin/ponysay 'hey buddy!'\n ____________ \n< hey buddy! >\n ------------ \n     \\                                  \n      \\                                 \n       \\                                \n       ▄▄  ▄▄ ▄ ▄                       \n    ▀▄▄▄█▄▄▄▄▄█▄▄▄                      \n   ▀▄███▄▄██▄██▄▄██                     \n  ▄██▄███▄▄██▄▄▄█▄██                    \n █▄█▄██▄█████████▄██                    \n  ▄▄█▄█▄▄▄▄▄████████                    \n ▀▀▀▄█▄█▄█▄▄▄▄▄█████         ▄   ▄      \n    ▀▄████▄▄▄█▄█▄▄██       ▄▄▄▄▄█▄▄▄    \n    █▄██▄▄▄▄███▄▄▄██    ▄▄▄▄▄▄▄▄▄█▄▄    \n    ▀▄▄██████▄▄▄████    █████████████   \n       ▀▀▀▀▀█████▄▄ ▄▄▄▄▄▄▄▄▄▄██▄█▄▄▀   \n            ██▄███▄▄▄▄█▄▄▀  ███▄█▄▄▄█▀  \n            █▄██▄▄▄▄▄████   ███████▄██  \n            █▄███▄▄█████    ▀███▄█████▄ \n            ██████▀▄▄▄█▄█    █▄██▄▄█▄█▄ \n           ███████ ███████   ▀████▄████ \n           ▀▀█▄▄▄▀ ▀▀█▄▄▄▀     ▀██▄▄██▀█\n                                ▀  ▀▀█\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n其他命令\n​\n\n其他还有些 nix flake init 之类的命令，请自行查阅 New Nix Commands 学习研究，这里就不详细介绍了。\n\nReferences\n​\npkgs.mkShell - nixpkgs manual\nA minimal nix-shell\nOne too many shell, Clearing up with nix' shells nix shell and nix-shell - Yannik Sander"
  },
  {
    "title": "Dev Environments | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/development/dev-environments",
    "html": "Dev Environments\n​\n\n前面我们已经学习了构建开发环境的实现原理，但是每次都要自己写一堆重复性较高的 flake.nix，略显繁琐。\n\n幸运的是，社区已经有人为我们做好了这件事，如下这个仓库中包含了绝大多数编程语言的开发环境模板，直接复制粘贴下来就能用：\n\nthe-nix-way/dev-templates\nMordragT/nix-templates\n\n如果你觉得 flake.nix 的结构还是太复杂了，希望能有更简单的方法，也可以考虑使用下面这个项目，它对 Nix 做了更彻底的封装，对用户提供了更简单的定义：\n\ncachix/devenv\n\n如果你连任何一行 nix 代码都不想写，只想以最小的代价获得一个可复现的开发环境，这里也有一个或许能符合你需求的工具：\n\njetpack-io/devbox\nPython 开发环境\n​\n\nPython 的开发环境比 Java/Go 等语言要麻烦许多，因为它默认就往全局环境装软件，要往当前项目装，还必须得先创建虚拟环境（JS/Go 等语言里可没虚拟环境这种幺蛾子）。 这对 Nix 而言是非常不友好的行为。\n\nPython 的 pip 默认会将软件安装到全局，在 NixOS 中 pip install 会直接报错：\n\nshell\n› pip install -r requirements.txt\nerror: externally-managed-environment\n\n× This environment is externally managed\n╰─> This command has been disabled as it tries to modify the immutable\n    `/nix/store` filesystem.\n\n    To use Python with Nix and nixpkgs, have a look at the online documentation:\n    <https://nixos.org/manual/nixpkgs/stable/#python>.\n\nnote: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.\nhint: See PEP 668 for the detailed specification.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n根据错误信息，pip install 直接被 NixOS 禁用掉了，测试了 pip install --user 也同样被禁用。为了提升环境的可复现能力，Nix 把它们全部废掉了。 即使我们通过 mkShell 等方式创建一个新环境，这些命令照样会报错（猜测是 Nixpkgs 中的 pip 命令本身就被魔改了，只要是跑 install 等修改指令就直接嘎掉）。\n\n但是很多项目的安装脚本都是基于 pip 的，这导致这些脚本都不能直接使用，而且另一方面 nixpkgs 中的内容有限，很多 pypi 中的包里边都没有，还得自己打包，相对麻烦很多，也加重了用户的心智负担。\n\n解决方案之一是改用 venv 虚拟环境，在虚拟环境里当然就能正常使用 pip 等命令了：\n\nshell\npython -m venv ./env\nsource ./env/bin/activate\n1\n2\n\n\n或者使用第三方工具 virtualenv，缺点是这个需要额外安装。\n\n这样用 python 直接创建的 venv，对一些人而言可能还是没有安全感，仍然希望将这个虚拟环境也弄进 /nix/store 里使其不可变，通过 nix 直接安装 requirements.txt 或者 poetry.toml 中的依赖项。 这当然是可行的，有现成的 Nix 封装工具帮我们干这个活：\n\n注意即使是在这俩环境中，直接跑 pip install 之类的安装命令仍然是会失败的，必须通过 flake.nix 来安装 Python 依赖！ 因为数据还是在 /nix/store 中，这类修改命令必须在 Nix 的构建阶段才能执行...\n\nDavHau/mach-nix\npoetry2nix\n\n这俩工具的好处是，能利用上 Nix Flakes 的锁机制来提升可复现能力，缺点是多了一层封装，底层变得更复杂了。\n\n最后，在一些更复杂的项目上，上述两种方案可能都行不通，这时候最佳的解决方案，就是改用容器了，比如 Docker、Podman 等，容器的限制没 Nix 这么严格，能提供最佳的兼容性。"
  },
  {
    "title": "Testing | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/other-usage-of-flakes/testing",
    "html": "Testing\n​\n\nTODO\n\nReferences\n​\nNixOS Testing library"
  },
  {
    "title": "Nix option difinitions | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/other-usage-of-flakes/options",
    "html": "Nix option difinitions\n​\n\nTODO\n\nReferences\n​\nNixOS option definitions - NixOS in Production\nAdvanced option definitions - NixOS in Production"
  },
  {
    "title": "新一代 Nix 命令行工具的使用 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/other-usage-of-flakes/the-new-cli",
    "html": "新一代 Nix 命令行工具的使用\n​\n\n在启用了 nix-command & flakes 功能后，我们就可以使用 Nix 提供的新一代 Nix 命令行工具 New Nix Commands 了， 这里主要介绍 nix shell 与 nix run 两个命令，其他重要的命令（如 nix shell nix build）将在「在 NixOS 上进行开发工作」一章中再详细介绍。\n\nnix shell\n​\n\nnix shell 用于进入到一个含有指定 Nix 包的环境并为它打开一个交互式 shell：\n\nshell\n# hello 不存在\n› hello\nhello: command not found\n\n# 进入到一个含有 hello 的 shell 环境\n› nix shell nixpkgs#hello\n\n# hello 可以用了\n› hello\nHello, world!\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\nnix run\n​\n\nnix run 则是创建一个含有指定 Nix 包的环境，并在该环境中直接运行该 Nix 包（临时运行该程序，不将它安装到系统环境中）：\n\nshell\n# hello 不存在\n› hello\nhello: command not found\n\n# 创建一个含有 hello 的环境并运行它\n› nix run nixpkgs#hello\nHello, world!\n1\n2\n3\n4\n5\n6\n7\n\n\n因为 nix run 会直接将 Nix 包运行起来，所以作为其参数的 Nix 包必须能生成一个可执行程序。\n\n根据 nix run --help 的说明，nix run 会执行 <out>/bin/<name> 这个命令，其中 <out> 是一个 Derivation 的根目录，<name> 则按如下顺序进行选择尝试：\n\nDerivation 的 meta.mainProgram 属性\nDerivation 的 pname 属性\nDerivation 的 name 属性中去掉版本号后的内容\n\n比如说我们上面测试的包 hello，nix run 实际会执行 $out/bin/hello 这个程序。\n\n再给两个示例，并详细说明下相关参数：\n\nbash\n# 解释下这条指令涉及的参数：\n#   `nixpkgs#ponysay` 意思是 `nixpkgs` 这个 flake 中的 `ponysay` 包。\n#   `nixpkgs` 是一个 flakeregistry ida,\n#    nix 会从 <https://github.com/NixOS/flake-registry/blob/master/flake-registry.json> 中\n#    找到这个 id 对应的 github 仓库地址\n# 所以这个命令的意思是创建一个新环境，安装并运行 `nixpkgs` 这个 flake 提供的 `ponysay` 包。\n#   注：前面已经介绍过了，nix 包 是 flake outputs 中的一种。\necho \"Hello Nix\" | nix run \"nixpkgs#ponysay\"\n\n# 这条命令和上面的命令作用是一样的，只是使用了完整的 flake URI，而不是 flakeregistry id。\necho \"Hello Nix\" | nix run \"github:NixOS/nixpkgs/nixos-unstable#ponysay\"\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\nnix run 与 nix shell 的常见用途\n​\n\n那显然就是用来跑些临时命令，比如说我在新 NixOS 主机上恢复环境，但是还没有装 Git，我可以直接用如下命令临时使用 Git 克隆我的配置仓库：\n\nbash\nnix run nixpkgs#git clone git@github.com:ryan4yin/nix-config.git\n1\n\n\n或者也可以这样：\n\nbash\nnix shell nixpkgs#git \ngit clone git@github.com:ryan4yin/nix-config.git\n1\n2\n"
  },
  {
    "title": "Flake 的 outputs | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/other-usage-of-flakes/outputs",
    "html": "Flake 的 outputs\n​\n\nflake.nix 中的 outputs 是一个 attribute set，是整个 Flake 的构建结果，每个 Flake 都可以有许多不同的 outputs。\n\n一些特定名称的 outputs 有特殊用途，会被某些 Nix 命令识别处理，比如：\n\nNix packages: 名称为 apps.<system>.<name>, packages.<system>.<name> 或 legacyPackages.<system>.<name> 的 outputs，都是 Nix 包，通常都是一个个应用程序。\n可以通过 nix build .#name 来构建某个 nix 包\nNix Helper Functions: 名称为 lib 的 outputs 是 Flake 函数库，可以被其他 Flake 作为 inputs 导入使用。\nNix development environments: 名称为 devShells 的 outputs 是 Nix 开发环境\n可以通过 nix develop 命令来使用该 Output 创建开发环境\nNixOS configurations: 名称为 nixosConfigurations.<hostname> 的 outputs，是 NixOS 的系统配置。\nnixos-rebuild switch .#<hostname> 可以使用该 Output 来部署 NixOS 系统\nNix templates: 名称为 templates 的 outputs 是 flake 模板\n可以通过执行命令 nix flake init --template <reference> 使用模板初始化一个 Flake 包\n其他用户自定义的 outputs，可能被其他 Nix 相关的工具使用\n\nNixOS Wiki 中给出的使用案例：\n\nnix\n{\n  inputs = {\n    # ......\n  };\n\n  outputs = { self, ... }@inputs: {\n    # Executed by `nix flake check`\n    checks.\"<system>\".\"<name>\" = derivation;\n    # Executed by `nix build .#<name>`\n    packages.\"<system>\".\"<name>\" = derivation;\n    # Executed by `nix build .`\n    packages.\"<system>\".default = derivation;\n    # Executed by `nix run .#<name>`\n    apps.\"<system>\".\"<name>\" = {\n      type = \"app\";\n      program = \"<store-path>\";\n    };\n    # Executed by `nix run . -- <args?>`\n    apps.\"<system>\".default = { type = \"app\"; program = \"...\"; };\n\n    # Formatter (alejandra, nixfmt or nixpkgs-fmt)\n    formatter.\"<system>\" = derivation;\n    # Used for nixpkgs packages, also accessible via `nix build .#<name>`\n    legacyPackages.\"<system>\".\"<name>\" = derivation;\n    # Overlay, consumed by other flakes\n    overlays.\"<name>\" = final: prev: { };\n    # Default overlay\n    overlays.default = {};\n    # Nixos module, consumed by other flakes\n    nixosModules.\"<name>\" = { config }: { options = {}; config = {}; };\n    # Default module\n    nixosModules.default = {};\n    # Used with `nixos-rebuild --flake .#<hostname>`\n    # nixosConfigurations.\"<hostname>\".config.system.build.toplevel must be a derivation\n    nixosConfigurations.\"<hostname>\" = {};\n    # Used by `nix develop .#<name>`\n    devShells.\"<system>\".\"<name>\" = derivation;\n    # Used by `nix develop`\n    devShells.\"<system>\".default = derivation;\n    # Hydra build jobs\n    hydraJobs.\"<attr>\".\"<system>\" = derivation;\n    # Used by `nix flake init -t <flake>#<name>`\n    templates.\"<name>\" = {\n      path = \"<store-path>\";\n      description = \"template description goes here?\";\n    };\n    # Used by `nix flake init -t <flake>`\n    templates.default = { path = \"<store-path>\"; description = \"\"; };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n"
  },
  {
    "title": "Flake 的 inputs | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/other-usage-of-flakes/inputs",
    "html": "Flake 的 inputs\n​\n\nflake.nix 中的 inputs 是一个 attribute set，用来指定当前 Flake 的依赖，inputs 有很多种类型，举例如下：\n\nnix\n{\n  inputs = {\n    # 以 GitHub 仓库为数据源，指定使用 master 分支，这是最常见的 input 格式\n    nixpkgs.url = \"github:Mic92/nixpkgs/master\";\n    # Git URL，可用于任何基于 https/ssh 协议的 Git 仓库\n    git-example.url = \"git+https://git.somehost.tld/user/path?ref=branch\";\n    # 同样是拉取 Git 仓库，但使用 ssh 协议 + 密钥认证，同时使用了 shallow=1 参数避免复制 .git\n    ssh-git-example.url = \"git+ssh://git@github.com/ryan4yin/nix-secrets.git?shallow=1\";\n    # 当然也可以直接依赖本地的 git 仓库\n    git-directory-example.url = \"git+file:/path/to/repo?shallow=1\";\n    # 使用 `dir` 参数指定某个子目录\n    nixpkgs.url = \"github:foo/bar?dir=shu\";\n    # 本地文件夹 (如果使用绝对路径，可省略掉前缀 'path:')\n    directory-example.url = \"path:/path/to/repo\";\n\n    # 如果数据源不是一个 flake，则需要设置 flake=false\n    # `flake=false` 通常被用于引入一些额外的源代码、配置文件等\n    # 在 nix 代码中可以直接通过 \"${inputs.bar}/xxx/xxx\" 的方式来引用其中的文件\n    # 比如说通过 `import \"${inputs.bar}/xxx/xxx.nix\"` 来导入其中的 nix 文件\n    # 或者直接将 \"${inputs.bar}/xx/xx\" 当作某些 option 的路径参数使用\n    bar = {\n      url = \"github:foo/bar/branch\";\n      flake = false;\n    };\n\n    sops-nix = {\n      url = \"github:Mic92/sops-nix\";\n      # `follows` 是 inputs 中的继承语法\n      # 这里使 sops-nix 的 `inputs.nixpkgs` 与当前 flake 的 inputs.nixpkgs 保持一致，\n      # 避免依赖的 nixpkgs 版本不一致导致问题\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n\n    # 将 flake 锁定在某个 commit 上\n    nix-doom-emacs = {\n      url = \"github:vlaci/nix-doom-emacs?rev=238b18d7b2c8239f676358634bfb32693d3706f3\";\n      flake = false;\n    };\n  };\n\n  outputs = { self, ... }@inputs: { ... };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n"
  },
  {
    "title": "Nix Flakes 的其他玩法 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/other-usage-of-flakes/intro",
    "html": "Nix Flakes 的其他玩法\n​\n\n到这里我们已经写了不少 Nix Flakes 配置来管理 NixOS 系统了，这里再简单介绍下 Nix Flakes 更细节的内容，以及常用的 nix flake 命令。"
  },
  {
    "title": "调试 Derivation 跟 Nix 表达式 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/best-practices/debugging",
    "html": "调试 Derivation 跟 Nix 表达式\n​\n通过 nix repl 查看源码、调试配置\n​\n\n前面我们已经使用 nix repl '<nixpkgs>' 看过很多次源码了，这是一个非常强大的工具，可以帮助我们理解 Nix 的工作原理。\n\n要学会用 nix repl，最好先看看它的 help 信息：\n\n› nix repl -f '<nixpkgs>'\nWelcome to Nix 2.13.3. Type :? for help.\n\nLoading installable ''...\nAdded 17755 variables.\nnix-repl> :?\nThe following commands are available:\n\n  <expr>        Evaluate and print expression\n  <x> = <expr>  Bind expression to variable\n  :a <expr>     Add attributes from resulting set to scope\n  :b <expr>     Build a derivation\n  :bl <expr>    Build a derivation, creating GC roots in the working directory\n  :e <expr>     Open package or function in $EDITOR\n  :i <expr>     Build derivation, then install result into current profile\n  :l <path>     Load Nix expression and add it to scope\n  :lf <ref>     Load Nix flake and add it to scope\n  :p <expr>     Evaluate and print expression recursively\n  :q            Exit nix-repl\n  :r            Reload all files\n  :sh <expr>    Build dependencies of derivation, then start nix-shell\n  :t <expr>     Describe result of evaluation\n  :u <expr>     Build derivation, then start nix-shell\n  :doc <expr>   Show documentation of a builtin function\n  :log <expr>   Show logs for a derivation\n  :te [bool]    Enable, disable or toggle showing traces for errors\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n我最常用的命令是 :lf <ref> 跟 :e <expr>.\n\n:e <expr> 非常直观，所以这里不再赘述，我们来看看 :lf <ref>：\n\nnix\n# 进入我的 nix 配置目录（建议替换成你自己的配置目录）\n› cd ~/nix-config/\n\n# 进入 nix repl 解释器\n› nix repl\nWelcome to Nix 2.13.3. Type :? for help.\n\n# 将我的 nix 配置作为一个 flake 加载到当前作用域中\nnix-repl> :lf .\nAdded 16 variables.\n\n# 按 <TAB> 看看当前作用域中有哪些变量，果然 nixosConfigurations inputs outputs 跟 packages 都在里面\n# 这意味着我们可以很方便地检查这些配置的内部状态\nnix-repl><TAB>\n# ......omit some outputs\n__isInt                          nixosConfigurations\n__isList                         null\n__isPath                         outPath\n__isString                       outputs\n__langVersion                    packages\n# ......omit some outputs\n\n# 看看 inputs 里都有些啥\nnix-repl> inputs.<TAB>\ninputs.agenix            inputs.nixpkgs\ninputs.darwin            inputs.nixpkgs-darwin\ninputs.home-manager      inputs.nixpkgs-unstable\ninputs.hyprland          inputs.nixpkgs-wayland\ninputs.nil\ninputs.nixos-generators\n\n# 看看 inputs.nil.packages 里都有些啥\nnix-repl> inputs.nil.packages.\ninputs.nil.packages.aarch64-darwin\ninputs.nil.packages.aarch64-linux\ninputs.nil.packages.x86_64-darwin\ninputs.nil.packages.x86_64-linux\n\n# 看看 outputs 里都有些啥\nnix-repl> outputs.nixosConfigurations.<TAB>\noutputs.nixosConfigurations.ai\noutputs.nixosConfigurations.aquamarine\noutputs.nixosConfigurations.kana\noutputs.nixosConfigurations.ruby\n\n# 看看 ai 的配置都有些啥\nnix-repl> outputs.nixosConfigurations.ai.<TAB>\noutputs.nixosConfigurations.ai._module\noutputs.nixosConfigurations.ai._type\noutputs.nixosConfigurations.ai.class\noutputs.nixosConfigurations.ai.config\noutputs.nixosConfigurations.ai.extendModules\noutputs.nixosConfigurations.ai.extraArgs\noutputs.nixosConfigurations.ai.options\noutputs.nixosConfigurations.ai.pkgs\noutputs.nixosConfigurations.ai.type\n\nnix-repl> outputs.nixosConfigurations.ai.config.\noutputs.nixosConfigurations.ai.config.age\noutputs.nixosConfigurations.ai.config.appstream\noutputs.nixosConfigurations.ai.config.assertions\noutputs.nixosConfigurations.ai.config.boot\noutputs.nixosConfigurations.ai.config.console\noutputs.nixosConfigurations.ai.config.containers\n# ......omit other outputs\n\nnix-repl> outputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.<TAB>\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.activation\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.activationPackage\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.emptyActivationPath\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.enableDebugInfo\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.file\n# ......omit other outputs\n\n\nnix-repl> outputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.sessionVariables.<TAB>\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.sessionVariables.BROWSER\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.sessionVariables.DELTA_PAGER\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.sessionVariables.EDITOR\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.sessionVariables.TERM\n# ......omit other outputs\n\n# 看看 `TERM` 这个环境变量的值是啥\nnix-repl> outputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.sessionVariables.TERM\n\"xterm-256color\"\n\n\n# 看下我使用 `home.file` 定义的所有文件\nnix-repl> outputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.file.<TAB>\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.file..bash_profile\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.file..bashrc\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.file..config/fcitx5/profile\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.file..config/fcitx5/profile-bak\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.file..config/i3/config\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.file..config/i3/i3blocks.conf\n#......\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n\n\n能看到，通过 nix repl 加载好我的 flake 配置后，就能很方便地检查所有的配置项了，这对于调试非常有用。\n\n使用 nixpkgs 中提供的调试函数\n​\n\nTODO\n\n使用 derivation 的 NIX_DEBUG 参数调试\n​\n\nTODO\n\n参考文档\n​\nHow to make nix build display all commands executed by make?\nuse NIX_DEBUG=7 in derivation\nCollection of functions useful for debugging broken nix expressions."
  },
  {
    "title": "远程部署 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/best-practices/remote-deployment",
    "html": "远程部署\n​\n\nNix 本身的设计就很适合远程部署，Nix 社区也有许多专门用于远程部署的工具，比如说 NixOps 与 colmena。另外我们前面已经用了很多次的官方工具 nixos-rebuild，它拥有一定的远程部署能力。\n\n此外在多架构场景下，远程部署还可以充分利用 Nix 的多架构支持，比如说在 x86_64 主机上交叉编译 aarch64/aarch64 的 NixOS 系统配置，然后通过 SSH 远程部署到对应的主机上。 我最近遇到的一个场景是，我本地交叉编译了一块 RISCV64 开发板的 NixOS 系统镜像，那么我本地已经拥有了交叉编译该系统的所有编译缓存。 但是由于 NixOS 官方几乎没有 RISCV64 的二进制缓存，我直接在开发板上执行任何未预装的程序（比如 nix run nixpkgs#cowsay hello）都会导致大量的编译，这会耗费我数小时的时间，是难以接受的。 而改用远程部署的话，我就能充分利用上本机的高性能 CPU 与大量编译缓存，体验就很好了。\n\n这里我简单介绍下如何使用 colmena 与 nixos-rebuild 进行远程部署。\n\n准备工作\n​\n\n在进行远程部署之前，需要做一些准备工作：\n\n为了防止 sudo 密码验证失败，要么以 root 用户身份部署，要么为用户授予免密码验证的 sudo 权限。\n为远程主机配置 SSH 公钥身份验证。\n\n建议使用 root 用户进行部署，因为这更方便且不需要额外的配置，没有令人头疼的 sudo 权限问题。\n\n假设我们现在要通过 root 用户进行远程部署，首先需要在远程主机上为该用户配置 SSH 公钥身份验证。 直接在远程主机的 Nix 配置的任一 NixOS Module 中（比如 configuration.nix）添加如下内容，然后重新构建系统即可：\n\nnix\n# configuration.nix\n{\n\n  # ...\n\n  users.users.root.openssh.authorizedKeys.keys = [\n    # TODO 替换为您自己的 SSH 公钥。\n    \"ssh-ed25519 AAAAC3Nxxxxx ryan@xxx\"\n  ];\n\n  # ...\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n然后还需要提前在本机上将用于登录的 SSH 私钥添加到 SSH agent，以便在部署配置时进行身份验证：\n\nbash\nssh-add ~/.ssh/your-private-key\n1\n\n通过 colmena 进行部署\n​\n\ncolmena 不能直接使用我们已经熟悉的 nixosConfigurations.xxx 进行远程部署，它自定义了一个名为 colmena 的 flake outputs 来进行远程部署， 其内容结构与 nixosConfigurations.xxx 类似但不完全相同。\n\n在你系统的 flake.nix 中添加一个新的名为 colmena 的 outputs，一个简单的例子如下：\n\nnix\n{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-23.05\";\n\n    # ...\n  };\n  outputs = { self, nixpkgs }: {\n    # ...\n\n    # 新增这个 outputs，colmena 会读取这个 outputs 中的内容进行远程部署\n    colmena = {\n      meta = {\n        nixpkgs = import nixpkgs { system = \"x86_64-linux\"; };\n\n        # 这个参数的功能与 `nixosConfigurations.xxx` 中的 `sepcialArgs` 一致，\n        # 都是用于传递自定义参数到所有子模块。\n        specialArgs = {\n          inherit nixpkgs;\n        };\n      };\n\n      # 主机名 = \"nixos-test\"\n      \"nixos-test\" = { name, nodes, ... }: {\n        # 与远程部署相关的参数\n        deployment.targetHost = \"192.168.5.42\"; # 远程主机的 IP 地址\n        deployment.targetUser = \"root\";  # 远程主机的用户名\n\n        # 此参数的功能与 `nixosConfigurations.xxx` 中的 `modules` 一致\n        # 都是用于导入所有子模块。\n        imports = [\n          ./configuration.nix\n        ];\n      };\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n现在，您可以将配置部署到设备上：\n\nbash\nnix run nixpkgs#colmena apply\n1\n\n\n更复杂的用法，请参阅 colmena 的官方文档 https://colmena.cli.rs/unstable/introduction.html\n\n通过 nixos-rebuild 进行部署\n​\n\n用 nixos-rebuild 进行远程部署的好处在于，它的工作方式与部署到本地主机完全相同，只需要多传几个参数，指定下远程主机的 IP 地址、用户名等信息即可。\n\n例如，使用以下命令将 flake 中的 nixosConfigurations.nixos-test 这份配置部署到远程主机：\n\nbash\nnixos-rebuild switch --flake .#nixos-text \\\n  --target-host root@192.168.4.1 --build-host localhost --verbose\n1\n2\n\n\n上述命令将会构建并部署 nixos-test 的配置到 IP 为 192.168.4.1 的服务器，系统构建过程将在本机执行。\n\n如果你希望在远程主机上构建系统，只需要将 --build-host localhost 替换为 --build-host root@192.168.4.1。\n\n如果你觉得到处写 IP 地址不太合适，也可以在本地主机的 ~/.ssh/config 或 /etc/ssh/ssh_config 中定义主机别名。例如：\n\nSSH 配置可以完全通过 Nix 配置生成，这个任务就留给读者自己完成了。\n\nbash\n› cat ~/.ssh/config\n\n# ......\n\nHost aquamarine\n  HostName 192.168.4.1\n  Port 22\n\n# ......\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n然后就可以直接使用主机别名进行部署了：\n\nbash\nnixos-rebuild switch --flake .#nixos-test --target-host root@aquamarine --build-host root@aquamarine --verbose\n1\n"
  },
  {
    "title": "自定义 NIX_PATH 与 Flake Registry | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/best-practices/nix-path-and-flake-registry",
    "html": "自定义 NIX_PATH 与 Flake Registry\n​\nNIX_PATH 介绍\n​\n\nNix 搜索路径由环境变量 NIX_PATH 控制，它的格式与 Linux 的 PATH 环境变量一致，由冒号分隔的多个路径组成。\n\nNix 表达式中形如 <name> 的路径会被解析为 NIX_PATH 中名为 name 的路径。\n\n这种使用方式在 Flakes 特性下已经不推荐使用了，因为它会导致 Flake 的构建结果依赖一个可变的环境变量 NIX_PATH，可复现能力大打折扣。\n\n但是在某些场景下，我们还是需要使用 NIX_PATH，比如我们前面多次使用了 nix repl '<nixpkgs>' 命令，它就是使用了从 NIX_PATH 搜索到的 Nixpkgs。\n\nFlakes Registry 介绍\n​\n\nFlake Registry 是一个 Flake 注册中心，它可以帮助我们在使用 nix run, nix shell 等命令时，使用一个简短的 id 来代替长长的 flake 仓库地址。\n\n默认情况下，Nix 会从 https://github.com/NixOS/flake-registry/blob/master/flake-registry.json 中找到这个 id 对应的 github 仓库地址。\n\n比如说我们执行 nix run nixpkgs#ponysay hello，nix 会自动从上述 json 文件中找到 nixpkgs 对应的 github 仓库地址，然后下载这个仓库，再通过其中的 flake.nix 查找对应的 ponysay 包并运行它。\n\n自定义 NIX_PATH 与 Flake Registry\n​\n\n前面说明了 NIX_PATH 与 Flake Registry 的作用。 在日常使用中，我们一般都会希望能在执行 nix repl '<nixpkgs>', nix run nixpkgs#ponysay hello 等命令时，使用的 nixpkgs 与系统一致，这就需要我们自定义 NIX_PATH 与 Flake Registry。\n\n在你的 NixOS 配置中，添加如下 module 即可实现上述需求：\n\nnix\n{\n  # make `nix run nixpkgs#nixpkgs` use the same nixpkgs as the one used by this flake.\n  nix.registry.nixpkgs.flake = nixpkgs;\n\n  # make `nix repl '<nixpkgs>'` use the same nixpkgs as the one used by this flake.\n  environment.etc.\"nix/inputs/nixpkgs\".source = \"${nixpkgs}\";\n  nix.nixPath = [\"/etc/nix/inputs\"];\n}\n1\n2\n3\n4\n5\n6\n7\n8\n\n参考\n​\nChapter 15. Nix Search Paths - Nix Pills"
  },
  {
    "title": "使用 Makefile 简化 NixOS 相关命令 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/best-practices/simplify-nixos-related-commands",
    "html": "使用 Makefile 简化 NixOS 相关命令\n​\n\n注意: Makefile 的 target 名称不能与当前目录下的文件或者目录重名，否则 target 将不会被执行！\n\n在使用 NixOS 的过程中，我们会经常使用 nixos-rebuild 命令，经常需要输入一大堆参数，比较繁琐。\n\n所以我使用 Makefile 来管理我的 flake 配置相关的命令，简化使用。 你也可以使用其他类似的工具来干这个活（比如说 just 跟 cargo-make），这里我仅介绍下我的用法以供参考。\n\n我的 Makefile 大概内容截取如下：\n\nmakefile\n############################################################################\n#\n#  Nix commands related to the local machine\n#\n############################################################################\n\ndeploy:\n\tnixos-rebuild switch --flake . --use-remote-sudo\n\ndebug:\n\tnixos-rebuild switch --flake . --use-remote-sudo --show-trace --verbose\n\nupdate:\n\tnix flake update\n\nhistory:\n\tnix profile history --profile /nix/var/nix/profiles/system\n\ngc:\n\t# remove all generations older than 7 days\n\tsudo nix profile wipe-history --profile /nix/var/nix/profiles/system  --older-than 7d\n\n\t# garbage collect all unused nix store entries\n\tsudo nix store gc --debug\n\n############################################################################\n#\n#  Idols, Commands related to my remote distributed building cluster\n#\n############################################################################\n\nadd-idols-ssh-key:\n\tssh-add ~/.ssh/ai-idols\n\naqua: add-idols-ssh-key\n\tnixos-rebuild --flake .#aquamarine --target-host aquamarine --build-host aquamarine switch --use-remote-sudo\n\naqua-debug: add-idols-ssh-key\n\tnixos-rebuild --flake .#aquamarine --target-host aquamarine --build-host aquamarine switch --use-remote-sudo --show-trace --verbose\n\nruby: add-idols-ssh-key\n\tnixos-rebuild --flake .#ruby --target-host ruby --build-host ruby switch --use-remote-sudo\n\nruby-debug: add-idols-ssh-key\n\tnixos-rebuild --flake .#ruby --target-host ruby --build-host ruby switch --use-remote-sudo --show-trace --verbose\n\nkana: add-idols-ssh-key\n\tnixos-rebuild --flake .#kana --target-host kana --build-host kana switch --use-remote-sudo\n\nkana-debug: add-idols-ssh-key\n\tnixos-rebuild --flake .#kana --target-host kana --build-host kana switch --use-remote-sudo --show-trace --verbose\n\nidols: aqua ruby kana\n\nidols-debug: aqua-debug ruby-debug kana-debug\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n将上述 Makefile 放到 NixOS 配置的根目录下，然后我们就可以使用 make 命令来执行相关的命令了。 比如说我这里 make deploy 就是部署 NixOS 配置到本地主机，make idols 就是部署到我的远程主机集群。"
  },
  {
    "title": "Overriding | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/nixpkgs/overriding",
    "html": "Overriding\n​\n\n简单的说，所有 nixpkgs 中的 Nix 包都可以通过 <pkg>.override {} 来自定义某些构建参数，它返回一个使用了自定义参数的新 Derivation. 举个例子：\n\nnix\npkgs.fcitx5-rime.override {rimeDataPkgs = [\n    ./rime-data-flypy\n];}\n1\n2\n3\n\n\n上面这个 Nix 表达式的执行结果就是一个新的 Derivation，它的 rimeDataPkgs 参数被覆盖为 [./rime-data-flypy]，而其他参数则沿用原来的值。\n\n如何知道 fcitx5-rime 这个包有哪些参数可以覆写呢？有几种方法：\n\n直接在 GitHub 的 nixpkgs 源码中找：fcitx5-rime.nix\n注意要选择正确的分支，加入你用的是 nixos-unstable 分支，那就要在 nixos-unstable 分支中找。\n通过 nix repl 交互式查看：nix repl '<nixpkgs>'，然后输入 :e pkgs.fcitx5-rime，会通过编辑器打开这个包的源码，然后就可以看到这个包的所有参数了。\n\n通过上述两种方法，都可以看到 fcitx5-rime 这个包拥有如下输入参数，它们都是可以通过 override 修改的：\n\nnix\n{ lib, stdenv\n, fetchFromGitHub\n, pkg-config\n, cmake\n, extra-cmake-modules\n, gettext\n, fcitx5\n, librime\n, rime-data\n, symlinkJoin\n, rimeDataPkgs ? [ rime-data ]\n}:\n\nstdenv.mkDerivation rec {\n  ...\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n除了覆写参数，还可以通过 overrideAttrs 来覆写使用 stdenv.mkDerivation 构建的 Derivation 的属性。 以 pkgs.hello 为例，首先通过前述方法查看这个包的源码：\n\nnix\n{ callPackage\n, lib\n, stdenv\n, fetchurl\n, nixos\n, testers\n, hello\n}:\n\nstdenv.mkDerivation (finalAttrs: {\n  pname = \"hello\";\n  version = \"2.12.1\";\n\n  src = fetchurl {\n    url = \"mirror://gnu/hello/hello-${finalAttrs.version}.tar.gz\";\n    sha256 = \"sha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=\";\n  };\n\n  doCheck = true;\n\n  # ......\n})\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n其中 pname version src doCheck 等属性都是可以通过 overrideAttrs 来覆写的，比如：\n\nnix\nhelloWithDebug = pkgs.hello.overrideAttrs (finalAttrs: previousAttrs: {\n  doCheck = false;\n});\n1\n2\n3\n\n\n上面这个例子中，doCheck 就是一个新的 Derivation，它的 doCheck 参数被改写为 false，而其他参数则沿用原来的值。\n\n除了包源码中自定义的参数值外，我们也可以通过 overrideAttrs 直接改写 stdenv.mkDerivation 内部的默认参数，比如：\n\nnix\nhelloWithDebug = pkgs.hello.overrideAttrs (finalAttrs: previousAttrs: {\n  separateDebugInfo = true;\n});\n1\n2\n3\n\n\n具体的内部参数可以通过 nix repl '<nixpkgs>' 然后输入 :e stdenv.mkDerivation 来查看其源码。\n\n参考\n​\nChapter 4. Overriding - nixpkgs Manual"
  },
  {
    "title": "运行非 NixOS 的二进制文件 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/best-practices/run-downloaded-binaries-on-nixos",
    "html": "运行非 NixOS 的二进制文件\n​\n\nNixOS 不遵循 FHS 标准，因此你从网上下载的二进制程序在 NixOS 上大概率是跑不了的。 为了在 NixOS 上跑这些非 NixOS 的二进制程序，需要做一些骚操作。有位老兄在这里总结了 10 种实现此目的的方法：Different methods to run a non-nixos executable on Nixos，推荐一读。 此外如果你懒得自己折腾，只想实现需求，也可以直接看看这个傻瓜式工具 nix-alien.\n\n我个人用的比较多的方法是，直接创建一个 FHS 环境来运行二进制程序，这种方法非常方便易用。\n\n大概玩法是这样的，首先在你的 environment.systemPackages 中添加这个包：\n\nnix\n{ config, pkgs, lib, ... }:\n\n{\n  # ......\n\n  environment.systemPackages = with pkgs; [\n    # ......o\n\n    # create a fhs environment by command `fhs`, so we can run non-nixos packages in nixos!\n    (let base = pkgs.appimageTools.defaultFhsEnvArgs; in\n      pkgs.buildFHSUserEnv (base // {\n      name = \"fhs\";\n      targetPkgs = pkgs: (\n        # pkgs.buildFHSUserEnv 只提供一个最小的 FHS 环境，缺少很多常用软件所必须的基础包\n        # 所以直接使用它很可能会报错\n        #\n        # pkgs.appimageTools 提供了大多数程序常用的基础包，所以我们可以直接用它来补充\n        (base.targetPkgs pkgs) ++ with pkgs; [\n          pkg-config\n          ncurses\n          # 如果你的 FHS 程序还有其他依赖，把它们添加在这里\n        ]\n      );\n      profile = \"export FHS=1\";\n      runScript = \"bash\";\n      extraOutputsToInstall = [\"dev\"];\n    }))\n  ];\n\n  # ......\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n部署好上面的配置后，你就能用 fhs 命令进入我们定义好的 FHS 环境了，然后就可以运行你下载的二进制程序了，比如：\n\nshell\n# 进入我们定义好的 fhs 环境，它就跟其他 Linux 发行版一样了\n$ fhs\n# 看看我们的 /usr/bin 里是不是多了很多东西\n(fhs) $ ls /usr/bin\n# 尝试下跑一个非 nixos 的二进制程序\n(fhs) $ ./bin/code\n1\n2\n3\n4\n5\n6\n\n参考\n​\nTips&Tricks for NixOS Desktop - NixOS Discourse: Just as the title says, it is a collection of tips and tricks for NixOS desktop.\nnix-alien: Run unpatched binaries on Nix/NixOS"
  },
  {
    "title": "Overlays | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/nixpkgs/overlays",
    "html": "Overlays\n​\n\n前面介绍的 override 函数都会生成新的 Derivation，不影响 pkgs 中原有的 Derivation，只适合作为局部参数使用。 但如果你需要覆写的 Derivation 还被其他 Nix 包所依赖，那其他 Nix 包使用的仍然会是原有的 Derivation.\n\n为了解决这个问题，Nix 提供了 overlays 能力。简单的说，Overlays 可以全局修改 pkgs 中的 Derivation。\n\n在旧的 Nix 环境中，Nix 默认会自动应用 ~/.config/nixpkgs/overlays.nix ~/.config/nixpkgs/overlays/*.nix 这类路径下的所有 overlays 配置。\n\n但是在 Flakes 中，为了确保系统的可复现性，它不能依赖任何 Git 仓库之外的配置，所以这种旧的方法就不能用了。\n\n在使用 Nix Flakes 编写 NixOS 配置时，Home Manager 与 NixOS 都提供了 nixpkgs.overlays 这个 option 来引入 overlays, 相关文档：\n\nhome-manager docs - nixpkgs.overlays\nnixpkgs source code - nixpkgs.overlays\n\n举个例子，如下内容就是一个加载 Overlays 的 Module，它既可以用做 Home Manager Module，也可以用做 NixOS Module，因为这俩定义完全是一致的：\n\n不过我使用发现，Home Manager 毕竟是个外部组件，而且现在全都用的 unstable 分支，这导致 Home Manager Module 有时候会有点小毛病，因此更建议以 NixOS Module 的形式引入 overlays\n\nnix\n{ config, pkgs, lib, ... }:\n\n{\n  nixpkgs.overlays = [\n    # overlayer1 - 参数名用 self 与 super，表达继承关系\n    (self: super: {\n      google-chrome = super.google-chrome.override {\n        commandLineArgs =\n          \"--proxy-server='https=127.0.0.1:3128;http=127.0.0.1:3128'\";\n      };\n    })\n\n    # overlayer2 - 还可以使用 extend 来继承其他 overlay\n    # 这里改用 final 与 prev，表达新旧关系\n    (final: prev: {\n      steam = prev.steam.override {\n        extraPkgs = pkgs:\n          with pkgs; [\n            keyutils\n            libkrb5\n            libpng\n            libpulseaudio\n            libvorbis\n            stdenv.cc.cc.lib\n            xorg.libXcursor\n            xorg.libXi\n            xorg.libXinerama\n            xorg.libXScrnSaver\n          ];\n        extraProfile = \"export GDK_SCALE=2\";\n      };\n    })\n\n    # overlay3 - 也可以将 overlay 定义在其他文件中\n    # 这里 overlay3.nix 中的内容格式与上面的一致\n    # 都是 `final: prev: { xxx = prev.xxx.override { ... }; }`\n    (import ./overlays/overlay3.nix)\n  ];\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n这里只是个示例配置，参照此格式编写你自己的 overlays 配置，将该配置作为 NixOS Module 或者 Home Manager Module 引入，然后部署就可以看到效果了。\n\n模块化 overlays 配置\n​\n\n上面的例子说明了如何编写 overlays，但是所有 overlays 都一股脑儿写在一起，就有点难以维护了，写得多了自然就希望模块化管理这些 overlays.\n\n这里介绍下我找到的一个 overlays 模块化管理的最佳实践。\n\n首先在 Git 仓库中创建 overlays 文件夹用于存放所有 overlays 配置，然后创建 overlays/default.nix，其内容如下：\n\nnix\nargs:\n  # import 当前文件夹下所有的 nix 文件，并以 args 为参数执行它们\n  # 返回值是一个所有执行结果的列表，也就是 overlays 的列表\n  builtins.map\n  # map 的第一个参数，是一个 import 并执行 nix 文件的函数\n  (f: (import (./. + \"/${f}\") args))\n  # map 的第二个参数，它返回一个当前文件夹下除 default.nix 外所有 nix 文件的列表\n  (builtins.filter\n    (f: f != \"default.nix\")\n    (builtins.attrNames (builtins.readDir ./.)))\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n后续所有 overlays 配置都添加到 overlays 文件夹中，一个示例配置 overlays/fcitx5/default.nix 内容如下：\n\n这里参考了 https://github.com/NixOS/nixpkgs/blob/e4246ae1e7f78b7087dce9c9da10d28d3725025f/pkgs/tools/inputmethods/fcitx5/fcitx5-rime.nix\n\nnix\n# 为了不使用默认的 rime-data，改用我自定义的小鹤音形数据，这里需要 override\n{pkgs, config, lib, ...}:\n\n(self: super: {\n  # 小鹤音形配置，配置来自 flypy.com 官方网盘的\n  # 鼠须管配置压缩包「小鹤音形“鼠须管”for macOS.zip」\n  rime-data = ./rime-data-flypy;\n  fcitx5-rime = super.fcitx5-rime.override {\n    rimeDataPkgs = [ ./rime-data-flypy ];\n  };\n})\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n我通过上面这个 overlays 修改了 fcitx5-rime 输入法的默认数据，加载了我自定义的小鹤音形输入法。\n\n最后，还需要通过 nixpkgs.overlays 这个 option 加载 overlays/default.nix 返回的所有 overlays 配置，在任一 NixOS Module 中添加如下参数即可：\n\nnix\n{ config, pkgs, lib, ... } @ args:\n\n{\n  # ......\n\n  # 添加此参数\n  nixpkgs.overlays = import /path/to/overlays/dir;\n\n  # ......\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n比如说直接写 flake.nix 里：\n\nnix\n{\n  description = \"NixOS configuration of Ryan Yin\";\n\n  # ......\n\n  inputs = {\n    # ......\n  };\n\n  outputs = inputs@{ self, nixpkgs, ... }: {\n    nixosConfigurations = {\n      nixos-test = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n        specialArgs = inputs;\n        modules = [\n          ./hosts/nixos-test\n\n          # 添加如下内嵌 module 定义\n          #   这里将 modules 的所有参数 args 都传递到了 overlays 中\n          (args: { nixpkgs.overlays = import ./overlays args; })\n\n          # ......\n        ];\n      };\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n按照上述方法进行配置，就可以很方便地模块化管理所有 overlays 配置了，以我的配置为例，overlays 文件夹的结构大致如下：\n\nnix\n.\n├── flake.lock\n├── flake.nix\n├── home\n├── hosts\n├── modules\n├── ......\n├── overlays\n│   ├── default.nix         # 它返回一个所有 overlays 的列表\n│   └── fcitx5              # fcitx5 overlay\n│       ├── default.nix\n│       ├── README.md\n│       └── rime-data-flypy  # 自定义的 rime-data，需要遵循它的文件夹格式\n│           └── share\n│               └── rime-data\n│                   ├── ......  # rime-data 文件\n└── README.md\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n你可以在我的配置仓库 ryan4yin/nix-config/v0.0.4 查看更详细的内容，获取些灵感。\n\n参考\n​\nChapter 3. Overlays - nixpkgs Manual"
  },
  {
    "title": "多 nixpkgs 实例的妙用 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/nixpkgs/multiple-nixpkgs",
    "html": "多 nixpkgs 实例的妙用\n​\n\n我们在前面 降级与升级软件包 一节中见过，怎么通过 import nixpkgs {...} 这样的方法实例化多个不同的 nixpkgs 实例。 这种方法有很多的用途，常见的有：\n\n通过实例化 commit id 不同的 nixpkgs 实例，用于安装不同版本的软件包。前面的 降级与升级软件包 一节中就是这样使用的。\n如果希望使用 overlays，但是又不想影响到默认的 nixpkgs 实例，可以通过实例化一个新的 nixpkgs 实例，然后在这个实例上使用 overlays。\n上一节 Overlays 中提到的 nixpkgs.overlays = [...]; 是直接修改全局的 nixpkgs 实例，如果你的 overlays 改了比较底层的包，可能会影响到其他模块。坏处之一是会导致大量的本地编译（因为二进制缓存失效了），二是被影响的包功能可能也会出问题。\n在跨系统架构的编译中，你可以通过实例化多个 nixpkgs 实例来在不同的地方分别选用 QEMU 模拟编译与交叉编译，或者添加不同的 gcc 编译参数。\n\n总之，实例化多个 nixpkgs 实例是非常有用的。\n\nnixpkgs 的实例化\n​\n\n先看看如何实例化一个非全局的 nixpkgs 实例，最常见的语法是：\n\nnix\n{\n  # a simple example\n  pkgs-xxx = import nixpkgs {\n    system = \"x86_64-linux\";\n  };\n\n  # a more complex example(cross-compiling)\n  pkgs-yyy = import nixpkgs {\n    localSystem = \"x86_64-linux\";\n    crossSystem = {\n      config = \"riscv64-unknown-linux-gnu\";\n\n      # https://nixos.wiki/wiki/Build_flags\n      # this option equals to add `-march=rv64gc` into CFLAGS.\n      # CFLAGS will be used as the command line arguments for the gcc/clang.\n      gcc.arch = \"rv64gc\";\n      # the same as `-mabi=lp64d` in CFLAGS.\n      gcc.abi = \"lp64d\";\n    };\n\n    overlays = [\n      (self: super: {\n        google-chrome = super.google-chrome.override {\n          commandLineArgs =\n            \"--proxy-server='https=127.0.0.1:3128;http=127.0.0.1:3128'\";\n        };\n        # ... other overlays\n      })\n    ];\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n我们学习 Nix 语法时就学过：\n\nimport 表达式以其他 Nix 文件的路径作为参数，返回该 Nix 文件的执行结果。 import 的参数如果为文件夹路径，那么会返回该文件夹下的 default.nix 文件的执行结果。\n\nnixpkgs 是一个 Git 仓库，它的根目录下刚好有一个 default.nix 文件，那么答案就呼之欲出了：import nixpkgs 就是返回 nixpkgs/default.nix 文件的执行结果。 从这个文件开始探索，就能找到 import nixpkgs 的实现代码是 pkgs/top-level/impure.nix，这里截取部分内容：\n\nnix\n# ... skip some lines\n\n{ # We put legacy `system` into `localSystem`, if `localSystem` was not passed.\n  # If neither is passed, assume we are building packages on the current\n  # (build, in GNU Autotools parlance) platform.\n  localSystem ? { system = args.system or builtins.currentSystem; }\n\n# These are needed only because nix's `--arg` command-line logic doesn't work\n# with unnamed parameters allowed by ...\n, system ? localSystem.system\n, crossSystem ? localSystem\n\n, # Fallback: The contents of the configuration file found at $NIXPKGS_CONFIG or\n  # $HOME/.config/nixpkgs/config.nix.\n  config ? let\n  # ... skip some lines\n\n, # Overlays are used to extend Nixpkgs collection with additional\n  # collections of packages.  These collection of packages are part of the\n  # fix-point made by Nixpkgs.\n  overlays ? let\n  # ... skip some lines\n\n, crossOverlays ? []\n\n, ...\n} @ args:\n\n# If `localSystem` was explicitly passed, legacy `system` should\n# not be passed, and vice-versa.\nassert args ? localSystem -> !(args ? system);\nassert args ? system -> !(args ? localSystem);\n\nimport ./. (builtins.removeAttrs args [ \"system\" ] // {\n  inherit config overlays localSystem;\n})\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n因此 import nixpkgs {...} 实际就是调用了上面这个函数，后面的 attribute set 就是这个参数的参数。\n\n注意事项\n​\n\n在创建多 nixpkgs 实例的时候需要注意一些细节，这里列举一些常见的问题：\n\n根据 @fbewivpjsbsby 补充的文章 1000 instances of nixpkgs，在子模块或者子 flakes 中用 import 来定制 nixpkgs 不是一个好的习惯，因为每次 import 都会重新求值并产生一个新的 nixpkgs 实例，在配置越来越多时会导致构建时间变长、内存占用变大。所以这里改为了在 flake.nix 中创建所有 nixpkgs 实例。\n在混合使用 QEMU 模拟编译与交叉编译时，搞得不好可能会导致许多包被重复编译多次，要注意避免这种情况。"
  },
  {
    "title": "pkgs.callPackage | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/nixpkgs/callpackage",
    "html": "pkgs.callPackage\n​\n\npkgs.callPackage 被用于参数化构建 Nix 包，为了理解它的用处，我们首先考虑下不使用 pkgs.callPakcage 的情况下，我们要如何定义一个 Nix 包（也就是 Derivation）。\n\n1. 不使用 pkgs.callPackage 的情况\n​\n\n我们可以使用如下代码来定义一个 Nix 包：\n\nnix\npkgs.writeShellScriptBin \"hello\" ''echo \"hello, ryan!\"''\n1\n\n\n使用 nix repl 来验证一下，能看到它的执行结果确实是一个 Derivation：\n\nshell\n› nix repl -f '<nixpkgs>'\nWelcome to Nix 2.13.5. Type :? for help.\n\nLoading installable ''...\nAdded 19203 variables.\n\nnix-repl> pkgs.writeShellScriptBin \"hello\" '' echo \"hello, xxx!\" ''\n«derivation /nix/store/zhgar12vfhbajbchj36vbbl3mg6762s8-hello.drv»\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面这个 Derivation 的定义很短，就一行，但 nixpkgs 中大部分的 Derivation 的定义都要比这复杂很多。 前面我们介绍并大量使用了 import xxx.nix 来从其他 Nix 文件中导入 Nix 表达式，我们可以在这里也使用这种方法来提升代码的可维护性：\n\n将上面这一行 Derivation 的定义存放到单独的文件 hello.nix 中。\n但 hello.nix 自身的上下文中不包含 pkgs 这个变量，所以需要修改下其内容，将 pkgs 作为参数传递给 hello.nix。\n在需要使用这个 Derivation 的地方，使用 import ./hello.nix pkgs 来导入它并使用 pkgs 作为参数来执行其中定义的函数。\n\n仍然使用 nix repl 来验证一下，能看到它的执行结果仍然是一个 Derivation：\n\nshell\n› cat hello.nix          \npkgs:\n  pkgs.writeShellScriptBin \"hello\" '' echo \"hello, xxx!\" ''\n\n› nix repl -f '<nixpkgs>'\nWelcome to Nix 2.13.5. Type :? for help.\n\nwarning: Nix search path entry '/nix/var/nix/profiles/per-user/root/channels' does not exist, ignoring\nLoading installable ''...\nAdded 19203 variables.\n\nnix-repl> import ./hello.nix pkgs\n«derivation /nix/store/zhgar12vfhbajbchj36vbbl3mg6762s8-hello.drv»\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n2. 使用 pkgs.callPackage 的情况\n​\n\n在前面不使用 pkgs.callPackage 的例子中，我们直接将 pkgs 作为参数传到了 hello.nix 中，这样做的缺点有：\n\nhello 这个 derivation 的所有其他依赖项都只能从 pkgs 中获取，耦合度太高。\n比如说我们如果需要其他自定义依赖项，就必须修改 pkgs 或者修改 hello.nix 的内容，而这两个都很麻烦。\n在 hello.nix 变复杂的情况下，很难判断 hello.nix 到底依赖了 pkgs 中的哪些 Derivation，很难分析 Derivation 之间的依赖关系。\n\n而 pkgs.callPackage 作为一个参数化构建 Derivation 的工具函数，可解决上述两个问题。 首先看看源码中此函数的定义与注释 nixpkgs/lib/customisation.nix#L101-L121：\n\nnix\n  /* Call the package function in the file `fn` with the required\n    arguments automatically.  The function is called with the\n    arguments `args`, but any missing arguments are obtained from\n    `autoArgs`.  This function is intended to be partially\n    parameterised, e.g.,\n\n      callPackage = callPackageWith pkgs;\n      pkgs = {\n        libfoo = callPackage ./foo.nix { };\n        libbar = callPackage ./bar.nix { };\n      };\n\n    If the `libbar` function expects an argument named `libfoo`, it is\n    automatically passed as an argument.  Overrides or missing\n    arguments can be supplied in `args`, e.g.\n\n      libbar = callPackage ./bar.nix {\n        libfoo = null;\n        enableX11 = true;\n      };\n  */\n  callPackageWith = autoArgs: fn: args:\n    let\n      f = if lib.isFunction fn then fn else import fn;\n      fargs = lib.functionArgs f;\n\n      # All arguments that will be passed to the function\n      # This includes automatic ones and ones passed explicitly\n      allArgs = builtins.intersectAttrs fargs autoArgs // args;    \n\n    # ...... 省略后面的内容 ......\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n简单的说，它的使用格式是 pkgs.callPackage fn args，其中 fn 是一个 nix 文件或者函数，args 是一个 attribute set，它的工作流程是：\n\npkgs.callPackge fn args 会先判断 fn 是一个函数还是一个文件，如果是文件就先通过 import xxx.nix 导入其中定义的函数。\n第一步执行完毕得到的是一个函数，其参数通常会有 lib, stdenv, fetchurl 等参数，可能还会带有一些自定义参数。\n之后，pkgs.callPackge fn args 会将 args 与 pkgs 这个 attribute set 合并。如果存在冲突，args 中的参数会覆盖 pkgs 中的参数。\n再之后，pkgs.callPackge fn args 会从上一步得到的 attribute set 中提取出 fn 函数的参数，并使用它们来执行 fn 函数。\n函数执行结果是一个 Derivation，也就是一个 Nix 包。\n\n那可以作为 pkgs.callPackge 参数的 nix 文件具体长啥样呢，可以去看看我们前面在 Nixpkgs 高级用法 - 简介 中举例过的 hello.nix fcitx5-rime.nix vscode/with-extensions.nix firefox/common.nix，它们都可以被 pkgs.callPackage 导入。\n\n比如说我们自定义了一个 NixOS 内核配置 kernel.nix，并且将开发版名称与内核源码作为了可变更参数：\n\nnix\n{\n  lib,\n  stdenv,\n  linuxManualConfig,\n\n  src,\n  boardName,\n  ...\n}:\n(linuxManualConfig {\n  version = \"5.10.113-thead-1520\";\n  modDirVersion = \"5.10.113\";\n\n  inherit src lib stdenv;\n\n  # file path to the generated kernel config file(the `.config` generated by make menuconfig)\n  #\n  # here is a special usage to generate a file path from a string\n  configfile = ./. + \"${boardName}_config\";\n\n  allowImportFromDerivation = true;\n})\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n那么就可以在任意 Nix Module 中使用 pkgs.callPackage ./hello.nix {} 来导入并使用它，并且替换它的任意参数。\n\nnix\n{ lib, pkgs, pkgsKernel, kernel-src, ... }:\n\n{\n  # ......\n\n  boot = {\n    # ......\n    kernelPackages = pkgs.linuxPackagesFor (pkgs.callPackage ./pkgs/kernel {\n        src = kernel-src;  # kernel source is passed as a `specialArgs` and injected into this module.\n        boardName = \"licheepi4a\";  # the board name, used to generate the kernel config file path.\n    });\n\n  # ......\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n就如上面所展示的，通过 pkgs.callPackage 我们可以给 kernel.nix 定义的函数传入不同的 src 与 boardName，来生成不同的内核包，这样就可以使用同一份 kernel.nix 来适配不同的内核源码与不同的开发板了。\n\npkgs.callPackage 的优势在于：\n\nDerivation 的定义被参数化，定义中的所有函数参数就是 Derivation 的所有依赖项，这样就可以很方便的分析 Derivation 之间的依赖关系。\nDerivation 的所有依赖项与其他自定义参数都可以很方便地被替换（通过使用 pkgs.callPackage 的第二个参数），Derivation 定义的可复用性大大提升。\n在实现了前两条功能的情况下，并未增加代码的复杂度，所有 pkgs 中的依赖项都可以被自动注入，不需要手动传递。\n\n因此我们总是推荐使用 pkgs.callPackage 来定义 Derivation。\n\n参考\n​\nChapter 13. Callpackage Design Pattern - Nix Pills\ncallPackage, a tool for the lazy - The Summer of Nix\nDocument what callPackage does and its preconditions - Nixpkgs Issues"
  },
  {
    "title": "Nixpkgs 的高级用法 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/nixpkgs/intro",
    "html": "Nixpkgs 的高级用法\n​\n\ncallPackage、Overriding 与 Overlays 是在使用 Nix 时偶尔会用到的技术，它们都是用来自定义 Nix 包的构建方法的。\n\n我们知道许多程序都有大量构建参数需要配置，不同的用户会希望使用不同的构建参数，这时候就需要 Overriding 与 Overlays 来实现。我举几个我遇到过的例子：\n\nfcitx5-rime.nix: fcitx5-rime 的 rimeDataPkgs 默认使用 rime-data 包，但是也可以通过 override 来自定义该参数的值，以加载自定义的 rime 配置（比如加载小鹤音形输入法配置）。\nvscode/with-extensions.nix: vscode 的这个包也可以通过 override 来自定义 vscodeExtensions 参数的值来安装自定义插件。\nnix-vscode-extensions: 就是利用该参数实现的 vscode 插件管理\nfirefox/common.nix: firefox 同样有许多可自定义的参数\n等等\n\n总之如果需要自定义上述这类 Nix 包的构建参数，或者实施某些比较底层的修改，我们就得用到 callPackage、Overriding 与 Overlays 这些特性。"
  },
  {
    "title": "NixOS 的其他实用技巧 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/nixos-with-flakes/other-useful-tips",
    "html": "NixOS 的其他实用技巧\n​\n使用 Git 管理 NixOS 配置\n​\n\n这里不介绍 Git 本身的使用，如果不熟悉 Git 的话，可以先找资料学习一下 Git.\n\nNixOS 的配置文件是纯文本，因此跟普通的 dotfiles 一样可以使用 Git 管理，这样可以方便的回滚到历史版本，或者在多台机器上同步配置。\n\n需要注意的一点是：在使用 Git 管理配置后，任何未被提交且未添加到 Git 暂存区的修改都会被 Nix 忽略！因此在部署前请一定确认，你的修改已添加到了暂存区或者已经提交。\n\n此外 Nix Flakes 配置也不一定需要放在 /etc/nixos 目录下，可以放在任意目录下，只要在部署时指定正确的路径即可。\n\n我们在前面第 3 小节的代码注释中有说明过，可以通过 sudo nixos-rebuild switch --flake .#xxx 的 --flake 参数指定 Flakes 配置的文件夹路径，并通过 # 后面的值来指定使用的 outputs 名称。\n\n比如我的使用方式是将 Nix Flakes 配置放在 ~/nixos-config 目录下，然后在 /etc/nixos 目录下创建一个软链接：\n\nshell\nsudo mv /etc/nixos /etc/nixos.bak  # 备份原来的配置\nsudo ln -s ~/nixos-config/ /etc/nixos\n1\n2\n\n\n然后就可以在 ~/nixos-config 目录下使用 Git 管理配置了，配置使用普通的用户级别权限即可，不要求 owner 为 root.\n\n另一种方法是直接删除掉 /etc/nixos，并在每次部署时指定配置文件路径：\n\nshell\nsudo mv /etc/nixos /etc/nixos.bak  # 备份原来的配置\ncd ~/nixos-config\n\n# 通过 --flake .#nixos-test 参数指定使用当前文件夹的 flake.nix，\n# 使用的 nixosConfiguraitons 名称为 nixos-test\nsudo nixos-rebuild switch --flake .#nixos-test\n1\n2\n3\n4\n5\n6\n\n\n两种方式都可以，看个人喜好。搞定之后，系统的回滚也变得非常简单，只需要切换到上一个 commit 即可：\n\nshell\ncd ~/nixos-config\n# 回滚到上一个 commit\ngit checkout HEAD^1\n# 部署\nsudo nixos-rebuild switch --flake .#nixos-test\n1\n2\n3\n4\n5\n\n\nGit 的更多操作这里就不介绍了，总之一般情况下的回滚都能直接通过 Git 完成，只在系统完全崩溃的情况下，才需要通过重启进入 grub，从上一个历史版本启动系统。\n\n查看与清理历史数据\n​\n\n如前所述，NixOS 的每次部署都会生成一个新的版本，所有版本都会被添加到系统启动项中，除了重启电脑外，我们也可以通过如下命令查询当前可用的所有历史版本：\n\nshell\nnix profile history --profile /nix/var/nix/profiles/system\n1\n\n\n以及清理历史版本释放存储空间的命令：\n\nshell\n# 清理 7 天之前的所有历史版本\nsudo nix profile wipe-history --older-than 7d --profile /nix/var/nix/profiles/system\n# 清理历史版本并不会删除数据，还需要手动 gc 下\nsudo nix store gc --debug\n1\n2\n3\n4\n\n\n以及查看系统层面安装的所有软件包（这个貌似只能用 nix-env）：\n\nshell\nnix-env -qa\n1\n\n节约存储空间\n​\n\n如下配置可以比较好的缩减 NixOS 的磁盘占用，可以考虑将它们添加到你的 NixOS 配置中：\n\nnix\n{ lib, pkgs, ... }:\n\n{\n  # ......\n\n  # do not need to keep too much generations\n  boot.loader.systemd-boot.configurationLimit = 10;\n  # boot.loader.grub.configurationLimit = 10;\n\n  # do garbage collection weekly to keep disk usage low\n  nix.gc = {\n    automatic = true;\n    dates = \"weekly\";\n    options = \"--delete-older-than 1w\";\n  };\n\n  # Optimise storage\n  # you can alse optimise the store manually via:\n  #    nix-store --optimise\n  # https://nixos.org/manual/nix/stable/command-ref/conf-file.html#conf-auto-optimise-store\n  nix.settings.auto-optimise-store = true;\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n"
  },
  {
    "title": "降级与升级软件包 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/nixos-with-flakes/downgrade-or-upgrade-packages",
    "html": "降级与升级软件包\n​\n\n在使用 Nix Flakes 后，目前大家用得比较多的都是 nixos-unstable 分支的 nixpkgs，有时候就会遇到一些 bug，比如我最近（2023/5/6）就遇到了 chrome/vscode 闪退的问题。\n\n这时候就需要退回到之前的版本，在 Nix Flakes 中，所有的包版本与 hash 值与其 input 数据源的 git commit 是一一对应的关系，因此回退某个包的到历史版本，就需要锁定其 input 数据源的 git commit.\n\n为了实现上述需求，首先修改 /etc/nixos/flake.nix，示例内容如下（主要是利用 specialArgs 参数）：\n\nnix\n{\n  description = \"NixOS configuration of Ryan Yin\"\n\n  inputs = {\n    # 默认使用 nixos-unstable 分支\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n\n    # 最新 stable 分支的 nixpkgs，用于回退个别软件包的版本\n    # 当前最新版本为 23.05\n    nixpkgs-stable.url = \"github:nixos/nixpkgs/nixos-23.05\";\n\n    # 另外也可以使用 git commit hash 来锁定版本，这是最彻底的锁定方式\n    nixpkgs-fd40cef8d.url = \"github:nixos/nixpkgs/fd40cef8d797670e203a27a91e4b8e6decf0b90c\";\n  };\n\n  outputs = inputs@{\n    self,\n    nixpkgs,\n    nixpkgs-stable,\n    nixpkgs-fd40cef8d,\n    ...\n  }: {\n    nixosConfigurations = {\n      nixos-test = nixpkgs.lib.nixosSystem rec {\n        system = \"x86_64-linux\";\n\n        # 核心参数是这个，将非默认的 nixpkgs 数据源传到其他 modules 中\n        specialArgs = {\n          # 注意每次 import 都会生成一个新的 nixpkgs 实例\n          # 这里我们直接在 flake.nix 中创建实例， 再传递到其他子 modules 中使用\n          # 这样能有效重用 nixpkgs 实例，避免 nixpkgs 实例泛滥。\n          pkgs-stable = import nixpkgs-stable {\n            # 这里递归引用了外部的 system 属性\n            system = system;\n            # 为了拉取 chrome 等软件包，\n            # 这里我们需要允许安装非自由软件\n            config.allowUnfree = true;\n          };\n\n          pkgs-fd40cef8d = import nixpkgs-fd40cef8d {\n            system = system;\n            config.allowUnfree = true;\n          };\n        };\n        modules = [\n          ./hosts/nixos-test\n\n          # 省略其他模块配置...\n        ];\n      };\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n然后在你对应的 module 中使用该数据源中的包，一个 Home Manager 的子模块示例：\n\nnix\n{\n  pkgs,\n  config,\n\n  # nix 会从 flake.nix 的 specialArgs 查找并注入此参数\n  pkgs-stable,\n  # pkgs-fd40cef8d,  # 也可以使用固定 hash 的 nixpkgs 数据源\n  ...\n}:\n\n{\n  # # 这里从 pkg-stable 中引用包（而不是默认的 pkgs）\n  home.packages = with pkgs-stable; [\n    firefox-wayland\n\n    # nixos-unstable 分支中的 Chrome Wayland 支持目前存在问题，\n    # 因此这里我们将 google-chrome 回滚到 stable 分支，临时解决下 bug.\n    # 相关 Issue: https://github.com/swaywm/sway/issues/7562\n    google-chrome\n  ];\n\n  programs.vscode = {\n    enable = true;\n    # 这里也一样，从 pkgs-stable 中引用包\n    package = pkgs-stable.vscode;\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n配置完成后，通过 sudo nixos-rebuild switch 部署即可将 firefox/chrome/vscode 三个软件包回退到 stable 分支的版本。\n\n根据 @fbewivpjsbsby 补充的文章 1000 instances of nixpkgs，在子模块或者子 flakes 中用 import 来定制 nixpkgs 不是一个好的习惯，因为每次 import 都会重新求值并产生一个新的 nixpkgs 实例，在配置越来越多时会导致构建时间变长、内存占用变大。所以这里改为了在 flake.nix 中创建所有 nixpkgs 实例。"
  },
  {
    "title": "更新系统 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/nixos-with-flakes/update-the-system",
    "html": "更新系统\n​\n\n在使用了 Nix Flakes 后，要更新系统也很简单，先更新 flake.lock 文件，然后部署即可。在配置文件夹中执行如下命令：\n\nshell\n# 更新 flake.lock\nnix flake update\n# 部署系统\nsudo nixos-rebuild switch --flake .\n1\n2\n3\n4\n\n\n另外有时候安装新的包，跑 sudo nixos-rebuild switch 时可能会遇到 sha256 不匹配的报错，也可以尝试通过 nix flake update 更新 flake.lock 来解决（原理暂时不太清楚）。"
  },
  {
    "title": "模块化 NixOS 配置 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/nixos-with-flakes/modularize-the-configuration",
    "html": "模块化 NixOS 配置\n​\n\n到这里整个系统的骨架基本就配置完成了，当前我们 /etc/nixos 中的系统配置结构应该如下：\n\n$ tree\n.\n├── flake.lock\n├── flake.nix\n├── home.nix\n└── configuration.nix\n1\n2\n3\n4\n5\n6\n\n\n下面分别说明下这四个文件的功能：\n\nflake.lock: 自动生成的版本锁文件，它记录了整个 flake 所有输入的数据源、hash 值、版本号，确保系统可复现。\nflake.nix: 入口文件，执行 sudo nixos-rebuild switch 时会识别并部署它。\nconfiguration.nix: 在 flake.nix 中被作为系统模块导入，目前所有系统级别的配置都写在此文件中。\n此配置文件中的所有配置项，参见官方文档 Configuration - NixOS Manual\nhome.nix: 在 flake.nix 中被 home-manager 作为 ryan 用户的配置导入，也就是说它包含了 ryan 这个用户的所有 Home Manager 配置，负责管理其 Home 文件夹。\n此配置文件的所有配置项，参见 Appendix A. Configuration Options - Home Manager\n\n通过修改上面几个配置文件就可以实现对系统与 Home 目录状态的修改。 但是随着配置的增多，单纯依靠 configuration.nix 跟 home.nix 会导致配置文件臃肿，难以维护。 更好的解决方案是通过 Nix 的模块机制，将配置文件拆分成多个模块，分门别类地编写维护。\n\n在前面的 Nix 语法一节有介绍过：「import 的参数如果为文件夹路径，那么会返回该文件夹下的 default.nix 文件的执行结果」，实际 Nix 还提供了一个 imports 参数，它可以接受一个 .nix 文件列表，并将该列表中的所有配置合并（Merge）到当前的 attribute set 中。注意这里的用词是「合并」，它表明 imports 如果遇到重复的配置项，不会简单地按执行顺序互相覆盖，而是更合理地处理。比如说我在多个 modules 中都定义了 program.packages = [...]，那么 imports 会将所有 modules 中的 program.packages 这个 list 合并。不仅 list 能被正确合并，attribute set 也能被正确合并，具体行为各位看官可以自行探索。\n\n我只在 nixpkgs-unstable 官方手册 - evalModules parameters 中找到一句关于 imports 的描述：A list of modules. These are merged together to form the final configuration.，可以意会一下...（Nix 的文档真的一言难尽...这么核心的参数文档就这么一句...）\n\n我们可以借助 imports 参数，将 home.nix 与 configuration.nix 拆分成多个 .nix 文件。\n\n推荐一个非常好的模块化配置的例子，可以参考一下：\n\nMisterio77/nix-starter-configs\n\n再举个更复杂一点的例子，如下是我之前 i3wm 配置的目录结构 ryan4yin/nix-config/i3-kickstarter：\n\nshell\n├── flake.lock\n├── flake.nix\n├── home\n│   ├── default.nix         # 在这里通过 imports = [...] 导入所有子模块\n│   ├── fcitx5              # fcitx5 中文输入法设置，我使用了自定义的小鹤音形输入法\n│   │   ├── default.nix\n│   │   └── rime-data-flypy\n│   ├── i3                  # i3wm 桌面配置\n│   │   ├── config\n│   │   ├── default.nix\n│   │   ├── i3blocks.conf\n│   │   ├── keybindings\n│   │   └── scripts\n│   ├── programs\n│   │   ├── browsers.nix\n│   │   ├── common.nix\n│   │   ├── default.nix   # 在这里通过 imports = [...] 导入 programs 目录下的所有 nix 文件\n│   │   ├── git.nix\n│   │   ├── media.nix\n│   │   ├── vscode.nix\n│   │   └── xdg.nix\n│   ├── rofi              #  rofi 应用启动器配置，通过 i3wm 中配置的快捷键触发\n│   │   ├── configs\n│   │   │   ├── arc_dark_colors.rasi\n│   │   │   ├── arc_dark_transparent_colors.rasi\n│   │   │   ├── power-profiles.rasi\n│   │   │   ├── powermenu.rasi\n│   │   │   ├── rofidmenu.rasi\n│   │   │   └── rofikeyhint.rasi\n│   │   └── default.nix\n│   └── shell             # shell 终端相关配置\n│       ├── common.nix\n│       ├── default.nix\n│       ├── nushell\n│       │   ├── config.nu\n│       │   ├── default.nix\n│       │   └── env.nu\n│       ├── starship.nix\n│       └── terminals.nix\n├── hosts\n│   ├── msi-rtx4090      # PC 主机的配置\n│   │   ├── default.nix                 # 这就是之前的 configuration.nix，不过大部分内容都拆出到 modules 了\n│   │   └── hardware-configuration.nix  # 与系统硬件相关的配置，安装 nixos 时自动生成的\n│   └── nixos-test       # 测试用的虚拟机配置\n│       ├── default.nix\n│       └── hardware-configuration.nix\n├── modules          # 从 configuration.nix 中拆分出的一些通用配置\n│   ├── i3.nix\n│   └── system.nix\n└── wallpaper.jpg    # 桌面壁纸，在 i3wm 配置中被引用\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\nNix Flakes 对目录结构没有任何要求，你可以参考上面的例子，摸索出适合你自己的目录结构。其中关键点就是通过 imports 参数导入其他 .nix 文件。\n\nlib.mkOverride, lib.mkDefault and lib.mkForce\n​\n\n你可能会发现有些人在 Nix 文件中使用 lib.mkDefault lib.mkForce 来定义值，顾名思义，lib.mkDefault 和 lib.mkForce 用于设置选项的默认值，或者强制设置选项的值。\n\n直接这么说可能不太好理解，官方文档也没啥对这几个函数的详细解释，最直接的理解方法，是看源码。\n\n开个新窗口，输入命令 nix repl -f '<nixpkgs>' 进入 REPL 解释器，然后输入 :e lib.mkDefault，就可以看到 lib.mkDefault 的源码了（不太懂 :e 是干啥的？请直接输入 :? 查看帮助信息学习下）。\n\n源码截取如下：\n\nnix\n  # ......\n\n  mkOverride = priority: content:\n    { _type = \"override\";\n      inherit priority content;\n    };\n\n  mkOptionDefault = mkOverride 1500; # priority of option defaults\n  mkDefault = mkOverride 1000; # used in config sections of non-user modules to set a default\n  mkImageMediaOverride = mkOverride 60; # image media profiles can be derived by inclusion into host config, hence needing to override host config, but do allow user to mkForce\n  mkForce = mkOverride 50;\n  mkVMOverride = mkOverride 10; # used by ‘nixos-rebuild build-vm’\n\n  # ......\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n所以 lib.mkDefault 就是用于设置选项的默认值，它的优先级是 1000，而 lib.mkForce 则用于强制设置选项的值，它的优先级是 50。 如果你直接设置选项的值，那么它的优先级就是 1000（和 lib.mkDefault 一样）。\n\npriority 的值越低，它实际的优先级就越高，所以 lib.mkForce 的优先级比 lib.mkDefault 高。 而如果你定义了多个优先级相同的值，Nix 会报错说存在参数冲突，需要你手动解决。\n\n这几个函数在模块化 NixOS 配置中非常有用，因为你可以在低层级的模块（base module）中设置默认值，然后在高层级的模块（high-level module）中设置优先级更高的值。\n\n举个例子，我在这里定义了一个默认值：https://github.com/ryan4yin/nix-config/blob/c515ea9/modules/nixos/core-server.nix#L32\n\nnix\n{ lib, pkgs, ... }:\n\n{\n  # ......\n\n  nixpkgs.config.allowUnfree = lib.mkDefault false;\n\n  # ......\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n然后在桌面机器的配置中，我强制覆盖了默认值： https://github.com/ryan4yin/nix-config/blob/c515ea9/modules/nixos/core-desktop.nix#L18\n\nnix\n{ lib, pkgs, ... }:\n\n{\n  # 导入 base module\n  imports = [\n    ./core-server.nix\n  ];\n\n  # 覆盖 base module 中定义的默认值\n  nixpkgs.config.allowUnfree = lib.mkForce true;\n\n  # ......\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\nlib.mkOrder, lib.mkBefore 与 lib.mkAfter\n​\n\nlib.mkBefore 跟 lib.mkAfter 用于设置列表类型的合并顺序，它们跟 lib.mkDefault 和 lib.mkForce 一样，也被用于模块化配置。\n\n前面说了如果你定义了多个优先级相同的值，Nix 会报错说存在参数冲突，需要你手动解决。\n\n但是如果你定义的是列表类型的值，Nix 就不会报错了，因为 Nix 会把你定义的多个值合并成一个列表，而 lib.mkBefore 跟 lib.mkAfter 就是用于设置这个列表的合并顺序的。\n\n还是先来看看源码，开个终端键入 nix repl -f '<nixpkgs>' 进入 REPL 解释器，然后输入 :e lib.mkBefore，就可以看到 lib.mkBefore 的源码了（不太懂 :e 是干啥的？请直接输入 :? 查看帮助信息学习下）。\n\nnix\n  # ......\n\n  mkOrder = priority: content:\n    { _type = \"order\";\n      inherit priority content;\n    };\n\n  mkBefore = mkOrder 500;\n  mkAfter = mkOrder 1500;\n\n  # The default priority for things that don't have a priority specified.\n  defaultPriority = 100;\n\n  # ......\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n能看到 lib.mkBefore 只是个 lib.mkOrder 500 的别名，而 lib.mkAfter 则是个 lib.mkOrder 1500 的别名。\n\n为了更直观地理解这两个函数，现在来创建一个 flake 测试下：\n\nshell\n# 使用如下内容创建一个 flake.nix 文件\n› cat <<EOF | sudo tee flake.nix\n{\n  description = \"Ryan's NixOS Flake\";\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-23.05\";\n  };\n\n  outputs = { self, nixpkgs, ... }@inputs: {\n    nixosConfigurations = {\n      \"nixos-test\" = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n\n        modules = [\n          # demo module 1, 在列表头插入 git\n          ({lib, pkgs, ...}: {\n            environment.systemPackages = lib.mkBefore [pkgs.git];\n          })\n\n          # demo module 2, 在列表尾插入 vim\n          ({lib, pkgs, ...}: {\n            environment.systemPackages = lib.mkAfter [pkgs.vim];\n          })\n\n          # demo module 3, 添加 curl，但是不设置优先级\n          ({lib, pkgs, ...}: {\n            environment.systemPackages = with pkgs; [curl];\n          })\n        ];\n      };\n    };\n  };\n}\nEOF\n\n# 生成 flake.lock\n› nix flake update\n\n# 进入 nix REPL 解释器\n› nix repl\nWelcome to Nix 2.13.3. Type :? for help.\n\n# 将我们刚刚创建好的 flake 加载到当前作用域中\nnix-repl> :lf .\nAdded 9 variables.\n\n# 检查下 systemPackages 的顺序，看看跟我们预期的是否一致\nnix-repl> outputs.nixosConfigurations.nixos-test.config.environment.systemPackages\n[ «derivation /nix/store/0xvn7ssrwa0ax646gl4hwn8cpi05zl9j-git-2.40.1.drv»\n  «derivation /nix/store/7x8qmbvfai68sf73zq9szs5q78mc0kny-curl-8.1.1.drv»\n  «derivation /nix/store/bly81l03kh0dfly9ix2ysps6kyn1hrjl-nixos-container.drv»\n  ......\n  ......\n  «derivation /nix/store/qpmpvq5azka70lvamsca4g4sf55j8994-vim-9.0.1441.drv» ]\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n能看到 systemPackages 的顺序是 git -> curl -> default packages -> vim，跟我们预期的一致。lib.mkBefore [pkgs.git] 确实是将 git 插入到了列表头，而 lib.mkAfter [pkgs.vim] 则是将 vim 插入到了列表尾。\n\n虽然单纯调整 systemPackages 的顺序没什么用，但是在其他地方可能会有用...\n\nReferences\n​\nNix modules: Improving Nix's discoverability and usability\nModule System - Nixpkgs\nMisterio77/nix-starter-configs"
  },
  {
    "title": "安装使用 Home Manager | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/nixos-with-flakes/start-using-home-manager",
    "html": "安装使用 Home Manager\n​\n\n前面简单提过，NixOS 自身的配置文件只能管理系统级别的配置，而用户级别的配置则需要使用 home-manager 来管理。\n\n根据官方文档 Home Manager Manual，要将 home manager 作为 NixOS 模块安装，首先需要创建 /etc/nixos/home.nix，配置方法如下：\n\nnix\n{ config, pkgs, ... }:\n\n{\n  # 注意修改这里的用户名与用户目录\n  home.username = \"ryan\";\n  home.homeDirectory = \"/home/ryan\";\n\n  # 直接将当前文件夹的配置文件，链接到 Home 目录下的指定位置\n  # home.file.\".config/i3/wallpaper.jpg\".source = ./wallpaper.jpg;\n\n  # 递归将某个文件夹中的文件，链接到 Home 目录下的指定位置\n  # home.file.\".config/i3/scripts\" = {\n  #   source = ./scripts;\n  #   recursive = true;   # 递归整个文件夹\n  #   executable = true;  # 将其中所有文件添加「执行」权限\n  # };\n\n  # 直接以 text 的方式，在 nix 配置文件中硬编码文件内容\n  # home.file.\".xxx\".text = ''\n  #     xxx\n  # '';\n\n  # 设置鼠标指针大小以及字体 DPI（适用于 4K 显示器）\n  xresources.properties = {\n    \"Xcursor.size\" = 16;\n    \"Xft.dpi\" = 172;\n  };\n\n  # git 相关配置\n  programs.git = {\n    enable = true;\n    userName = \"Ryan Yin\";\n    userEmail = \"xiaoyin_c@qq.com\";\n  };\n\n  # 通过 home.packages 安装一些常用的软件\n  # 这些软件将仅在当前用户下可用，不会影响系统级别的配置\n  # 建议将所有 GUI 软件，以及与 OS 关系不大的 CLI 软件，都通过 home.packages 安装\n  home.packages = with pkgs;[\n    # 如下是我常用的一些命令行工具，你可以根据自己的需要进行增删\n    neofetch\n    nnn # terminal file manager\n\n    # archives\n    zip\n    xz\n    unzip\n    p7zip\n\n    # utils\n    ripgrep # recursively searches directories for a regex pattern\n    jq # A lightweight and flexible command-line JSON processor\n    yq-go # yaml processer https://github.com/mikefarah/yq\n    exa # A modern replacement for ‘ls’\n    fzf # A command-line fuzzy finder\n\n    # networking tools\n    mtr # A network diagnostic tool\n    iperf3\n    dnsutils  # `dig` + `nslookup`\n    ldns # replacement of `dig`, it provide the command `drill`\n    aria2 # A lightweight multi-protocol & multi-source command-line download utility\n    socat # replacement of openbsd-netcat\n    nmap # A utility for network discovery and security auditing\n    ipcalc  # it is a calculator for the IPv4/v6 addresses\n\n    # misc\n    cowsay\n    file\n    which\n    tree\n    gnused\n    gnutar\n    gawk\n    zstd\n    gnupg\n\n    # nix related\n    #\n    # it provides the command `nom` works just like `nix`\n    # with more details log output\n    nix-output-monitor\n\n    # productivity\n    hugo # static site generator\n    glow # markdown previewer in terminal\n\n    btop  # replacement of htop/nmon\n    iotop # io monitoring\n    iftop # network monitoring\n\n    # system call monitoring\n    strace # system call monitoring\n    ltrace # library call monitoring\n    lsof # list open files\n\n    # system tools\n    sysstat\n    lm_sensors # for `sensors` command\n    ethtool\n    pciutils # lspci\n    usbutils # lsusb\n  ];\n\n  # 启用 starship，这是一个漂亮的 shell 提示符\n  programs.starship = {\n    enable = true;\n    # 自定义配置\n    settings = {\n      add_newline = false;\n      aws.disabled = true;\n      gcloud.disabled = true;\n      line_break.disabled = true;\n    };\n  };\n\n  # alacritty - 一个跨平台终端，带 GPU 加速功能\n  programs.alacritty = {\n    enable = true;\n    # 自定义配置\n    settings = {\n      env.TERM = \"xterm-256color\";\n      font = {\n        size = 12;\n        draw_bold_text_with_bright_colors = true;\n      };\n      scrolling.multiplier = 5;\n      selection.save_to_clipboard = true;\n    };\n  };\n\n  programs.bash = {\n    enable = true;\n    enableCompletion = true;\n    # TODO 在这里添加你的自定义 bashrc 内容\n    bashrcExtra = ''\n      export PATH=\"$PATH:$HOME/bin:$HOME/.local/bin:$HOME/go/bin\"\n    '';\n\n    # TODO 设置一些别名方便使用，你可以根据自己的需要进行增删\n    shellAliases = {\n      k = \"kubectl\";\n      urldecode = \"python3 -c 'import sys, urllib.parse as ul; print(ul.unquote_plus(sys.stdin.read()))'\";\n      urlencode = \"python3 -c 'import sys, urllib.parse as ul; print(ul.quote_plus(sys.stdin.read()))'\";\n    };\n  };\n\n  # This value determines the Home Manager release that your\n  # configuration is compatible with. This helps avoid breakage\n  # when a new Home Manager release introduces backwards\n  # incompatible changes.\n  #\n  # You can update Home Manager without changing this value. See\n  # the Home Manager release notes for a list of state version\n  # changes in each release.\n  home.stateVersion = \"23.05\";\n\n  # Let Home Manager install and manage itself.\n  programs.home-manager.enable = true;\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n\n\n添加好 /etc/nixos/home.nix 后，还需要在 /etc/nixos/flake.nix 中导入该配置，它才能生效，可以使用如下命令，在当前文件夹中生成一个示例配置以供参考：\n\nshell\nnix flake new example -t github:nix-community/home-manager#nixos\n1\n\n\n调整好参数后的 /etc/nixos/flake.nix 内容示例如下：\n\nnix\n{\n  description = \"NixOS configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    home-manager.url = \"github:nix-community/home-manager\";\n    home-manager.inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  outputs = inputs@{ nixpkgs, home-manager, ... }: {\n    nixosConfigurations = {\n      # 这里的 nixos-test 替换成你的主机名称\n      nixos-test = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n        modules = [\n          ./configuration.nix\n\n          # 将 home-manager 配置为 nixos 的一个 module\n          # 这样在 nixos-rebuild switch 时，home-manager 配置也会被自动部署\n          home-manager.nixosModules.home-manager\n          {\n            home-manager.useGlobalPkgs = true;\n            home-manager.useUserPackages = true;\n\n            # 这里的 ryan 也得替换成你的用户名\n            # 这里的 import 函数在前面 Nix 语法中介绍过了，不再赘述\n            home-manager.users.ryan = import ./home.nix;\n\n            # 使用 home-manager.extraSpecialArgs 自定义传递给 ./home.nix 的参数\n            # 取消注释下面这一行，就可以在 home.nix 中使用 flake 的所有 inputs 参数了\n            # home-manager.extraSpecialArgs = inputs;\n          }\n        ];\n      };\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n然后执行 sudo nixos-rebuild switch 应用配置，即可完成 home-manager 的安装。\n\n安装完成后，所有用户级别的程序、配置，都可以通过 /etc/nixos/home.nix 管理，并且执行 sudo nixos-rebuild switch 时也会自动应用 home-manager 的配置。\n\nhome.nix 中 Home Manager 的配置项有这几种查找方式：\n\nHome Manager - Appendix A. Configuration Options: 一份包含了所有配置项的列表，建议在其中关键字搜索。\nHome Manager Option Search: 一个更方便的 option 搜索工具。\nhome-manager: 有些配置项在官方文档中没有列出，或者文档描述不够清晰，可以直接在这份 home-manager 的源码中搜索阅读对应的源码。\nHome Manager vs NixOS\n​\n\n有许多的软件包或者软件配置, 既可以使用 NixOS Module 配置(configuration.nix)，也可以使用 Home Manager 配置(home.nix), 这带来一个选择难题: 将软件包或者配置文件写在 NixOS Module 里还是 Homa Manager 配置里面有何区别? 该如何决策?\n\n首先看看区别, NixOS Module 中安装的软件包跟配置文件都是整个系统全局的, 全局的配置通常会被存放在 /etc 中, 而全局的软件也通常被链接到全局. 不论切换到哪个用户下, 都能正常使用该软件或配置.\n\n而 Home Manager 安装的所有东西, 都仅在对应的用户下可用, 切换到其他用户后这些配置跟软件就都失效了.\n\n根据这种特性, 一般的推荐用法是:\n\nNixOS Module: 安装系统的核心组件, 以及所有用户都需要用到的其他软件包或配置\n比如说如果你希望某个软件包能在你切换到 root 用户时仍能正常使用, 或者使某个配置能在系统全局生效, 那就得用 NixOS Module 来安装它\nHome Manager: 其他所有的配置与软件, 都建议用 Home Manager 来安装\n如何以特权身份使用 Home Manager 安装的软件包?\n​\n\n对这个问题，首先想到的一般都是直接切换到 root 用户, 可切换用户后，当前用户通过 home.nix 安装的软件包都将不可用。 让我们以 kubectl 为例（已通过 home.nix 预先安装好），来演示一下:\n\nsh\n# 1. kubectl 当前可用\n› kubectl | head\nkubectl controls the Kubernetes cluster manager.\n\n Find more information at: https://kubernetes.io/docs/reference/kubectl/\n......\n\n# 2. 切换到 `root` 用户\n› sudo su\n\n# 3. kubectl 不再可用，报错找不到它\n> kubectl\nError: nu::shell::external_command\n\n  × External command failed\n   ╭─[entry #1:1:1]\n 1 │ kubectl\n   · ───┬───\n   ·    ╰── executable was not found\n   ╰────\n  help: No such file or directory (os error 2)\n\n\n/home/ryan/nix-config> exit\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n但是，我们可以通过 sudo 命令，临时授予当前用户访问系统资源的特权，从而在不切换到 root 用户的情况下，使用 home.nix 安装的软件包:\n\nsh\n› sudo kubectl\nkubectl controls the Kubernetes cluster manager.\n...\n1\n2\n3\n"
  },
  {
    "title": "使用 Flakes 来管理你的 NixOS | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/nixos-with-flakes/nixos-with-flakes-enabled",
    "html": "使用 Flakes 来管理你的 NixOS\n​\n启用 NixOS 的 Flakes 支持\n​\n\n与 NixOS 默认的配置方式相比，Nix Flakes 提供了更好的可复现性，同时它清晰的包结构定义原生支持了以其他 Git 仓库为依赖，便于代码分享，因此更建议使用 Nix Flakes 来管理系统配置。\n\n但是目前 Nix Flakes 作为一个实验性的功能，仍未被默认启用。所以我们需要手动启用它，修改 /etc/nixos/configuration.nix 文件，在函数块中启用 flakes 与 nix-command 功能：\n\nnix\n# Edit this configuration file to define what should be installed on\n# your system.  Help is available in the configuration.nix(5) man page\n# and in the NixOS manual (accessible by running ‘nixos-help’).\n{ config, pkgs, ... }:\n\n{\n  imports =\n    [ # Include the results of the hardware scan.\n      ./hardware-configuration.nix\n    ];\n\n  # 省略掉前面的配置......\n\n  # 启用 Nix Flakes 功能，以及配套的新 nix-command 命令行工具\n  nix.settings.experimental-features = [ \"nix-command\" \"flakes\" ];\n\n  environment.systemPackages = with pkgs; [\n    git  # Nix Flakes 通过 git 命令从数据源拉取依赖，所以必须先安装好 git\n    vim\n    wget\n    curl\n  ];\n  # 将默认编辑器设置为 vim\n  environment.variables.EDITOR = \"vim\";\n\n  # 省略其他配置......\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n然后运行 sudo nixos-rebuild switch 应用修改后，即可使用 Nix Flakes 来管理系统配置。\n\n额外还有个好处就是，现在你可以通过 nix repl 打开一个 nix 交互式环境，有兴趣的话，可以使用它复习测试一遍前面学过的所有 Nix 语法。\n\n将系统配置切换到 flake.nix\n​\n\n在启用了 Nix Flakes 特性后，sudo nixos-rebuild switch 命令会优先读取 /etc/nixos/flake.nix 文件，如果找不到再尝试使用 /etc/nixos/configuration.nix。\n\n可以首先使用官方提供的模板来学习 flake 的编写，先查下有哪些模板：\n\nbash\nnix flake show templates\n1\n\n\n其中有个 templates#full 模板展示了所有可能的用法，可以看看它的内容：\n\nbash\nnix flake init -t templates#full\ncat flake.nix\n1\n2\n\n\n我们参照该模板创建文件 /etc/nixos/flake.nix 并编写好配置内容，后续系统的所有修改都将全部由 Nix Flakes 接管，示例内容如下：\n\nnix\n{\n  description = \"Ryan's NixOS Flake\";\n\n  # 这是 flake.nix 的标准格式，inputs 是 flake 的依赖，outputs 是 flake 的输出\n  # inputs 中的每一项依赖都会在被拉取、构建后，作为参数传递给 outputs 函数\n  inputs = {\n    # flake inputs 有很多种引用方式，应用最广泛的格式是:\n    #     github:owner/name/reference\n    # 即 github 仓库地址 + branch/commit-id/tag\n\n    # NixOS 官方软件源，这里使用 nixos-unstable 分支\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n    # home-manager，用于管理用户配置\n    home-manager = {\n      url = \"github:nix-community/home-manager/release-23.05\";\n      # `follows` 是 inputs 中的继承语法\n      # 这里使 sops-nix 的 `inputs.nixpkgs` 与当前 flake 的\n      # `inputs.nixpkgs` 保持一致，避免依赖的 nixpkgs 版本不一致导致问题\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n\n  # outputs 即 flake 的所有输出，其中的 nixosConfigurations 即 NixOS 系统配置\n  # flake 有很多用途，也可以有很多不同的 outputs，nixosConfigurations 只是其中一种\n  #\n  # outputs 是一个函数，它的参数都在 inputs 中定义，可以通过 inputs 中定义的\n  # 名称来引用。\n  # 比如这里的输入参数 `nixpkgs`，就是上面 inputs 中的 `nixpkgs`\n  # 不过 self 是个例外，这个特殊参数指向 outputs 自身（自引用），以及 flake 根目录\n  # 这里的 @ 语法将函数的参数 attribute set 取了个别名，方便在内部使用\n  outputs = { self, nixpkgs, ... }@inputs: {\n    # 名为 nixosConfigurations 的 outputs 会在执行\n    # `sudo nixos-rebuild switch` 时被使用\n    # 默认情况下上述命令会使用与主机 hostname 同名的 nixosConfigurations\n    # 但是也可以通过 `--flake /path/to/flake/direcotry#nixos-test` 来指定\n    # 在 flakes 配置文件夹中执行如下命令即可部署此配置：\n    #     sudo nixos-rebuild switch --flake .#nixos-test\n    # 其中 --flake 后的参数简要说明如下：\n    #   1. `.` 表示使用当前文件夹的 Flakes 配置，\n    #   2. `#` 后面的内容则是 nixosConfigurations 的名称\n    nixosConfigurations = {\n      # hostname 为 nixos-test 的主机会使用这个配置\n      # 这里使用了 nixpkgs.lib.nixosSystem 函数来构建配置，\n      # 后面的 attributes set 是它的参数，在 nixos 系统上使用如下命令即可部署此配置：\n      #     nixos-rebuild switch --flake .#nixos-test\n      \"nixos-test\" = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n\n        # Nix 模块系统可将配置模块化，提升配置的可维护性\n        #\n        # modules 中每个参数，都是一个 Nix Module\n        # nixpkgs manual 中有半份介绍它的文档：\n        #   <https://nixos.org/manual/nixpkgs/unstable/#module-system-introduction>\n        # 说半份是因为它的文档不全，只有一些简单的介绍（Nix 文档现状...）\n        #\n        # Nix Module 可以是一个 attribute set，\n        # 也可以是一个返回 attribute set 的函数，如果是函数，\n        # 那么它的参数就是当前的 NixOS Module 的参数.\n        #\n        # 根据 Nix Wiki 对 Nix modules 的描述，默认情况下，\n        # Nix Module 函数的默认参数有几个：\n        #\n        #  lib:     nixpkgs 自带的函数库，提供了许多操作 Nix 表达式的实用函数\n        #           详见 https://nixos.org/manual/nixpkgs/stable/#id-1.4\n        #  config:  当前 flake 的所有 config 参数的集合，比较常用\n        #  options: 当前 flake 中所有 NixOS Modules 中定义的所有参数的集合\n        #  pkgs:    一个包含所有 nixpkgs 包的集合，它也提供了许多相关的工具函数\n        #           入门阶段可以认为它的默认值为 `nixpkgs.legacyPackages.\"${system}\"`\n        #           可通过 `nixpkgs.pkgs` 这个 option 来自定义 pkgs 的值\n        #  modulesPath: 默认 nixpkgs 的内置 Modules 文件夹路径，\n        #               常用于从 nixpkgs 中导入一些额外的模块\n        #               这个参数通常都用不到，我只在制作 iso 镜像时用到过\n        #\n        # 上述默认参数都由 Nixpkgs 自动生成。而如果你需要将其他非默认参数传递到\n        # 子模块，就得使用 specialArgs 手动设定这些参数，\n        # 你可以取消注释如下这行来启用该参数：\n        #\n        # specialArgs = {...};  # 将 inputs 中的参数传入所有子模块\n        modules = [\n          # 这里导入之前我们使用的 configuration.nix，这样旧的配置文件仍然能生效\n          # 注: configuration.nix 本身也是一个 Nix Module，因此可以直接在这里导入\n          ./configuration.nix\n        ];\n      };\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n\n这里我们定义了一个名为 nixos-test 的系统，它的配置文件为 ./configuration.nix，这个文件就是我们之前的配置文件，这样我们仍然可以沿用旧的配置。\n\n现在执行 sudo nixos-rebuild switch --flake /etc/nixos#nixos-test 应用配置，系统应该没有任何变化，因为我们仅仅是切换到了 Nix Flakes，配置内容与之前还是一致的。\n\n上述代码的注释已经非常详细了，这里再着重说明几点：\n\nlib pkgs config 等默认参数都由 Nixpkgs 自动生成，并可被自动注入到子模块，无需在此处额外声明。\nspecialArgs = {...}; 这里省略了 attribute set 的内容，其中的内容会被通过名称匹配的方式自动注入到子模块中。\n常见用法比如直接写 specialArgs = inputs;，这样所有 inputs 中的 flake 数据源就都可以在子模块中使用了。\n通过 Flakes 来管理系统软件\n​\n\n切换完毕后，我们就可以通过 Flakes 来管理系统了。管系统最常见的需求就是装软件，我们在前面已经见识过如何通过 environment.systemPackages 来安装 pkgs 中的包，这些包都来自官方的 nixpkgs 仓库。\n\n现在我们学习下如何通过 Flakes 安装其他来源的软件包，这比直接安装 nixpkgs 要灵活很多，最显而易见的好处是你可以很方便地设定软件的版本。 以 helix 编辑器为例，我们首先需要在 flake.nix 中添加 helix 这个 inputs 数据源：\n\nnix\n{\n  description = \"NixOS configuration of Ryan Yin\";\n\n  # ......\n\n  inputs = {\n    # ......\n\n    # helix editor, use tag 23.05\n    helix.url = \"github:helix-editor/helix/23.05\";\n  };\n\n  outputs = inputs@{ self, nixpkgs, ... }: {\n    nixosConfigurations = {\n      nixos-test = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n\n        # 将所有 inputs 参数设为所有子模块的特殊参数，\n        # 这样就能直接在子模块中使用 inputs 中的 helix 了\n        specialArgs = inputs;\n        modules = [\n          ./configuration.nix\n        ];\n      };\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n接下来在 configuration.nix 中就能引用这个 flake input 数据源了：\n\nnix\n# Nix 会通过名称匹配，\n# 自动将 specialArgs 中的 helix 注入到此函数的第三个参数\n{ config, pkgs, helix, ... }:\n\n{\n  # 省略掉前面的配置......\n\n  environment.systemPackages = with pkgs; [\n    git  # Nix Flakes 通过 git 命令从数据源拉取依赖，所以必须先安装好 git\n    vim\n    wget\n    curl\n\n    # 这里从 helix 这个 inputs 数据源安装了 helix 程序\n    helix.packages.\"${pkgs.system}\".helix\n  ];\n\n  # 省略其他配置......\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n改好后再 sudo nixos-rebuild switch 部署，就能安装好 helix 程序了，可直接在终端使用 hx 命令测试验证。\n\n如果你的系统 Hostname 不是 nixos-test，你需要在 flake.nix 中修改 nixosConfigurations 的名称，或者使用 --flake /etc/nixos#nixos-test 来指定配置名称。\n\n为 Flake 添加自定义 cache 源\n​\n\n注意：这里介绍的手段只能加速部分包的下载，许多 inputs 数据源仍然会从 Github 拉取。 另外如果找不到缓存，会执行本地构建，这通常仍然需要从国外下载源码与构建依赖，因此仍然会很慢。为了完全解决速度问题，仍然建议使用旁路由等局域网全局代理方案。\n\nNix 为了加快包构建速度，提供了 https://cache.nixos.org 提前缓存构建结果提供给用户，但是在国内访问这个 cache 地址非常地慢，如果没有局域网全局代理的话，基本上是无法使用的。 另外 Flakes 的数据源基本都是某个 Github 仓库，在国内从 Github 下载 Flakes 数据源也同样非常非常慢。\n\n在旧的 NixOS 配置方式中，可以通过 nix-channel 命令添加国内的 cache 镜像源以提升下载速度，但是 Nix Flakes 会尽可能地避免使用任何系统级别的配置跟环境变量，以确保其构建结果不受环境的影响，因此在使用了 Flakes 后 nix-channel 命令就失效了。\n\n为了自定义 cache 镜像源，我们必须在 flake.nix 中添加相关配置，这就是 nixConfig 参数，示例如下：\n\nnix\n{\n  description = \"NixOS configuration of Ryan Yin\";\n\n  nixConfig = {\n    experimental-features = [ \"nix-command\" \"flakes\" ];\n    substituters = [\n      # replace official cache with a mirror located in China\n      \"https://mirrors.ustc.edu.cn/nix-channels/store\"\n      \"https://cache.nixos.org/\"\n    ];\n\n    # nix community's cache server\n    extra-substituters = [\n      \"https://nix-community.cachix.org\"\n    ];\n    extra-trusted-public-keys = [\n      \"nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs=\"\n    ];\n  };\n\n  inputs = {\n    # 省略若干配置...\n  };\n\n  outputs = {\n    # 省略若干配置...\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n添加完新 substituters 后，它仍然不会生效，这时直接部署配置，会出现这个 warning：\n\n...\nwarning: ignoring untrusted substituter 'https://mirrors.ustc.edu.cn/nix-channels/store', you are not a trusted user.\n...\n1\n2\n3\n\n\n这是 Nix 的安全限制，只有可信用户才能正常使用这里设置好的 substituters，所以我们还需要将自己的用户添加到可信列表中。在任一 NixOS Module 中添加如下配置：\n\nnix\n{\n  # 省略若干配置...\n\n  # 将自己的用户名添加到可信列表中\n  nix.settings.trusted-users = [ \"ryan\" ];\n\n  # 省略若干配置...\n}\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n现在再使用 sudo nixos-rebuild switch 应用配置即可生效，后续所有的包都会优先从国内镜像源查找缓存。\n\n如果你的系统 Hostname 不是 nixos-test，你需要在 flake.nix 中修改 nixosConfigurations 的名称，或者使用 --flake /etc/nixos#nixos-test 来指定配置名称。\n\n通过本地 HTTP 代理加速包下载\n​\n\n虽然前面提到了，旁路由可以完全解决 NixOS 的包下载速度问题，但是旁路由的配置比较麻烦，而且经常需要额外的软路由设备支持。\n\n更多的用户会希望能直接通过本机运行的 HTTP 代理来加速包下载，这里介绍下怎么设置。\n\n直接在 Terminal 中使用 export HTTPS_PROXY=http://127.0.0.1:7890 这类方式是无法生效的，因为 nix 实际干活的是一个叫 nix-daemon 的后台进程，而不是直接在 Terminal 中执行的命令。\n\n要让 nix-daemon 使用代理，需要修改它的 systemd 配置，方法如下：\n\nbash\nsudo mkdir /run/systemd/system/nix-daemon.service.d/\ncat << EOF >/run/systemd/system/nix-daemon.service.d/override.conf  \n[Service]\nEnvironment=\"http_proxy=socks5h://localhost:7891\"\nEnvironment=\"https_proxy=socks5h://localhost:7891\"\nEnvironment=\"all_proxy=socks5h://localhost:7891\"\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart nix-daemon\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n使用此方案，每次重启系统可能都需要重新执行一遍上述命令，因为 /run 目录是临时文件系统，重启后会被清空。\n\n参考\n​\nroaming laptop: network proxy configuration - NixOS/nixpkgs"
  },
  {
    "title": "Flakes 简介 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/nixos-with-flakes/introduction-to-flakes",
    "html": "Flakes 简介\n​\n\nFlakes 实验特性是 Nix 项目的一项重大进展，它引入了一种管理 Nix 表达式之间的依赖关系的策略，提高了 Nix 生态系统中的可复现性、可组合性和可用性。 虽然 Flakes 仍然是一个试验性的功能，但已经被 Nix 社区广泛采用。[1]\n\nFlakes 特性是 Nix 项目中最有意义的变化之一。[2]\n\n简单的说，如果你写过点 JavaScript/Go/Rust/Python，那你应该对 package.json/go.mod/Cargo.toml/pyproject.toml 这些文件不陌生， 在这些编程语言中，这些文件用来描述软件包之间的依赖关系，以及如何构建项目。 同样的，这些编程语言的包管理器还通过 package-lock.json/go.sum/Cargo.lock/poetry.lock 这些文件来锁定依赖的版本，以保证项目的可复现性。\n\nFlakes 就是从上述这类编程语言的包管理器中借鉴了一些思想，以提高 Nix 生态系统中的可复现性、可组合性和可用性。 Flakes 提供了 flake.nix，它类似 package.json，用来描述 Nix 包之间的依赖关系，以及如何构建项目。 同时它还提供了 flake.lock，这是一个类似 package-lock.json 的文件，用来锁定依赖的版本，以保证项目的可复现性。\n\n注意事项 caution\n​\n\nFlakes 带来的好处是显而易见的，整个 NixOS 社区都很喜欢它，目前超过半数的用户已经在大量使用 Flakes[3]，因此我们可以相当确定 Flakes 不会被废弃。\n\n⚠️但是 Flakes 目前仍然存在一些问题，因此在将它推向稳定的过程中，Nix 可能会引入一些不兼容的改动，这个改动的大小目前还无法确定。\n\n总的来说，我仍然推荐大家使用 Flakes，毕竟这本书本身也是围绕 NixOS 与 Flakes 编写的，但是也要做好准备——未来可能需要解决一些不兼容变更带来的问题。\n\nFlakes 与传统的 Nix\n​\n\nNix 于 2020 年推出了 nix-command & flakes 两个新特性，它们提供了全新的命令行工具、标准的 Nix 包结构定义、类似 cargo/npm 的 flake.lock 版本锁文件等等。这两个特性极大地增强了 Nix 的能力，因此虽然至今（2023/5/5）它们仍然是实验性特性，但是已经被 Nix 社区广泛使用。\n\n但由于 nix-command & flakes 仍然是实验性特性，官方文档基本不包含任何介绍它们的内容，同时社区关于 Flakes 的文档也相当分散且不完整。 但是从可复现、易于管理维护的角度讲，旧的 Nix 包结构与命令行工具已经不推荐使用了，因此本书也不会介绍旧的 Nix 包结构与命令行工具的使用方法，也建议新手直接忽略掉这些旧的内容，从 nix-command & flakes 学起。\n\n这里列举下在 nix-command & flakes 中已经不需要用到的旧的 Nix 命令行工具与相关概念，在查找资料时，如果看到它们直接忽略掉就行：\n\nnix-channel: 与 apt/yum/pacman 等其他 Linux 发行版的包管理工具类似，传统的 Nix 也以 stable/unstable/test 等 channel 的形式来管理软件包的版本，可通过此命令修改 Nix 的 channel 信息。\nNix Flakes 在 flake.nix 中通过 inputs 声明依赖包的数据源，通过 flake.lock 锁定依赖版本，完全取代掉了 nix-channel 的功能。\nnix-env: 用于管理用户环境的软件包，是传统 Nix 的核心命令行工具。它从 nix-channel 定义的数据源中安装软件包，所以安装的软件包版本受 channel 影响。\n通过 nix-env 安装的包不会被自动记录到 Nix 的声明式配置中，是完全脱离掌控的，无法在其他主机上复现，因此不推荐使用。\n在 Nix Flakes 中对应的命令为 nix profile，我个人也不太推荐直接使用它.\nnix-shell: nix-shell 用于创建一个临时的 shell 环境\n这玩意儿可能有点复杂了，因此在 Nix Flakes 中它被拆分成了三个子命令 nix develop, nix shell 以及 nix run，我们会在「构建开发环境」一章详细介绍这三个命令。\nnix-build: 用于构建 Nix 包，它会将构建结果放到 /nix/store 路径下，但是不会记录到 Nix 的声明式配置中。\n在 Nix Flakes 中对应的命令为 nix build\nnix-collect-garbage: 垃圾回收指令，用于清理 /nix/store 中未被使用的 Store Objects.\n在 Nix Flakes 中对应的命令为 nix store gc --debug.\n以及其他使用地较少的命令，就不一一列出了.\n详细的命令对比列表可以看看 Try to explain nix commands\n\n可能也就 nix-env -qa 这个命令偶尔还会有些用了，它返回当前系统下安装的所有软件包。\n\nFlakes 何时会成为稳定特性？\n​\n\n我深入了解了下 Flakes 现状与未来计划相关的资料，大概有这些：\n\n[RFC 0136] A plan to stabilize Flakes and the new CLI incrementally: 一份渐进式地将 Flakes 与 new CLI 两个实验性特性推向稳定的 RFC，目前还在讨论中。\nWhy are flakes still experimental? - NixOS Discourse: 最近的一次关于 Flakes 稳定性的讨论，可以看到大家的疑惑，以及社区对 Flakes 的态度。\nFlakes are such an obviously good thing - Graham Christensen: NixOS 社区成员的文章，记录了他对 Flakes 的看法，以及对社区当初添加 Flakes 特性时的不当举措的懊悔。\nteaching Nix 3 CLI and Flakes #281 - nix.dev: 社区关于是否应该在 NixOS 官方文档中介绍 Flakes 的讨论，当前结论是官方文档不应该推广使用 unstable 功能。\nDraft: 1 year roadmap - NixOS Foundation: NixOS Fundation 的一份 Roadmap，其中提到了 Flakes 的计划：Stabilize flakes and release Nix 3.0. Flakes are widely used (there are more GitHub repos being created with a flake.nix than a default.nix) but they’re still marked as experimental, which is not a good situation. The same applies to the new nix CLI.\n\n读完上述内容后，个人猜测，Flakes 可能会在未来一两年内成为稳定特性。\n\nFlakes - NixOS Wiki ↩︎\n\nFlakes are such an obviously good thing ↩︎\n\nDraft: 1 year roadmap - NixOS Foundation ↩︎"
  },
  {
    "title": "Nix 语言入门 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/the-nix-language/",
    "html": "Nix 语言入门\n​\n\nNix 语言是 Nix 包管理器的基础，要想玩得转 NixOS 与 Nix Flakes，享受到它们带来的诸多好处，就必须学会这门语言。\n\nNix 是一门比较简单的函数式语言，在已有一定编程基础的情况下，过一遍这些语法用时应该在 2 个小时以内，本文假设你具有一定编程基础（也就是说写得不会很细）。\n\n先把语法过一遍，有个大概的印象就行，后面需要用到时再根据右侧目录回来复习。\n\n注：如下内容有选择地介绍了 Nix 语言的常用语法，仅适合新手快速入门，请阅读官方文档 Nix Language 了解 Nix 语言的完整语法！\n\n基础数据类型一览\n​\n\n下面通过一个 attribute set （这类似 json 或者其他语言中的 map/dict）来简要说明所有基础数据类型：\n\nnix\n{\n  string = \"hello\";\n  integer = 1;\n  float = 3.141;\n  bool = true;\n  null = null;\n  list = [ 1 \"two\" false ];\n  attribute-set = {\n    a = \"hello\";\n    b = 2;\n    c = 2.718;\n    d = false;\n  }; # comments are supported\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n以及一些基础操作符（普通的算术运算、布尔运算就跳过不介绍了）：\n\nnix\n# 列表拼接\n[ 1 2 3 ] ++ [ 4 5 6 ] # [ 1 2 3 4 5 6 ]\n\n# 将 // 后面的 attribut set 中的内容，全部更新到 // 前面的 attribute set 中\n{ a = 1; b = 2; } // { b = 3; c = 4; } # 结果为 { a = 1; b = 3; c = 4; }\n\n# 逻辑隐含，等同于 !b1 || b2.\nbool -> bool\n1\n2\n3\n4\n5\n6\n7\n8\n\nlet ... in ...\n​\n\nNix 的 let ... in ... 语法被称作「let 表达式」或者「let 绑定」，它用于创建临时使用的局部变量：\n\nnix\nlet\n  a = 1;\nin\na + a  # 结果是 2\n1\n2\n3\n4\n\n\nlet 表达式中的变量只能在 in 之后的表达式中使用，理解成临时变量就行。\n\nif...then...else...\n​\n\nif...then...else... 用于条件判断，它是一个有返回值的表达式，语法如下：\n\nnix\nif 3 > 4 then \"yes\" else \"no\" # 结果为 \"no\"\n1\n\n\n也可以与 let...in... 一起使用：\n\nnix\nlet\n  x = 3;\nin\n  if x > 4 then \"yes\" else \"no\" # 结果为 \"no\"\n1\n2\n3\n4\n\nattribute set 说明\n​\n\n花括号 {} 用于创建 attribute set，也就是 key-value 对的集合，类似于 JSON 中的对象。\n\nattribute set 默认不支持递归引用，如下内容会报错：\n\nnix\n{\n  a = 1;\n  b = a + 1; # error: undefined variable 'a'\n}\n1\n2\n3\n4\n\n\n不过 Nix 提供了 rec 关键字（recursive attribute set），可用于创建递归引用的 attribute set：\n\nnix\nrec {\n  a = 1;\n  b = a + 1; # ok\n}\n1\n2\n3\n4\n\n\n在递归引用的情况下，Nix 会按照声明的顺序进行求值，所以如果 a 在 b 之后声明，那么 b 会报错。\n\n可以使用 . 操作符来访问 attribute set 的成员：\n\nnix\nlet\n  a = {\n    b = {\n      c = 1;\n    };\n  };\nin\na.b.c # 结果是 1\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n. 操作符也可直接用于赋值：\n\nnix\n{ a.b.c = 1; }\n1\n\n\n此外 attribute set 还支持一个 has attribute 操作符，它可用于检测 attribute set 中是否包含某个属性，返回 bool 值：\n\nnix\nlet\n  a = {\n    b = {\n      c = 1;\n    };\n  };\nin\na?b  # 结果是 true，因为 a.b 这个属性确实存在\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nhas attribute 操作符在 nixpkgs 库中常被用于检测处理 args?system 等参数，以 (args?system) 或 (! args?system) 的形式作为函数参数使用（叹号表示对 bool 值取反，是常见 bool 值运算符）。\n\nwith 语句\n​\n\nwith 语句的语法如下：\n\nnix\nwith <attribute-set> ; <expression>\n1\n\n\nwith 语句会将 <attribute-set> 中的所有成员添加到当前作用域中，这样在 <expression> 中就可以直接使用 <attribute-set> 中的成员了，简化 attribute set 的访问语法，比如：\n\nnix\nlet\n  a = {\n    x = 1;\n    y = 2;\n    z = 3;\n  };\nin\nwith a; [ x y z ]  # 结果是 [ 1 2 3 ], 等价于 [ a.x a.y a.z ]\n1\n2\n3\n4\n5\n6\n7\n8\n\n继承 inherit ...\n​\n\ninherit 语句用于从 attribute set 中继承成员，同样是一个简化代码的语法糖，比如：\n\nnix\nlet\n  x = 1;\n  y = 2;\nin\n{\n  inherit x y;\n}  # 结果是 { x = 1; y = 2; }\n1\n2\n3\n4\n5\n6\n7\n\n\ninherit 还能直接从某个 attribute set 中继承成员，语法为 inherit (<attribute-set>) <member-name>;，比如：\n\nnix\nlet\n  a = {\n    x = 1;\n    y = 2;\n    z = 3;\n  };\nin\n{\n  inherit (a) x y;\n}  # 结果是 { x = 1; y = 2; }\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n${ ... } 字符串插值\n​\n\n${ ... } 用于字符串插值，懂点编程的应该都很容易理解这个，比如：\n\nnix\nlet\n  a = \"1\";\nin\n\"the value of a is ${a}\"  # 结果是 \"the value of a is 1\"\n1\n2\n3\n4\n\n文件系统路径\n​\n\nNix 中不带引号的字符串会被解析为文件系统路径，路径的语法与 Unix 系统相同。\n\n搜索路径\n​\n\n请不要使用这个功能，它会导致不可预期的行为。\n\nNix 会在看到 <nixpkgs> 这类三角括号语法时，会在 NIX_PATH 环境变量中指定的路径中搜索该路径。\n\n因为环境变量 NIX_PATH 是可变更的值，所以这个功能是不纯的，会导致不可预期的行为。\n\n在这里做个介绍，只是为了让你在看到别人使用类似的语法时不至于抓瞎。\n\n多行字符串\n​\n\n多行字符串的语法为 ''，比如：\n\nnix\n''\n  this is a\n  multi-line\n  string\n''\n1\n2\n3\n4\n5\n\n多行字符串的转义\n​\n\n在单行字符串中，Nix 的转义语法与许多其他语言相同，\" \\ ${ 以及其他 \\n \\t 等特殊字符，都可直接使用 \\ 进行转义，比如：\n\nnix\n\"this is a \\\"string\\\" \\\\\"  # 结果是: this is a \"string\" \\\n1\n\n\n但在多行字符串中，情况会有点特殊。Nix 规定在多行字符串中需要使用两个单引号 '' 来转义。\n\n比如如下表示输出原始字符 ${a}，而不是字符串插值：\n\nnix\nlet\n  a = \"1\";\nin\n''the value of a is:\n  ''${a}\n''  # 结果是 \"the value of a is ''${a}\"\n1\n2\n3\n4\n5\n6\n\n\n其他 \\n \\t 等特殊字符的转义也类似，必须使用两个单引号来转义，如\n\nnix\n''\n  this is a\n  multi-line\n  string\n  ''\\n\n''\n1\n2\n3\n4\n5\n6\n\n\n如果我们希望在字符串中使用原始字符 ''，则需要再为它添加一个 '，比如：\n\nnix\nlet\n  a = \"1\";\nin\n''the value of a is:\n  '''${a}'''\n''  # 结果是 \"the value of a is ''1''\"\n1\n2\n3\n4\n5\n6\n\n函数\n​\n\n函数的声明语法为：\n\nnix\n<arg1>:\n  <body>\n1\n2\n\n\n举几个常见的例子：\n\nnix\n# 单参数函数\na: a + a\n\n# 嵌套函数\na: b: a + b\n\n# 双参数函数\n{ a, b }: a + b\n\n# 双参数函数，带默认值。问号后面的是参数的默认值\n{ a ? 1, b ? 2 }: a + b\n\n# 带有命名 attribute set 作为参数的函数，并且使用 ... 收集其他可选参数\n# 命名 args 与 ... 可选参数通常被一起作为函数的参数定义使用\nargs@{ a, b, ... }: a + b + args.c\n# 如下内容等价于上面的内容,\n{ a, b, ... }@args: a + b + args.c\n\n# 但是要注意命名参数仅绑定了输入的 attribute set，默认参数不在其中，举例\nlet\n  f = { a ? 1, b ? 2, ... }@args: args;\nin\n  f {}  # 结果是 {}，说明默认参数不在 args 中\n\n# 函数的调用方式就是把参数放在后面，比如下面的 2 就是前面这个函数的参数\na: a + a 2  # 结果是 4\n\n# 还可以给函数命名，不过必须使用 let 表达式\nlet\n  f = a: a + a;\nin\n  f 2  # 结果是 4\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n内置函数\n​\n\nNix 内置了一些函数，可通过 builtins.<function-name> 来调用，比如：\n\nnix\nbuiltins.add 1 2  # 结果是 3\n1\n\n\n详细的内置函数列表参见 Built-in Functions - Nix Reference Mannual\n\nimport 表达式\n​\n\nimport 表达式以其他 Nix 文件的路径作为参数，返回该 Nix 文件的执行结果。\n\nimport 的参数如果为文件夹路径，那么会返回该文件夹下的 default.nix 文件的执行结果。\n\n举个例子，首先创建一个 file.nix 文件：\n\nshell\n$ echo \"x: x + 1\" > file.nix\n1\n\n\n然后使用 import 执行它：\n\nnix\nimport ./file.nix 1  # 结果是 2\n1\n\npkgs.lib 函数包\n​\n\n除了 builtins 之外，Nix 的 nixpkgs 仓库还提供了一个名为 lib 的 attribute set，它包含了一些常用的函数，它通常被以如下的形式被使用：\n\nnix\nlet\n  pkgs = import <nixpkgs> {};\nin\npkgs.lib.strings.toUpper \"search paths considered harmful\"  # 结果是 \"SEARCH PATHS CONSIDERED HARMFUL\"\n1\n2\n3\n4\n\n\n可以通过 Nixpkgs Library Functions - Nixpkgs Manual 查看 lib 函数包的详细内容。\n\n不纯（Impurities）\n​\n\nNix 语言本身是纯函数式的，是纯的，「纯」是指它就跟数学中的函数一样，同样的输入永远得到同样的输出。\n\nNix 有两种构建输入，一种是从文件系统路径等输入源中读取文件，另一种是将其他函数作为输入。\n\nNix 唯一的不纯之处在这里：从文件系统路径或者其他输入源中读取文件作为构建任务的输入，这些输入源参数可能没变化，但是文件内容或数据源的返回内容可能会变化，这就会导致输入相同，Nix 函数的输出却可能不同——函数变得不纯了。\n\nNix 中的搜索路径与 builtins.currentSystem 也是不纯的，但是这两个功能都不建议使用，所以这里略过了。\n\nFetchers\n​\n\n构建输入除了直接来自文件系统路径之外，还可以通过 Fetchers 来获取，Fetcher 是一种特殊的函数，它的输入是一个 attribute set，输出是 Nix Store 中的一个系统路径。\n\nNix 提供了四个内置的 Fetcher，分别是：\n\nbuiltins.fetchurl：从 url 中下载文件\nbuiltins.fetchTarball：从 url 中下载 tarball 文件\nbuiltins.fetchGit：从 git 仓库中下载文件\nbuiltins.fetchClosure：从 Nix Store 中获取 Derivation\n\n举例：\n\nnix\nbuiltins.fetchurl \"https://github.com/NixOS/nix/archive/7c3ab5751568a0bc63430b33a5169c5e4784a0ff.tar.gz\"\n# result example => \"/nix/store/7dhgs330clj36384akg86140fqkgh8zf-7c3ab5751568a0bc63430b33a5169c5e4784a0ff.tar.gz\"\n\nbuiltins.fetchTarball \"https://github.com/NixOS/nix/archive/7c3ab5751568a0bc63430b33a5169c5e4784a0ff.tar.gz\"\n# result example(auto unzip the tarball) => \"/nix/store/d59llm96vgis5fy231x6m7nrijs0ww36-source\"\n1\n2\n3\n4\n5\n\nDerivations\n​\n\n官方 Nixpkgs 包仓库中的软件包已经能满足绝大部分用户的使用，在学习 NixOS 的前期不太需要深入了解 Derivation 的使用细节，有个印象就行。 本书会在后面 Nix 软件打包入门 中详细介绍相关内容，这里仅做简要介绍。\n\nDerivation 描述了如何构建一个软件包，是一个软件包构建流程的 Nix 语言描述，它声明了构建时需要有哪些依赖项、需要什么构建工具链、要设置哪些环境变量、哪些构建参数、先干啥后干啥等等。\n\nDerivation 的构建结果是一个 Store Object，其中包含了软件包的所有二进制程序、配置文件等等内容。 Store Object 的存放路径格式为 /nix/store/<hash>-<name>，其中 <hash> 是构建结果的 hash 值，<name> 是它的名字。路径 hash 值确保了每个构建结果都是唯一的，因此可以多版本共存，而且不会出现依赖冲突的问题。\n\n/nix/store 是一个特殊的文件路径，它被称为 Store，存放所有的 Store Objects，这个路径被设置为只读，只有 Nix 本身才能修改这个路径下的内容，以保证系统的可复现性。\n\nDerivation 实质上只是一个 attribute set，Nix 底层会使用内置函数 builtins.derivation 将这个 attribute set 构建为一个 Store Object。 我们实际编写 Derivation 时，通常使用的是 stdenv.mkDerivation，它是前述内置函数 builtins.derivation 的 Nix 语言 wrapper，屏蔽了底层的细节，简化了用法。\n\n一个简单的 Derivation 如下，它声明了一个名为 hello 的应用程序（摘抄自 nixpkgs/pkgs/hello）：\n\nnix\n{ callPackage\n, lib\n, stdenv\n, fetchurl\n, nixos\n, testers\n, hello\n}:\n\nstdenv.mkDerivation (finalAttrs: {\n  pname = \"hello\";\n  version = \"2.12.1\";\n\n  src = fetchurl {\n    url = \"mirror://gnu/hello/hello-${finalAttrs.version}.tar.gz\";\n    sha256 = \"sha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=\";\n  };\n\n  doCheck = true;\n\n  passthru.tests = {\n    version = testers.testVersion { package = hello; };\n\n    invariant-under-noXlibs =\n      testers.testEqualDerivation\n        \"hello must not be rebuilt when environment.noXlibs is set.\"\n        hello\n        (nixos { environment.noXlibs = true; }).pkgs.hello;\n  };\n\n  passthru.tests.run = callPackage ./test.nix { hello = finalAttrs.finalPackage; };\n\n  meta = with lib; {\n    description = \"A program that produces a familiar, friendly greeting\";\n    longDescription = ''\n      GNU Hello is a program that prints \"Hello, world!\" when you run it.\n      It is fully customizable.\n    '';\n    homepage = \"https://www.gnu.org/software/hello/manual/\";\n    changelog = \"https://git.savannah.gnu.org/cgit/hello.git/plain/NEWS?h=v${finalAttrs.version}\";\n    license = licenses.gpl3Plus;\n    maintainers = [ maintainers.eelco ];\n    platforms = platforms.all;\n  };\n})\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n参考\n​\nNix language basics - nix.dev"
  },
  {
    "title": "开始使用 NixOS | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/nixos-with-flakes/get-started-with-nixos",
    "html": "开始使用 NixOS\n​\n\n了解了 Nix 语言的基本用法之后，我们就可以开始使用 Nix 语言来配置 NixOS 系统了。 NixOS 的系统配置路径为 /etc/nixos/configuration.nix，它包含系统的所有声明式配置，如时区、语言、键盘布局、网络、用户、文件系统、启动项、桌面环境等等。\n\n如果想要以可复现的方式修改系统的状态（这也是最推荐的方式），就需要手工修改 /etc/nixos/configuration.nix 文件，然后执行 sudo nixos-rebuild switch 命令来应用配置，此命令会根据配置文件生成一个新的系统环境，并将新的环境设为默认环境。 同时上一个系统环境会被保留，而且会被加入到 grub 的启动项中，这确保了即使新的环境不能启动，也能随时回退到旧环境。\n\n另一方面，/etc/nixos/configuration.nix 是传统的 Nix 配置方式，它依赖 nix-channel 配置的数据源，也没有任何版本锁定机制，实际无法确保系统的可复现性。 更推荐使用的是 Nix Flakes，它可以确保系统的可复现性，同时也可以很方便地管理系统的配置。\n\n我们下面首先介绍下通过 NixOS 默认的配置方式来管理系统，然后再过渡到更先进的 Nix Flakes.\n\n使用 /etc/nixos/configuration.nix 配置系统\n​\n\n前面提过了这是传统的 Nix 配置方式，也是当前 NixOS 默认使用的配置方式，它依赖 nix-channel 配置的数据源，也没有任何版本锁定机制，实际无法确保系统的可复现性。\n\n简单起见我们先使用这种方式来配置系统，后面会介绍 Flake 的使用。\n\n比如要启用 ssh 并添加一个用户 ryan，只需要在 /etc/nixos/configuration.nix 中添加如下配置：\n\nnix\n# Edit this configuration file to define what should be installed on\n# your system.  Help is available in the configuration.nix(5) man page\n# and in the NixOS manual (accessible by running ‘nixos-help’).\n{ config, pkgs, ... }:\n\n{\n  imports =\n    [ # Include the results of the hardware scan.\n      ./hardware-configuration.nix\n    ];\n\n  # 省略掉前面的配置......\n\n  # 新增用户 ryan\n  users.users.ryan = {\n    isNormalUser = true;\n    description = \"ryan\";\n    extraGroups = [ \"networkmanager\" \"wheel\" ];\n    openssh.authorizedKeys.keys = [\n        # replace with your own public key\n        \"ssh-ed25519 <some-public-key> ryan@ryan-pc\"\n    ];\n    packages = with pkgs; [\n      firefox\n    #  thunderbird\n    ];\n  };\n\n  # 启用 OpenSSH 后台服务\n  services.openssh = {\n    enable = true;\n    settings = {\n      X11Forwarding = true;\n      PermitRootLogin = \"no\"; # disable root login\n      PasswordAuthentication = false; # disable password login\n    };\n    openFirewall = true;\n  };\n\n  # 省略其他配置......\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n这里我启用了 openssh 服务，为 ryan 用户添加了 ssh 公钥，并禁用了密码登录。\n\n现在运行 sudo nixos-rebuild switch 部署修改后的配置，之后就可以通过 ssh 密钥远程登录到我的这台主机了。\n\n这就是 NixOS 默认的声明式系统配置，要对系统做任何可复现的变更，都只需要修改 /etc/nixos/configuration.nix 文件，然后运行 sudo nixos-rebuild switch 部署变更即可。\n\n/etc/nixos/configuration.nix 的所有配置项，可以在这几个地方查到：\n\n直接 Google，比如 Chrome NixOS 就能找到 Chrome 相关的配置项，一般 NixOS Wiki 或 nixpkgs 仓库源码的排名会比较靠前。\n在 NixOS Options Search 中搜索关键字\n系统级别的配置，可以考虑在 Configuration - NixOS Manual 找找相关文档\n直接在 nixpkgs 仓库中搜索关键字，读相关的源码。\n参考\n​\nOverview of the NixOS Linux distribution"
  },
  {
    "title": "安装 NixOS | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/introduction/installation",
    "html": "安装 NixOS\n​\n\nNix 有多种安装方式：\n\n以包管理器的形式安装到 MacOS/Linux/WSL 三种系统上\n也可以直接安装 NixOS，这是 Nix 官方推出的一个 Linux 发行版，使用 Nix 包管理器来管理整个系统环境。\n\n本书主要介绍 NixOS 与 Flakes 的使用，因此不展开讨论。\n\nNixOS 的安装步骤很简单，这里不多介绍，仅列一下我觉得比较有用的参考资料：\n\nNixOS 官网\n国内镜像源：\nhttps://mirrors.ustc.edu.cn/help/nix-channels.html\nhttps://mirrors.tuna.tsinghua.edu.cn/help/nix/\n\n如果你使用的是 MacOS，可以通过 ryan4yin/nix-darwin-kickstarter 结合本书的内容来学习使用 Nix."
  },
  {
    "title": "NixOS 的优缺点 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/introduction/advantages-and-disadvantages",
    "html": "NixOS 的优缺点\n​\n优点\n​\n声明式配置，OS as Code\nNixOS 使用声明式配置来管理整个系统环境，可以直接用 Git 管理这些配置，只要你的配置文件不丢，系统就可以随时还原到任一历史状态（前面提过了，只有在 Nix 配置文件中声明了的状态才可被 NixOS 还原）。\nNix Flakes 还使用了 flake.lock 作为版本锁文件，它记录了所有相关数据的数据源地址、hash 值，这极大地提升了 Nix 的可复现能力（或者说增强了构建结果的一致性，这个设计实际是从 cargo/npm 等一些编程语言的包管理设计中借鉴来的）。\n高度便捷的系统自定义能力\n通过改几行配置，就可以简单地更换系统的各种组件。这是因为 Nix 将底层的复杂操作全部封装在了 Nix 软件包中，只给用户提供了简洁且必要的声明式参数。\n而且这种修改非常安全，你可以很方便地来回切换各种桌面环境（比如 gnome/kde/i3/sway），几乎不会遇到坑。\n可回滚\n可以随时回滚到任一历史环境，NixOS 甚至默认将所有旧版本都加入到了启动项，确保系统滚挂了也能随时回退。所以 Nix 也被认为是最稳定的包管理方式。\n没有依赖冲突问题\n因为 Nix 中每个软件包都拥有唯一的 hash，其安装路径中也会包含这个 hash 值，因此可以多版本共存。\n社区很活跃，第三方项目也挺丰富\n官方包仓库 nixpkgs 贡献者众多，也有很多人分享自己的 Nix 配置，一遍浏览下来，整个生态给我一种发现新大陆的兴奋感。\nNixOS 启动项中列出了所有历史版本，图来自 NixOS Discourse - 10074\n缺点\n​\n学习成本高:\n如果你希望系统完全可复现，并且避免各种不当使用导致的坑，那就需要学习了解 Nix 的整个设计，并以声明式的方式管理系统，不能无脑 nix-env -i（这类似 apt-get install）。\n文档混乱:\n首先 Nix Flakes 目前仍然是实验性特性，介绍它本身的文档目前比较匮乏, Nix 社区绝大多数文档都只介绍了旧的 nix-env/nix-channel，想直接从 Nix Flakes 开始学习的话，需要参考大量旧文档，从中提取出自己需要的内容。另外一些 Nix 当前的核心功能，官方文档都语焉不详（比如 imports 跟 Nix Module System），想搞明白基本只能看源码了...\n比较吃硬盘空间:\n为了保证系统可以随时回退，nix 默认总是保留所有历史环境，这会使用更多的硬盘空间。\n多使用的这这些空间，在桌面电脑上可能不是啥事，但是在资源受限的云服务器上可能会是个问题。\n报错信息比较隐晦:\n一般的报错提示还是比较清楚的，但是遇到好几次依赖版本有问题或者传参错误提示不出原因，--show-trace 直接输出一堆的内部堆栈，都花了很长时间才定位到，通过升级依赖版本或者修正参数后问题解决。\n猜测导致这个问题的原因有两个，一是 Nix 是动态语言，各种参数都是运行时才确定类型。二是我用到的 flake 包的错误处理逻辑写得不太好，错误提示不清晰，一些隐晦的错误甚至通过错误堆栈也定位不到原因。\n底层实现更复杂：\nNix 多做了一层声明式的抽象带来了诸多好处，而其代价就是底层的代码实现会比传统的命令式工具中的同类代码更复杂。\n这导致实现难度更高，对底层做些修改也会更麻烦。不过这个问题带来的负担主要是在 Nix 软件包的维护者身上，普通用户接触底层比较少，负担也就小很多。\n简单总结下\n​\n\n总的来说，我觉得 NixOS 适合那些有一定 Linux 使用经验与编程经验，并且希望对自己的系统拥有更强掌控力的开发者。\n\n我不推荐没有任何 Linux 使用经验的新人直接上手 NixOS，那可能会是一段糟糕的旅程。\n\n如果你对 NixOS 还有疑问，可以看看本书的最后一章「常见问题」。"
  },
  {
    "title": "Frequently Asked Questions | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/faq/",
    "html": "Frequently Asked Questions\n​\nWhat is the difference between NixOS rollback capability and btrfs/zfs system snapshot rollback?\n​\n\nThe difference lies in the nature of the snapshots. System snapshots created with btrfs/zfs does not contain the 'knowledge' of how to build this snapshot from scratch, it is uninterpretable, and its content is strongly correlated with the current hardware environment, making it difficult to reproduce on other machines.\n\nOn the other hand, NixOS configuration is a piece of \"knowledge\" that can build an identical OS from scratch. It is explainable and can be automatically built with just a few simple commands. The NixOS configuration serves as documentation of all the changes made to your OS and is also used to automatically build the OS itself.\n\nThe NixOS configuration file is like the source code of a program. As long as the source code is intact, it is easy to modify, review, or rebuild an identical program. In contrast, system snapshots are like compiled binary programs derived from source code, making it much more difficult to modify or review them. Moreover, snapshots are large in size, making sharing or migrating them more costly compared to source code.\n\nHowever, this doesn't mean that NixOS eliminates the need for system snapshots. As mentioned in Chapter 1 of this book, NixOS can only guarantee reproducibility for everything declared in the declarative configuration. Other aspects of the system that are not covered by the declarative configuration, such as dynamic data in MySQL/PostgreSQL, user-uploaded files, system logs, videos, music, and images in user home directories, still require system snapshots or other means of backup.\n\nHow does Nix compare to traditional system management tools like Ansible?\n​\n\nNix is not only used for managing desktop environments but is also widely employed for batch management of cloud servers. The official NixOps from the NixOS community and colmena developed by the community are tools specifically designed for this use case.\n\nWhen compared to widely used traditional tools like Ansible, Nix has the following main advantages:\n\nOne of the biggest problems with this Anisble is that each deployment is based on incremental changes to the current state of the system. The current state of the system, like the snapshots mentioned above, is not interpretable and is difficult to reproduce. NixOS declares the target state of the system through its configuration files, so that the deployment result is independent of the current state of the system, and repeated deployments will not cause any problems.\nNix Flakes uses a version lock file flake.lock to lock the hash value, version number, data source and other information of all dependencies, which greatly improves the reproducibility of the system. Traditional tools like Ansible don't have this feature, so they're not very reproducible.\nThis is why Docker is so popular - it provides, at a fraction of the cost, a reproducible system environment on a wide range of machines that traditional Ops tools like Ansible don't. 1.\nNix provides a high degree of ease of system customization by shielding the underlying implementation details with a layer of declarative abstraction so that users only need to care about their core requirements. Tools like Ansible have much weaker abstractions.\nIf you've ever used a declarative configuration tool like terraform/kubernetes, this should be easy to understand. The more complex the requirements, the greater the benefit of declarative configuration.\nWhat are the advantages of Nix compared to Docker container technology?\n​\n\nNix and container technologies like Docker do have overlapping use cases, such as:\n\nMany people use Nix to manage development and build environments, as discussed in this book. On the other hand, technologies like Dev Containers, which build development environments based on containers, are also popular.\nThe DevOps/SRE field is currently dominated by container technologies based on Dockerfiles. Commonly used distributions like Ubuntu/Debian are frequently used within containers, and there are also mature options available for the host machine. In this context, what significant advantages do switching to NixOS offer?\n\nRegarding the first point of \"managing the development and build environments,\" Nix provides a development environment experience that closely resembles working directly on the host machine. This offers several advantages over Dev Containers, as outlined below:\n\nNix does not use namespaces for filesystem and network isolation, allowing easy interaction with the host machine's filesystem (including /dev for external devices) and network environment within the Nix-created development environment. In contrast, containers require various mappings to enable communication between the container and the host machine's filesystem, which can sometimes lead to file permission issues.\nDue to the absence of strong isolation, Nix development environments have no issues supporting GUI applications. Running GUI programs within this environment is as seamless as running them in the system environment.\n\nIn other words, Nix provides a development experience that is closest to the host machine, with no strong isolation. Developers can use familiar development and debugging tools in this environment, and their past development experience can be seamlessly migrated. On the other hand, if Dev Containers are used, developers may encounter various issues related to filesystem communication, network environment, user permissions, and the inability to use GUI debugging tools due to strong isolation.\n\nIf we decide to use Nix to manage all development environments, then building Docker containers based on Nix would provide the highest level of consistency. Additionally, adopting a unified technological architecture for all environments significantly reduces infrastructure maintenance costs. This answers the second point mentioned earlier: when managing development environments with Nix as a prerequisite, using NixOS for container base images and cloud servers offers distinct advantages."
  },
  {
    "title": "最佳实践 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/best-practices/intro",
    "html": "最佳实践\n​\n\nNix 非常强大且灵活，做一件事有非常多的方法，这就导致了很难找到最合适的方法来做你的工作。 这里记录了一些我在使用 NixOS 中学习到的最佳实践，希望能帮到你。"
  },
  {
    "title": "Nix 与 NixOS 简介 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/introduction/",
    "html": "Nix 与 NixOS 简介\n​\n\nNix 是一个声明式的软件包管理器，用户需要通过某些配置声明好期望的环境状态，而 Nix 负责达成这个目标。\n\n简单解释下什么是「声明式配置」，它是指用户只需要声明好自己想要的结果——比如说希望将 i3 桌面替换成 sway 桌面，Nix 就会帮用户达成这个目标。 用户不需要关心底层细节（比如说 sway 需要安装哪些软件包，哪些 i3 相关的软件包需要卸载掉，哪些系统配置或环境变量需要针对 sway 做调整、如果使用了 Nvidia 显卡 Sway 参数要做什么调整才能正常运行等等），Nix 会自动帮用户处理这些细节（当然这有个前提，就是 sway 跟 i3 相关的 nix 包设计良好）。\n\n而基于 Nix 包管理器构建的 Linux 发行版 NixOS，可以简单用 OS as Code 来形容，它通过声明式的 Nix 配置文件来描述整个操作系统的状态。\n\n一个操作系统中有各种各样的软件包、配置文件、文本或二进制的数据，这些都是系统当前的状态，而声明式的配置能够管理到的，只是其中静态的那一部分。 而那些动态的数据（比如说 PostgreSQL/MySQL/MongoDB 的数据），显然是无法通过声明式配置管理的（总不能每次部署都直接删除掉所有未在配置中声明的新数据吧）。 因此 NixOS 实际也只支持通过声明式配置管理系统的部分状态，上面提到的各种动态数据，以及用户 Home 目录中的所有内容，都不受它管控（所以在你将 NixOS 切换到上一个版本时，NixOS 不会对它们做任何操作）。\n\n但是用户的 Home 目录中实际包含了许多重要的配置文件，用户当然会希望能使用 Nix 将它们给管理起来。 另一个重要的社区项目 home-manager 就填补了这块缺失，它被设计用于管理用户 Home 目录中的配置文件以及用户级别的软件包。\n\n因为 Nix 声明式、可复现的特性，Nix 不仅可用于管理桌面电脑的环境，也有很多人用它管理开发编译环境、云上虚拟机、容器镜像构建等等，Nix 官方的 NixOps 与社区的 colmena 都是基于 Nix 实现的运维工具。\n\n为什么选择 NixOS？\n​\n\n好几年前就听说过 Nix 包管理器，它用 Nix 语言编写配置来管理系统依赖，此外基于 Nix 包管理器设计的 Linux 发行版 NixOS，还能随时将系统回滚到任一历史状态（额实际上这个回滚有些限制，前面提过了）。 虽然听着很牛，但是不仅要多学一门语言，装个包还得写代码，当时觉得太麻烦就没研究。\n\n但是我最近在使用 EndeavourOS 时遇到了一系列麻烦事儿，花了大量的精力去解决，搞得我精疲力尽。 我仔细一想，遇到的这些问题归根结底还是系统没有版本控制跟回滚机制，导致出了问题不能还原，就必须得各种查资料找 Bug，手动修复系统状态。\n\n所以我就决定干脆换成 NixOS.\n\n切换到 NixOS 后，我对它那是相当的满意，腰也不疼了，背也不酸了... 最惊艳的是，现在我可以通过仅仅一行命令（sudo nixos-rebuild switch --flake .），就能在一台全新安装的 NixOS 主机上还原我的整个 i3 桌面环境以及所有我的常用软件！\n\nNixOS 的回滚能力与可复现能力给了我非常大的底气，我现在再也不用怕把系统搞挂了（挂了直接回滚就恢复了），于是我又在 NixOS 尝试了许多新鲜玩意儿！ 在以前 EndeavourOS 上我肯定是不太敢这么玩的，因为万一要是把系统玩出问题了，就必须手动修复系统状态，那可是相当麻烦。\n\n这就是我选择 NixOS 的原因。"
  },
  {
    "title": "Nix 与 NixOS 简介 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/introduction/",
    "html": "Nix 与 NixOS 简介\n​\n\nNix 是一个声明式的软件包管理器，用户需要通过某些配置声明好期望的环境状态，而 Nix 负责达成这个目标。\n\n简单解释下什么是「声明式配置」，它是指用户只需要声明好自己想要的结果——比如说希望将 i3 桌面替换成 sway 桌面，Nix 就会帮用户达成这个目标。 用户不需要关心底层细节（比如说 sway 需要安装哪些软件包，哪些 i3 相关的软件包需要卸载掉，哪些系统配置或环境变量需要针对 sway 做调整、如果使用了 Nvidia 显卡 Sway 参数要做什么调整才能正常运行等等），Nix 会自动帮用户处理这些细节（当然这有个前提，就是 sway 跟 i3 相关的 nix 包设计良好）。\n\n而基于 Nix 包管理器构建的 Linux 发行版 NixOS，可以简单用 OS as Code 来形容，它通过声明式的 Nix 配置文件来描述整个操作系统的状态。\n\n一个操作系统中有各种各样的软件包、配置文件、文本或二进制的数据，这些都是系统当前的状态，而声明式的配置能够管理到的，只是其中静态的那一部分。 而那些动态的数据（比如说 PostgreSQL/MySQL/MongoDB 的数据），显然是无法通过声明式配置管理的（总不能每次部署都直接删除掉所有未在配置中声明的新数据吧）。 因此 NixOS 实际也只支持通过声明式配置管理系统的部分状态，上面提到的各种动态数据，以及用户 Home 目录中的所有内容，都不受它管控（所以在你将 NixOS 切换到上一个版本时，NixOS 不会对它们做任何操作）。\n\n但是用户的 Home 目录中实际包含了许多重要的配置文件，用户当然会希望能使用 Nix 将它们给管理起来。 另一个重要的社区项目 home-manager 就填补了这块缺失，它被设计用于管理用户 Home 目录中的配置文件以及用户级别的软件包。\n\n因为 Nix 声明式、可复现的特性，Nix 不仅可用于管理桌面电脑的环境，也有很多人用它管理开发编译环境、云上虚拟机、容器镜像构建等等，Nix 官方的 NixOps 与社区的 colmena 都是基于 Nix 实现的运维工具。\n\n为什么选择 NixOS？\n​\n\n好几年前就听说过 Nix 包管理器，它用 Nix 语言编写配置来管理系统依赖，此外基于 Nix 包管理器设计的 Linux 发行版 NixOS，还能随时将系统回滚到任一历史状态（额实际上这个回滚有些限制，前面提过了）。 虽然听着很牛，但是不仅要多学一门语言，装个包还得写代码，当时觉得太麻烦就没研究。\n\n但是我最近在使用 EndeavourOS 时遇到了一系列麻烦事儿，花了大量的精力去解决，搞得我精疲力尽。 我仔细一想，遇到的这些问题归根结底还是系统没有版本控制跟回滚机制，导致出了问题不能还原，就必须得各种查资料找 Bug，手动修复系统状态。\n\n所以我就决定干脆换成 NixOS.\n\n切换到 NixOS 后，我对它那是相当的满意，腰也不疼了，背也不酸了... 最惊艳的是，现在我可以通过仅仅一行命令（sudo nixos-rebuild switch --flake .），就能在一台全新安装的 NixOS 主机上还原我的整个 i3 桌面环境以及所有我的常用软件！\n\nNixOS 的回滚能力与可复现能力给了我非常大的底气，我现在再也不用怕把系统搞挂了（挂了直接回滚就恢复了），于是我又在 NixOS 尝试了许多新鲜玩意儿！ 在以前 EndeavourOS 上我肯定是不太敢这么玩的，因为万一要是把系统玩出问题了，就必须手动修复系统状态，那可是相当麻烦。\n\n这就是我选择 NixOS 的原因。"
  },
  {
    "title": "Introduction to Nix & NixOS | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/introduction/#VPContent",
    "html": "Introduction to Nix & NixOS\n​\n\nNix is a declarative package manager that enables users to declare the desired system state in configuration files (declarative configuration), and it takes responsibility for achieving that state.\n\nIn simple terms, \"declarative configuration\" means that users only need to declare the desired outcome. For instance, if you declare that you want to replace the i3 window manager with sway, Nix will assist you in achieving that goal. You don't have to worry about the underlying details, such as which packages sway requires for installation, which i3-related packages need to be uninstalled, or the necessary adjustments to system configuration and environment variables for sway. Nix automatically handles these details for the user (provided that the Nix packages related to sway and i3 are properly designed).\n\nNixOS, a Linux distribution built on top of the Nix package manager, can be described as \"OS as Code.\" It employs declarative Nix configuration files to describe the entire state of the operating system.\n\nAn operating system consists of various software packages, configuration files, and text/binary data, all of which represent the current state of the system. Declarative configuration can manage only the static portion of this state. Dynamic data, such as PostgreSQL, MySQL, or MongoDB data, cannot be effectively managed through declarative configuration (it is not feasible to delete all new PostgreSQL data that is not declared in the configuration during each deployment). Therefore, NixOS primarily focuses on managing the static portion of the system state in a declarative manner. Dynamic data, along with the contents in the user's home directory, remain unaffected by NixOS when rolling back to a previous generation.\n\nAlthough we cannot achieve complete system reproducibility, the /home directory, being an important user directory, contains many necessary configuration files. A significant community project called home-manager is designed to manage user-level packages and configuration files within the user's home directory.\n\nDue to Nix's features, such as being declarative and reproducible, Nix is not limited to managing desktop environments but is also extensively used for managing development environments, compilation environments, cloud virtual machines, and container image construction. NixOps (an official Nix project) and colmena (a community project) are both operational tools based on Nix.\n\nWhy NixOS?\n​\n\nI first learned about the Nix package manager several years ago. It utilizes the Nix language to describe system configuration. NixOS, the Linux distribution built on top of it, allows for rolling back the system to any previous state (although only the state declared in Nix configuration files can be rolled back). While it sounded impressive, I found it troublesome to learn a new language and write code to install packages, so I didn't pursue it at the time.\n\nHowever, I recently encountered numerous environmental issues while using EndeavourOS, and resolving them consumed a significant amount of my energy, leaving me exhausted. Upon careful consideration, I realized that the lack of version control and rollback mechanisms in EndeavourOS prevented me from restoring the system when problems arose.\n\nThat's when I decided to switch to NixOS.\n\nTo my delight, NixOS has exceeded my expectations. The most astonishing aspect is that I can now restore my entire i3 environment and all my commonly used packages on a fresh NixOS host with just one command sudo nixos-rebuild switch --flake .. It's truly fantastic!\n\nThe rollback capability and reproducibility of NixOS has instilled a great deal of confidence in me—I no longer fear breaking the system. I've even ventured into experimenting with new things on NixOS, such as the hyprland compositor. Previously, on EndeavourOS, I wouldn't have dared to tinker with such novel compositors, as any system mishaps would have entailed significant manual troubleshooting using various workarounds.\n\nThis is why I chose NixOS."
  },
  {
    "title": "Frequently Asked Questions | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/faq",
    "html": "Frequently Asked Questions\n​\nWhat is the difference between NixOS rollback capability and btrfs/zfs system snapshot rollback?\n​\n\nThe difference lies in the nature of the snapshots. System snapshots created with btrfs/zfs does not contain the 'knowledge' of how to build this snapshot from scratch, it is uninterpretable, and its content is strongly correlated with the current hardware environment, making it difficult to reproduce on other machines.\n\nOn the other hand, NixOS configuration is a piece of \"knowledge\" that can build an identical OS from scratch. It is explainable and can be automatically built with just a few simple commands. The NixOS configuration serves as documentation of all the changes made to your OS and is also used to automatically build the OS itself.\n\nThe NixOS configuration file is like the source code of a program. As long as the source code is intact, it is easy to modify, review, or rebuild an identical program. In contrast, system snapshots are like compiled binary programs derived from source code, making it much more difficult to modify or review them. Moreover, snapshots are large in size, making sharing or migrating them more costly compared to source code.\n\nHowever, this doesn't mean that NixOS eliminates the need for system snapshots. As mentioned in Chapter 1 of this book, NixOS can only guarantee reproducibility for everything declared in the declarative configuration. Other aspects of the system that are not covered by the declarative configuration, such as dynamic data in MySQL/PostgreSQL, user-uploaded files, system logs, videos, music, and images in user home directories, still require system snapshots or other means of backup.\n\nHow does Nix compare to traditional system management tools like Ansible?\n​\n\nNix is not only used for managing desktop environments but is also widely employed for batch management of cloud servers. The official NixOps from the NixOS community and colmena developed by the community are tools specifically designed for this use case.\n\nWhen compared to widely used traditional tools like Ansible, Nix has the following main advantages:\n\nOne of the biggest problems with this Anisble is that each deployment is based on incremental changes to the current state of the system. The current state of the system, like the snapshots mentioned above, is not interpretable and is difficult to reproduce. NixOS declares the target state of the system through its configuration files, so that the deployment result is independent of the current state of the system, and repeated deployments will not cause any problems.\nNix Flakes uses a version lock file flake.lock to lock the hash value, version number, data source and other information of all dependencies, which greatly improves the reproducibility of the system. Traditional tools like Ansible don't have this feature, so they're not very reproducible.\nThis is why Docker is so popular - it provides, at a fraction of the cost, a reproducible system environment on a wide range of machines that traditional Ops tools like Ansible don't. 1.\nNix provides a high degree of ease of system customization by shielding the underlying implementation details with a layer of declarative abstraction so that users only need to care about their core requirements. Tools like Ansible have much weaker abstractions.\nIf you've ever used a declarative configuration tool like terraform/kubernetes, this should be easy to understand. The more complex the requirements, the greater the benefit of declarative configuration.\nWhat are the advantages of Nix compared to Docker container technology?\n​\n\nNix and container technologies like Docker do have overlapping use cases, such as:\n\nMany people use Nix to manage development and build environments, as discussed in this book. On the other hand, technologies like Dev Containers, which build development environments based on containers, are also popular.\nThe DevOps/SRE field is currently dominated by container technologies based on Dockerfiles. Commonly used distributions like Ubuntu/Debian are frequently used within containers, and there are also mature options available for the host machine. In this context, what significant advantages do switching to NixOS offer?\n\nRegarding the first point of \"managing the development and build environments,\" Nix provides a development environment experience that closely resembles working directly on the host machine. This offers several advantages over Dev Containers, as outlined below:\n\nNix does not use namespaces for filesystem and network isolation, allowing easy interaction with the host machine's filesystem (including /dev for external devices) and network environment within the Nix-created development environment. In contrast, containers require various mappings to enable communication between the container and the host machine's filesystem, which can sometimes lead to file permission issues.\nDue to the absence of strong isolation, Nix development environments have no issues supporting GUI applications. Running GUI programs within this environment is as seamless as running them in the system environment.\n\nIn other words, Nix provides a development experience that is closest to the host machine, with no strong isolation. Developers can use familiar development and debugging tools in this environment, and their past development experience can be seamlessly migrated. On the other hand, if Dev Containers are used, developers may encounter various issues related to filesystem communication, network environment, user permissions, and the inability to use GUI debugging tools due to strong isolation.\n\nIf we decide to use Nix to manage all development environments, then building Docker containers based on Nix would provide the highest level of consistency. Additionally, adopting a unified technological architecture for all environments significantly reduces infrastructure maintenance costs. This answers the second point mentioned earlier: when managing development environments with Nix as a prerequisite, using NixOS for container base images and cloud servers offers distinct advantages."
  },
  {
    "title": "Advanced Topics | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/advanced-topics/",
    "html": "Advanced Topics\n​\n\nOnce you have become familiar with NixOS, you can explore advanced topics and dive deeper into the Nix ecosystem. Here are some resources and community projects that can help you expand your knowledge:\n\nDocumentation\n​\nNix Reference Manual: A comprehensive guide to the Nix package manager, covering its design and usage from the command line.\nnixpkgs Manual: The manual for nixpkgs, which introduces its parameters, explains how to use, modify, and package Nix packages.\nNixOS Manual: A user manual for NixOS, providing configuration instructions for system-level components such as Wayland/X11 and GPU.\nnix-pills: \"Nix Pills\" is a series of guides that provide an in-depth explanation of building software packages with Nix. It offers clear and understandable explanations.\nnixos-in-production: This is a work-in-progress book hosted on LeanPub about introducing and maintaining NixOS in a production environment.\nAdvanced Techniques and Community Projects\n​\n\nOnce you are comfortable with Flakes, you can explore more advanced techniques and community projects. Here are some popular ones to try out:\n\nflake-parts: Simplifies the writing and maintenance of configurations using the Module module system.\nflake-utils-plus: A third-party package that enhances Flake configuration and provides additional powerful features.\ndigga: A comprehensive Flake template that combines functionality from various useful Nix toolkits. Note that it has a complex structure and may require some experience to navigate.\n\nThere are many other valuable community projects worth exploring. Here are a few examples:\n\nnixpak: A tool to sandbox all sorts of Nix-packaged applications, including graphical ones.\nnix-output-monitor: Beautifully displays the build progress of Nix packages, with additional information such as build time and build log.\nagenix: A tool for secrets management.\ncolmena: Tools for NixOS deployment.\nnixos-generators: A tool to generate ISO/qcow2/... from NixOS configurations.\nlanzaboote: Enables secure boot for NixOS.\nimpermanence: Helps make NixOS stateless and improves system reproducibility.\ndevbox: Lightweight, repeatable dev environments without container woes, internally powered by nix, similar to earthly.\nnixpacks: Nixpacks takes a source directory and produces an OCI compliant image that can be deployed anywhere, similar to buildpacks.\n...\n\nThese projects offer additional functionality and tools that can enhance your NixOS experience.\n\nFor more information, see the awesome-nix."
  },
  {
    "title": "Kernel Development | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/development/kernel-development",
    "html": "Kernel Development\n​\n\nWIP work in progress\n\nAn example of kernel development with flake.nix.\n\nnix\n{\n  description = \"NixOS running on LicheePi 4A\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-23.05-small\";\n\n    # custom kernel's source\n    thead-kernel = {\n      url = \"github:revyos/thead-kernel/lpi4a\";\n      flake = false;\n    };\n  };\n\n  outputs = inputs@{\n    self\n    ,nixpkgs\n    ,thead-kernel\n    ,... }:\n  let\n    pkgsKernel = import nixpkgs {\n      localSystem = \"x86_64-linux\";\n      crossSystem = {\n        config = \"riscv64-unknown-linux-gnu\";\n      };\n\n      overlays = [\n        (self: super: {\n          # use gcc 13 to compile this custom kernel\n          linuxPackages_thead = super.linuxPackagesFor (super.callPackage ./pkgs/kernel {\n            src = thead-kernel;\n            stdenv = super.gcc13Stdenv;\n            kernelPatches = with super.kernelPatches; [\n              bridge_stp_helper\n              request_key_helper\n            ];\n          });\n        })\n      ];\n    };\n  in\n  {\n    nixosConfigurations.lp4a = nixpkgs.lib.nixosSystem {\n      system = \"x86_64-linux\";\n\n      specialArgs = {\n        inherit nixpkgs pkgsKernel;\n      };\n      modules = [\n        {\n          # cross-compile this flake.\n          nixpkgs.crossSystem = {\n            system = \"riscv64-linux\";\n          };\n        }\n\n        ./modules/licheepi4a.nix\n        ./modules/sd-image-lp4a.nix\n      ];\n    };\n\n    # use `nix develop .#kernel` to enter the environment with the custom kernel build environment available.\n    # and then use `unpackPhase` to unpack the kernel source code and cd into it.\n    # then you can use `make menuconfig` to configure the kernel.\n    #\n    # problem\n    #   - using `make menuconfig` - Unable to find the ncurses package.\n    devShells.x86_64-linux.kernel = pkgsKernel.linuxPackages_thead.kernel.dev;\n\n    # use `nix develop .#fhs` to enter the fhs test environment defined here.\n    devShells.x86_64-linux.fhs = let\n      pkgs = import nixpkgs {\n        system = \"x86_64-linux\";\n      };\n    in\n      # the code here is mainly copied from:\n      #   https://nixos.wiki/wiki/Linux_kernel#Embedded_Linux_Cross-compile_xconfig_and_menuconfig\n      (pkgs.buildFHSUserEnv {\n        name = \"kernel-build-env\";\n        targetPkgs = pkgs_: (with pkgs_;\n          [\n            # we need theses packages to run `make menuconfig` successfully.\n            pkgconfig\n            ncurses\n\n            pkgsKernel.gcc13Stdenv.cc\n            gcc\n          ]\n          ++ pkgs.linux.nativeBuildInputs);\n        runScript = pkgs.writeScript \"init.sh\" ''\n          # set the cross-compilation environment variables.\n          export CROSS_COMPILE=riscv64-unknown-linux-gnu-\n          export ARCH=riscv\n          export PKG_CONFIG_PATH=\"${pkgs.ncurses.dev}/lib/pkgconfig:\"\n          exec bash\n        '';\n      }).env;\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n\n\nWith the above flake.nix, I can enter the kernel build environment with nix develop .#kernel, and then use unpackPhase to unpack the kernel source code and cd into it. But I can't use make menuconfig to configure the kernel, because the ncurses package is missing in this environment.\n\nTo solve this problem, I add a fhs environment to install the ncurses package and other necessary packages, and then I can use nix develop .#fhs to enter this environment and use make menuconfig to configure the kernel.\n\nReferences\n​\nLinux kernel - NixOS Wiki\nhttps://github.com/jordanisaacs/kernel-module-flake"
  },
  {
    "title": "Cross-platform Compilation | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/development/cross-platform-compilation",
    "html": "Cross-platform Compilation\n​\n\nOn any Linux platform, there are two ways to do cross-platform compilation. For example, to build an aarch64-linux program on an x86_64-linux host, you can use the following methods:\n\nUse the cross-compilation toolchain to compile the aarch64 program.\nThe disadvantage is that you cannot use the NixOS binary cache, and you need to compile everything yourself (cross-compilation also has a cache, but there is basically nothing in it).\nThe advantages are that you don't need to emulate the instruction set, and the performance is high.\nUse QEMU to emulate the aarch64 architecture and then compile the program in the emulator.\nThe disadvantage is that the instruction set is emulated, and the performance is poor.\nThe advantage is that you can use the NixOS binary cache, and you don't need to compile everything yourself.\n\nIf you use method one, you don't need to enable binfmt_misc, but you need to execute the compilation through the cross-compilation toolchain.\n\nIf you use method two, you need to enable the binfmt_misc of the aarch64 architecture in the NixOS configuration of the building machine.\n\nCross Compilation\n​\n\nnixpkgs provides a set of predefined host platforms for cross-compilation called pkgsCross. You can explore them in nix repl.\n\nshell\n› nix repl '<nixpkgs>'\nwarning: future versions of Nix will require using `--file` to load a file\nWelcome to Nix 2.13.3. Type :? for help.\n\nLoading installable ''...\nAdded 19273 variables.\nnix-repl> pkgsCross.<TAB>\npkgsCross.aarch64-android             pkgsCross.msp430\npkgsCross.aarch64-android-prebuilt    pkgsCross.musl-power\npkgsCross.aarch64-darwin              pkgsCross.musl32\npkgsCross.aarch64-embedded            pkgsCross.musl64\npkgsCross.aarch64-multiplatform       pkgsCross.muslpi\npkgsCross.aarch64-multiplatform-musl  pkgsCross.or1k\npkgsCross.aarch64be-embedded          pkgsCross.pogoplug4\npkgsCross.arm-embedded                pkgsCross.powernv\npkgsCross.armhf-embedded              pkgsCross.ppc-embedded\npkgsCross.armv7a-android-prebuilt     pkgsCross.ppc64\npkgsCross.armv7l-hf-multiplatform     pkgsCross.ppc64-musl\npkgsCross.avr                         pkgsCross.ppcle-embedded\npkgsCross.ben-nanonote                pkgsCross.raspberryPi\npkgsCross.fuloongminipc               pkgsCross.remarkable1\npkgsCross.ghcjs                       pkgsCross.remarkable2\npkgsCross.gnu32                       pkgsCross.riscv32\npkgsCross.gnu64                       pkgsCross.riscv32-embedded\npkgsCross.i686-embedded               pkgsCross.riscv64\npkgsCross.iphone32                    pkgsCross.riscv64-embedded\npkgsCross.iphone32-simulator          pkgsCross.rx-embedded\npkgsCross.iphone64                    pkgsCross.s390\npkgsCross.iphone64-simulator          pkgsCross.s390x\npkgsCross.loongarch64-linux           pkgsCross.sheevaplug\npkgsCross.m68k                        pkgsCross.vc4\npkgsCross.mingw32                     pkgsCross.wasi32\npkgsCross.mingwW64                    pkgsCross.x86_64-darwin\npkgsCross.mips-linux-gnu              pkgsCross.x86_64-embedded\npkgsCross.mips64-linux-gnuabi64       pkgsCross.x86_64-freebsd\npkgsCross.mips64-linux-gnuabin32      pkgsCross.x86_64-netbsd\npkgsCross.mips64el-linux-gnuabi64     pkgsCross.x86_64-netbsd-llvm\npkgsCross.mips64el-linux-gnuabin32    pkgsCross.x86_64-unknown-redox\npkgsCross.mipsel-linux-gnu\npkgsCross.mmix\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\nIf you want to set pkgs to a cross-compilation toolchain globally in a flake, you only need to add a Module in flake.nix, as shown below:\n\nnix\n{\n  description = \"NixOS running on LicheePi 4A\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-23.05\";\n  };\n\n  outputs = inputs@{ self, nixpkgs, ... }: {\n    nixosConfigurations.lp4a = nixpkgs.lib.nixosSystem {\n      # native platform\n      system = \"x86_64-linux\";\n      modules = [\n\n        # add this module, to enable cross-compilation.\n        {\n          nixpkgs.crossSystem = {\n            # target platform\n            system = \"riscv64-linux\";\n          };\n        }\n\n        # ...... other modules\n      ];\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nThe nixpkgs.crossSystem option is used to set pkgs to a cross-compilation toolchain, so that all the contents built will be riscv64-linux architecture.\n\nCompile through emulated system\n​\n\nThe second method is to cross-compile through the emulated system. This method does not require a cross-compilation toolchain.\n\nTo use this method, first your building machine needs to enable the binfmt_misc module in the configuration. If your building machine is NixOS, add the following configuration to your NixOS Module to enable the simulated build system of aarch64-linux and riscv64-linux architectures:\n\nnix\n{ ... }:\n{\n  # ......\n\n  # Enable binfmt emulation.\n  boot.binfmt.emulatedSystems = [ \"aarch64-linux\" \"riscv64-linux\" ];\n\n  # ......\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nAs for flake.nix, its setting method is very simple, even simpler than the setting of cross-compilation, as shown below:\n\nnix\n{\n  description = \"NixOS running on LicheePi 4A\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-23.05\";\n  };\n\n  outputs = inputs@{ self, nixpkgs, ... }: {\n    nixosConfigurations.lp4a = nixpkgs.lib.nixosSystem {\n      # native platform\n      system = \"riscv64-linux\";\n      modules = [\n        # ...... other modules\n      ];\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nYou do not need to add any additional modules, just specify system as riscv64-linux. Nix will automatically detect whether the current system is riscv64-linux during the build. If not, it will automatically build through the emulated system(QEMU). For users, these underlying operations are completely transparent.\n\nLinux binfmt_misc\n​\n\nThe previous section only provided an introduction on how to use Nix's emulated system, but if you want to understand the underlying details, here's a brief introduction.\n\nbinfmt_misc is a feature of the Linux kernel, which stands for Kernel Support for miscellaneous Binary Formats. It enables Linux to run programs for almost any CPU architecture, including X86_64, ARM64, RISCV64, and more.\n\nTo enable binfmt_misc to run programs in various formats, two things are required: a specific identification method for the binary format and the location of the corresponding interpreter. Although binfmt_misc sounds powerful, its implementation is surprisingly easy to understand. It works similarly to how the Bash interpreter determines the interpreter to use by reading the first line of a script file (e.g., #!/usr/bin/env python3). binfmt_misc defines a set of rules, such as reading the magic number at a specific location in the binary file or determining the executable file format based on the file extension (e.g., .exe, .py). It then invokes the corresponding interpreter to execute the program. The default executable file format in Linux is ELF, but binfmt_misc expands the execution possibilities by allowing a wide range of binary files to be executed using their respective interpreters.\n\nTo register a binary program format, you need to write a line in the format :name:type:offset:magic:mask:interpreter:flags to the /proc/sys/fs/binfmt_misc/register file. The detailed explanation of the format is beyond the scope of this discussion.\n\nSince manually writing the registration information for binfmt_misc can be cumbersome, the community provides a container to assist with automatic registration. This container is called binfmt and running it will install various binfmt_misc emulators. Here's an example:\n\nshell\n# Register all architectures\npodman run --privileged --rm tonistiigi/binfmt:latest --install all\n\n# Register only common arm/riscv architectures\ndocker run --privileged --rm tonistiigi/binfmt --install arm64,riscv64,arm\n1\n2\n3\n4\n5\n\n\nThe binfmt_misc module was introduced in Linux version 2.6.12-rc2 and has undergone several minor changes in functionality since then. In Linux 4.8, the \"F\" (fix binary) flag was added, allowing the interpreter to be invoked correctly in mount namespaces and chroot environments. To work properly in containers where multiple architectures need to be built, the \"F\" flag is necessary. Therefore, the kernel version needs to be 4.8 or above.\n\nIn summary, binfmt_misc provides transparency compared to explicitly calling an interpreter to execute non-native architecture programs. With binfmt_misc, users no longer need to worry about which interpreter to use when running a program. It allows programs of any architecture to be executed directly. The configurable \"F\" flag is an added benefit, as it loads the interpreter program into memory during installation and remains unaffected by subsequent environment changes.\n\nCustom build toolchain\n​\n\nSometimes we may need to use a custom toolchain for building, such as using our own gcc, or using our own musl libc, etc. This modification can be achieved through overlays.\n\nFor example, let's try to use a different version of gcc, and test it through nix repl:\n\nshell\n\n```shell\n› nix repl -f '<nixpkgs>'\nWelcome to Nix 2.13.3. Type :? for help.\n\nLoading installable ''...\nAdded 17755 variables.\n\n# replace gcc through overlays, this will create a new instance of nixpkgs\nnix-repl> a = import <nixpkgs> { crossSystem = { config = \"riscv64-unknown-linux-gnu\"; }; overlays = [ (self: super: { gcc = self.gcc12; }) ]; }\n\n# check the gcc version, it is indeed changed to 12.2\nnix-repl> a.pkgsCross.riscv64.stdenv.cc\n«derivation /nix/store/jjvvwnf3hzk71p65x1n8bah3hrs08bpf-riscv64-unknown-linux-gnu-stage-final-gcc-wrapper-12.2.0.drv»\n\n# take a look at the default pkgs, it is still 11.3\nnix-repl> pkgs.pkgsCross.riscv64.stdenv.cc\n«derivation /nix/store/pq3g0wq3yfc4hqrikr03ixmhqxbh35q7-riscv64-unknown-linux-gnu-stage-final-gcc-wrapper-11.3.0.drv»\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nSo how to use this method in Flakes? The example flake.nix is as follows:\n\nnix\n{\n  description = \"NixOS running on LicheePi 4A\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-23.05-small\";\n  };\n\n  outputs = { self, nixpkgs, ... }:\n  {\n    nixosConfigurations.lp4a = nixpkgs.lib.nixosSystem {\n      system = \"x86_64-linux\";\n      modules = [\n        {\n          nigpkgs.crossSystem = {\n            config = \"riscv64-unknown-linux-gnu\";\n          };\n\n          # replace gcc with gcc12 through overlays\n          nixpkgs.overlays = [ (self: super: { gcc = self.gcc12; }) ];\n        }\n\n        # other moduels ......\n      ];\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nnixpkgs.overlays is used to modify the pkgs instance globally, and the modified pkgs instance will take effect to the whole flake. It will likely cause a large number of cache missing, and thus require building a large number of Nix packages locally.\n\nTo avoid this problem, a better way is to create a new pkgs instance, and only use this instance when building the packages we want to modify. The example flake.nix is as follows:\n\nnix\n{\n  description = \"NixOS running on LicheePi 4A\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-23.05-small\";\n  };\n\n  outputs = { self, nixpkgs, ... }: let\n    # create a new pkgs instance with overlays\n    pkgs-gcc12 = import nixpkgs {\n      localSystem = \"x86_64-linux\";\n      crossSystem = {\n        config = \"riscv64-unknown-linux-gnu\";\n      };\n\n      overlays = [\n        (self: super: { gcc = self.gcc12; })\n      ];\n    };\n  in {\n    nixosConfigurations.lp4a = nixpkgs.lib.nixosSystem {\n      system = \"x86_64-linux\";\n      specialArgs = {\n        # pass the new pkgs instance to the module\n        inherit pkgs-gcc12;\n      };\n      modules = [\n        {\n          nigpkgs.crossSystem = {\n            config = \"riscv64-unknown-linux-gnu\";\n          };\n        }\n\n        ({pkgs-gcc12, ...}: {\n          # use the custom pkgs instance to build the package hello\n          environment.systemPackages = [ pkgs-gcc12.hello ];\n        })\n\n        # other moduels ......\n      ];\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\nThrough the above method, we can easily customize the build toolchain of some packages without affecting the build of other packages.\n\nReferences\n​\nCross compilation - nix.dev"
  },
  {
    "title": "Distributed Building | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/development/distributed-building",
    "html": "Distributed Building\n​\n\nDistributed building can significantly speed up the build process by utilizing multiple machines. However, for ordinary NixOS users, distributed building may not be very useful since cache.nixos.org provides a vast majority of caches for the x86_64 architecture.\n\nDistributed building is particularly valuable in scenarios where no cache is available, such as:\n\nUsers of RISC-V or ARM64 architectures, especially RISC-V, as there are very few caches for these architectures in the official cache repository. Local compilation is often required.\nUsers who heavily customize their systems. The packages in the official cache repository are built with default configurations. If you modify the build parameters, the official cache is not applicable, and local compilation is necessary. For example, in embedded scenarios, customization of the underlying kernel, drivers, etc., is often required, leading to the need for local compilation.\nConfiguring Distributed Building\n​\n\nCurrently, there is no official documentation for distributed building. However, I have provided a sample distributed build configuration (a NixOS module) below, along with some recommended reference documents at the end of this section.\n\nnix\n{ ... }: {\n\n  ####################################################################\n  #\n  #  NixOS's Configuration for Remote Building / Distributed Building\n  #\n  ####################################################################\n\n  # Set local's max-jobs to 0 to force remote building (disable local building).\n  # nix.settings.max-jobs = 0;\n  nix.distributedBuilds = true;\n  nix.buildMachines =\n    let\n      sshUser = \"ryan\";\n      # Path to the SSH key on the local machine.\n      sshKey = \"/home/ryan/.ssh/ai-idols\";\n      systems = [\n        # Native architecture.\n        \"x86_64-linux\"\n\n        # Emulated architecture using binfmt_misc and qemu-user.\n        \"aarch64-linux\"\n        \"riscv64-linux\"\n      ];\n      # All available system features are poorly documented here:\n      # https://github.com/NixOS/nix/blob/e503ead/src/libstore/globals.hh#L673-L687\n      supportedFeatures = [\n        \"benchmark\"\n        \"big-parallel\"\n        \"kvm\"\n      ];\n    in\n      [\n        # Nix seems to always prioritize remote building.\n        # To make use of the local machine's high-performance CPU, do not set the remote builder's maxJobs too high.\n        {\n          # Some of my remote builders are running NixOS\n          # and have the same sshUser, sshKey, systems, etc.\n          inherit sshUser sshKey systems supportedFeatures;\n\n          # The hostName should be:\n          #   1. A hostname that can be resolved by DNS.\n          #   2. The IP address of the remote builder.\n          #   3. A host alias defined globally in /etc/ssh/ssh_config.\n          hostName = \"aquamarine\";\n          # Remote builder's max-jobs.\n          maxJobs = 3;\n          # SpeedFactor is a signed integer,\n          # but it seems that it's not used by Nix and has no effect.\n          speedFactor = 1;\n        }\n        {\n          inherit sshUser sshKey systems supportedFeatures;\n          hostName = \"ruby\";\n          maxJobs = 2;\n          speedFactor = 1;\n        }\n        {\n          inherit sshUser sshKey systems supportedFeatures;\n          hostName = \"kana\";\n          maxJobs = 2;\n          speedFactor = 1;\n        }\n      ];\n  # Optional: Useful when the builder has a faster internet connection than yours.\n\tnix.extraOptions = ''\n\t\tbuilders-use-substitutes = true\n\t'';\n\n  # Define the host aliases for remote builders.\n  # This configuration will be written to /etc/ssh/ssh_config.\n  programs.ssh.extraConfig = ''\n    Host ai\n      HostName 192.168.5.100\n      Port 22\n\n    Host aquamarine\n      HostName 192.168.5.101\n      Port 22\n\n    Host ruby\n      HostName 192.168.5.102\n      Port 22\n\n    Host kana\n      HostName 192.168.5.103\n      Port 22\n  '';\n\n  # Define the host keys for remote builders so that Nix can verify all the remote builders.\n  # This configuration will be written to /etc/ssh/ssh_known_hosts.\n  programs.ssh.knownHosts = {\n    # 星野 愛久愛海, Hoshino Aquamarine\n    aquamarine = {\n      hostNames = [ \"aquamarine\" \"192.168.5.101\" ];\n      publicKey = \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIDnCQXlllHoLX5EvU+t6yP/npsmuxKt0skHVeJashizE\";\n    };\n\n    # 星野 瑠美衣, Hoshino Rubii\n    ruby = {\n      hostNames = [ \"ruby\" \"192.168.5.102\" ];\n      publicKey = \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIE7n11XxB8B3HjdyAsL3PuLVDZxWCzEOUTJAY8+goQmW\";\n    };\n\n    # 有馬 かな, Arima Kana\n    kana = {\n      hostNames = [ \"kana\" \"192.168.5.103\" ];\n      publicKey = \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIJ3dDLOZERP1nZfRz3zIeVDm1q2Trer+fWFVvVXrgXM1\";\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n\nLimitations\n​\n\nHere are some observed issues and limitations:\n\nYou cannot specify which hosts to use at build time. You can only specify a list of hosts in the configuration file, and Nix automatically selects available hosts.\nWhen choosing a host, Nix always prefers the remote host over the local host, even if the local host has better performance. This can result in underutilization of the local host's CPU.\nThe smallest unit of distributed building is a derivation. When building large packages, other machines may remain idle for a long time, waiting for the large package to be built. This can lead to resource wastage.\nReferences\n​\nDistributed build - NixOS Wiki\nDocument available system features - nix#7380\nDistributed builds seem to disable local builds - nix#2589\nOffloading NixOS builds to a faster machine\ntests/nixos/remote-builds.nix - Nix Source Code"
  },
  {
    "title": "Dev Environments | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/development/dev-environments",
    "html": "Dev Environments\n​\n\nWe have learned how to build development environments, but it's a bit tedious to write flake.nix for each project.\n\nLuckily, some people in the community have done this for us. The following repository contains development environment templates for most programming languages. Just copy and paste them:\n\ndev-templates\nMordragT/nix-templates\n\nIf you think the structure of flake.nix is still too complicated and want a simpler way, you can consider using the following project, which encapsulates Nix more thoroughly and provides users with a simpler definition:\n\ncachix/devenv\n\nIf you don't want to write a single line of nix code and just want to get a reproducible development environment with minimal cost, here's a tool that might meet your needs:\n\njetpack-io/devbox\nDev Environment for Python\n​\n\nThe development environment for Python is much more cumbersome compared to languages like Java or Go because it defaults to installing software in the global environment. To install software for the current project, you must create a virtual environment first (unlike in languages such as JavaScript or Go, where virtual environments are not necessary). This behavior is very unfriendly for Nix.\n\nBy default, when using pip in Python, it installs software globally. On NixOS, running pip install directly will result in an error:\n\nbash\n› pip install -r requirements.txt\nerror: externally-managed-environment\n\n× This environment is externally managed\n╰─> This command has been disabled as it tries to modify the immutable\n    `/nix/store` filesystem.\n\n    To use Python with Nix and nixpkgs, have a look at the online documentation:\n    <https://nixos.org/manual/nixpkgs/stable/#python>.\n\nnote: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.\nhint: See PEP 668 for the detailed specification.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nBased on the error message, pip install is directly disabled by NixOS. Even when attempting pip install --user, it is similarly disabled. To improve the reproducibility of the environment, Nix eliminates these commands altogether. Even if we create a new environment using methods like mkShell, these commands still result in errors (presumably because the pip command in Nixpkgs itself has been modified to prevent any modification instructions like install from running).\n\nHowever, many project installation scripts are based on pip, which means these scripts cannot be used directly. Additionally, the content in nixpkgs is limited, and many packages from PyPI are missing. This requires users to package them themselves, adding a lot of complexity and mental burden.\n\nOne solution is to use the venv virtual environment. Within a virtual environment, you can use commands like pip normally:\n\nshell\npython -m venv ./env\nsource ./env/bin/activate\n1\n2\n\n\nAlternatively, you can use a third-party tool called virtualenv, but this requires additional installation.\n\nFor those who still lack confidence in the venv created directly with Python, they may prefer to include the virtual environment in /nix/store to make it immutable. This can be achieved by directly installing the dependencies from requirements.txt or poetry.toml using Nix. There are existing Nix packaging tools available to assist with this:\n\nNote that even in these environments, running commands like pip install directly will still fail. Python dependencies must be installed through flake.nix because the data is located in the /nix/store directory, and these modification commands can only be executed during the Nix build phase.\n\nDavHau/mach-nix\npoetry2nix\n\nThe advantage of these tools is that they utilize the lock mechanism of Nix Flakes to improve reproducibility. However, the downside is that they add an extra layer of abstraction, making the underlying system more complex.\n\nFinally, in some more complex projects, neither of the above solutions may be feasible. In such cases, the best solution is to use containers such as Docker or Podman. Containers have fewer restrictions compared to Nix and can provide the best compatibility."
  },
  {
    "title": "Development Environments on NixOS | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/development/intro",
    "html": "Development Environments on NixOS\n​\n\nNixOS's reproducibility makes it ideal for building development environments. However, if you're used to other distros, you may encounter problems because NixOS has its own logic. We'll briefly explain this below.\n\nOn NixOS, it's recommended to only install common tools in the global environment, such as git, vim, emacs, tmux, zsh, etc. The development environment of each language should be an independent environment for each project.\n\nYou should NOT install the development environment of each language in the global environment. The project environment should be completely isolated from each other and will not affect each other.\n\nIn the following sections, we'll introduce how the development environment works in NixOS.\n\nCreating a Development Environment\n​\n\nWe can create a development environment using pkgs.mkShell { ... } and open an interactive Bash shell of this development environment using nix develop.\n\nTo see how pkgs.mkShell works, let's take a look at its source code.\n\nnix\n{ lib, stdenv, buildEnv }:\n\n# A special kind of derivation that is only meant to be consumed by the\n# nix-shell.\n{ name ? \"nix-shell\"\n, # a list of packages to add to the shell environment\n  packages ? [ ]\n, # propagate all the inputs from the given derivations\n  inputsFrom ? [ ]\n, buildInputs ? [ ]\n, nativeBuildInputs ? [ ]\n, propagatedBuildInputs ? [ ]\n, propagatedNativeBuildInputs ? [ ]\n, ...\n}@attrs:\nlet\n  mergeInputs = name:\n    (attrs.${name} or [ ]) ++\n    (lib.subtractLists inputsFrom (lib.flatten (lib.catAttrs name inputsFrom)));\n\n  rest = builtins.removeAttrs attrs [\n    \"name\"\n    \"packages\"\n    \"inputsFrom\"\n    \"buildInputs\"\n    \"nativeBuildInputs\"\n    \"propagatedBuildInputs\"\n    \"propagatedNativeBuildInputs\"\n    \"shellHook\"\n  ];\nin\n\nstdenv.mkDerivation ({\n  inherit name;\n\n  buildInputs = mergeInputs \"buildInputs\";\n  nativeBuildInputs = packages ++ (mergeInputs \"nativeBuildInputs\");\n  propagatedBuildInputs = mergeInputs \"propagatedBuildInputs\";\n  propagatedNativeBuildInputs = mergeInputs \"propagatedNativeBuildInputs\";\n\n  shellHook = lib.concatStringsSep \"\\n\" (lib.catAttrs \"shellHook\"\n    (lib.reverseList inputsFrom ++ [ attrs ]));\n\n  phases = [ \"buildPhase\" ];\n\n  # ......\n\n  # when distributed building is enabled, prefer to build locally\n  preferLocalBuild = true;\n} // rest)\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\npkgs.mkShell { ... } is a special derivation (Nix package). Its name, buildInputs, and other parameters are customizable, and shellHook is a special parameter that will be executed when nix develop enters the environment.\n\nHere is a flake.nix that defines a development environment with Node.js 18 installed:\n\nnix\n{\n  description = \"A Nix-flake-based Node.js development environment\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-23.05\";\n  };\n\n  outputs = { self , nixpkgs ,... }: let\n    # system should match the system you are running on\n    # system = \"x86_64-linux\";\n    system = \"x86_64-darwin\";\n  in {\n    devShells.\"${system}\".default = let\n      pkgs = import nixpkgs {\n        inherit system;\n        overlays = [\n          (self: super: rec {\n            nodejs = super.nodejs-18_x;\n            pnpm = super.nodePackages.pnpm;\n            yarn = (super.yarn.override { inherit nodejs; });\n          })\n        ];\n      };\n    in pkgs.mkShell {\n      # create an environment with nodejs-18_x, pnpm, and yarn\n      packages = with pkgs; [\n        node2nix\n        nodejs\n        pnpm\n        yarn\n      ];\n\n      shellHook = ''\n        echo \"node `${pkgs.nodejs}/bin/node --version`\"\n      '';\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\nCreate an empty folder, save the above configuration as flake.nix, and then execute nix develop (or more precisely, you can use nix develop .#default), you will find that you have entered a nodejs 18 development environment, you can use node npm pnpm yarn and other commands. And when you just entered, shellHook was also executed, outputting the current version of nodejs.\n\nUsing zsh/fish/... instead of bash\n​\n\npkgs.mkShell uses bash by default, but you can also use zsh or fish by add exec <your-shell> into shellHook.\n\nHere is an example:\n\nnix\n{\n  description = \"A Nix-flake-based Node.js development environment\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-23.05\";\n  };\n\n  outputs = { self , nixpkgs ,... }: let\n    # system should match the system you are running on\n    # system = \"x86_64-linux\";\n    system = \"x86_64-darwin\";\n  in {\n    devShells.\"${system}\".default = let\n      pkgs = import nixpkgs {\n        inherit system;\n        overlays = [\n          (self: super: rec {\n            nodejs = super.nodejs-18_x;\n            pnpm = super.nodePackages.pnpm;\n            yarn = (super.yarn.override { inherit nodejs; });\n          })\n        ];\n      };\n    in pkgs.mkShell {\n      # create an environment with nodejs-18_x, pnpm, and yarn\n      packages = with pkgs; [\n        node2nix\n        nodejs\n        pnpm\n        yarn\n        nushell\n      ];\n\n      shellHook = ''\n        echo \"node `${pkgs.nodejs}/bin/node --version`\"\n        exec nu\n      '';\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\nWith the above configuration, nix develop will enter the REPL environment of nushell.\n\nEnter the build environment of any Nix package\n​\n\nNow let's take a look at nix develop, first read the help document output by nix develop --help:\n\nName\n    nix develop - run a bash shell that provides the build environment of a derivation\n\nSynopsis\n    nix develop [option...] installable\n# ......\n1\n2\n3\n4\n5\n6\n\n\nIt tells us that nix develop accepts a parameter installable, which means that we can enter the development environment of any installable Nix package through it, not just the environment created by pkgs.mkShell.\n\nBy default, nix develop will try to use the following attributes in the flake outputs:\n\ndevShells.<system>.default\npackages.<system>.default\n\nIf we use nix develop /path/to/flake#<name> to specify the flake package address and flake output name, then nix develop will try the following attributes in the flake outputs:\n\ndevShells.<system>.<name>\npackages.<system>.<name>\nlegacyPackages.<system>.<name>\n\nNow let's try it out. First, test it to confirm that We don't have c++ g++ and other compilation-related commands in the current environment:\n\nshell\nryan in 🌐 aquamarine in ~\n› c++\nc++: command not found\n\nryan in 🌐 aquamarine in ~\n› g++\ng++: command not found\n1\n2\n3\n4\n5\n6\n7\n\n\nThen use nix develop to enter the build environment of the hello package in nixpkgs:\n\nshell\n# login to the build environment of the package `hello`\nryan in 🌐 aquamarine in ~\n› nix develop nixpkgs#hello\n\nryan in 🌐 aquamarine in ~ via ❄️  impure (hello-2.12.1-env)\n› env | grep CXX\nCXX=g++\n\nryan in 🌐 aquamarine in ~ via ❄️  impure (hello-2.12.1-env)\n› c++ --version\ng++ (GCC) 12.3.0\nCopyright (C) 2022 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\nryan in 🌐 aquamarine in ~ via ❄️  impure (hello-2.12.1-env)\n› g++ --version\ng++ (GCC) 12.3.0\nCopyright (C) 2022 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nWe can see that the CXX environment variable have been set, and the c++ g++ and other commands can be used normally now.\n\nIn addition, we can also call every build phase of the hello package normally:\n\nThe default execution order of all build phases of a Nix package is: $prePhases unpackPhase patchPhase $preConfigurePhases configurePhase $preBuildPhases buildPhase checkPhase $preInstallPhases installPhase fixupPhase installCheckPhase $preDistPhases distPhase $postPhases\n\nshell\n# unpack source code\nryan in 🌐 aquamarine in /tmp/xxx via ❄️  impure (hello-2.12.1-env)\n› unpackPhase\nunpacking source archive /nix/store/pa10z4ngm0g83kx9mssrqzz30s84vq7k-hello-2.12.1.tar.gz\nsource root is hello-2.12.1\nsetting SOURCE_DATE_EPOCH to timestamp 1653865426 of file hello-2.12.1/ChangeLog\n\nryan in 🌐 aquamarine in /tmp/xxx via ❄️  impure (hello-2.12.1-env)\n› ls\nhello-2.12.1\n\nryan in 🌐 aquamarine in /tmp/xxx via ❄️  impure (hello-2.12.1-env)\n› cd hello-2.12.1/\n\n# generate Makefile\nryan in 🌐 aquamarine in /tmp/xxx/hello-2.12.1 via ❄️  impure (hello-2.12.1-env)\n› configurePhase\nconfigure flags: --prefix=/tmp/xxx/outputs/out --prefix=/tmp/xxx/outputs/out\nchecking for a BSD-compatible install... /nix/store/02dr9ymdqpkb75vf0v1z2l91z2q3izy9-coreutils-9.3/bin/install -c\nchecking whether build environment is sane... yes\nchecking for a thread-safe mkdir -p... /nix/store/02dr9ymdqpkb75vf0v1z2l91z2q3izy9-coreutils-9.3/bin/mkdir -p\nchecking for gawk... gawk\nchecking whether make sets $(MAKE)... yes\nchecking whether make supports nested variables... yes\nchecking for gcc... gcc\n# ......\nchecking that generated files are newer than configure... done\nconfigure: creating ./config.status\nconfig.status: creating Makefile\nconfig.status: creating po/Makefile.in\nconfig.status: creating config.h\nconfig.status: config.h is unchanged\nconfig.status: executing depfiles commands\nconfig.status: executing po-directories commands\nconfig.status: creating po/POTFILES\nconfig.status: creating po/Makefile\n\n# build the package\nryan in 🌐 aquamarine in /tmp/xxx/hello-2.12.1 via C v12.3.0-gcc via ❄️  impure (hello-2.12.1-env) took 2s\n› buildPhase\nbuild flags: SHELL=/run/current-system/sw/bin/bash\nmake  all-recursive\nmake[1]: Entering directory '/tmp/xxx/hello-2.12.1'\n# ......\nranlib lib/libhello.a\ngcc  -g -O2   -o hello src/hello.o  ./lib/libhello.a\nmake[2]: Leaving directory '/tmp/xxx/hello-2.12.1'\nmake[1]: Leaving directory '/tmp/xxx/hello-2.12.1'\n\n# run the built program\nryan in 🌐 aquamarine in /tmp/xxx/hello-2.12.1 via C v12.3.0-gcc via ❄️  impure (hello-2.12.1-env)\n› ./hello\nHello, world!\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\nThis usage is mainly used to debug the build process of a Nix package, or to execute some commands in the build environment of a Nix package.\n\nnix build\n​\n\nThe nix build command is used to build a software package and creates a symbolic link named result in the current directory, which points to the build result.\n\nHere's an example:\n\nbash\n# Build the package 'ponysay' from the 'nixpkgs' flake\nnix build \"nixpkgs#ponysay\"\n# Use the built 'ponysay' command\n› ./result/bin/ponysay 'hey buddy!'\n ____________ \n< hey buddy! >\n ------------ \n     \\                                  \n      \\                                 \n       \\                                \n       ▄▄  ▄▄ ▄ ▄                       \n    ▀▄▄▄█▄▄▄▄▄█▄▄▄                      \n   ▀▄███▄▄██▄██▄▄██                     \n  ▄██▄███▄▄██▄▄▄█▄██                    \n █▄█▄██▄█████████▄██                    \n  ▄▄█▄█▄▄▄▄▄████████                    \n ▀▀▀▄█▄█▄█▄▄▄▄▄█████         ▄   ▄      \n    ▀▄████▄▄▄█▄█▄▄██       ▄▄▄▄▄█▄▄▄    \n    █▄██▄▄▄▄███▄▄▄██    ▄▄▄▄▄▄▄▄▄█▄▄    \n    ▀▄▄██████▄▄▄████    █████████████   \n       ▀▀▀▀▀█████▄▄ ▄▄▄▄▄▄▄▄▄▄██▄█▄▄▀   \n            ██▄███▄▄▄▄█▄▄▀  ███▄█▄▄▄█▀  \n            █▄██▄▄▄▄▄████   ███████▄██  \n            █▄███▄▄█████    ▀███▄█████▄ \n            ██████▀▄▄▄█▄█    █▄██▄▄█▄█▄ \n           ███████ ███████   ▀████▄████ \n           ▀▀█▄▄▄▀ ▀▀█▄▄▄▀     ▀██▄▄██▀█\n                                ▀  ▀▀█\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\nOther Commands\n​\n\nThere are other commands like nix flake init, which you can explore in New Nix Commands. For more detailed information, please refer to the documentation.\n\nReferences\n​\npkgs.mkShell - nixpkgs manual\nA minimal nix-shell\nOne too many shell, Clearing up with nix' shells nix shell and nix-shell - Yannik Sander"
  },
  {
    "title": "Packging 101 | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/development/packaging-101",
    "html": "Packging 101\n​\n\nWIP work in progress\n\nTODO\n\n1. stdenv\n​\n\nTODO\n\n2. language specific frameworks\n​\n\nTODO\n\nReferences\n​\nNixOS Series 3: Software Packaging 101 - LanTian\nHow to Learn Nix, Part 28: The standard environment\nstdenv - Nixpkgs Manual\nlanguages-frameworks - Nixpkgs Manual\nUseful tools:\nnurl: Generate Nix fetcher calls from repository URLs\nnix-init: Generate Nix packages from URLs with hash prefetching, dependency inference, license detection, and more"
  },
  {
    "title": "Testing | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/other-usage-of-flakes/testing",
    "html": "Testing\n​\n\nTODO\n\nReferences\n​\nNixOS Testing library"
  },
  {
    "title": "Nix option definitions | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/other-usage-of-flakes/options",
    "html": "Nix option definitions\n​\n\nTODO\n\nReferences\n​\nNixOS option definitions - NixOS in Production\nAdvanced option definitions - NixOS in Production"
  },
  {
    "title": "Usage of the New CLI | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/other-usage-of-flakes/the-new-cli",
    "html": "Usage of the New CLI\n​\n\nOnce you have enabled the nix-command and flakes features, you can start using the new generation Nix command-line tools provided by New Nix Commands. In this section, we will focus on two commands: nix shell and nix run. Other important commands like nix build will be discussed in detail in nix develop & pkgs.mkShell\n\nnix shell\n​\n\nThe nix shell command allows you to enter an environment with the specified Nix package and opens an interactive shell within that environment:\n\nshell\n# hello is not available\n› hello\nhello: command not found\n\n# Enter an environment with the 'hello' package\n› nix shell nixpkgs#hello\n\n# hello is now available\n› hello\nHello, world!\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\nnix run\n​\n\nOn the other hand, nix run creates an environment with the specified Nix package and directly runs that package within the environment (without installing it into the system environment):\n\nshell\n# hello is not available\n› hello\nhello: command not found\n\n# Create an environment with the 'hello' package and run it\n› nix run nixpkgs#hello\nHello, world!\n1\n2\n3\n4\n5\n6\n7\n\n\nSince nix run directly executes the Nix package, the package specified as the argument must generate an executable program.\n\nAccording to the nix run --help documentation, nix run executes the command <out>/bin/<name>, where <out> is the root directory of the derivation and <name> is selected in the following order:\n\nThe meta.mainProgram attribute of the derivation\nThe pname attribute of the derivation\nThe content of the name attribute of the derivation with the version number removed\n\nFor example, in the case of the 'hello' package we tested earlier, nix run actually executes the program $out/bin/hello.\n\nHere are two more examples with detailed explanations of the relevant parameters:\n\nbash\n# Explanation of the command:\n#   `nixpkgs#ponysay` means the 'ponysay' package in the 'nixpkgs' flake.\n#   `nixpkgs` is a flake registry id, and Nix will find the corresponding GitHub repository address\n#   from <https://github.com/NixOS/flake-registry/blob/master/flake-registry.json>.\n# Therefore, this command creates a new environment, installs, and runs the 'ponysay' package provided by the 'nixpkgs' flake.\n#   Note: It has been mentioned earlier that a Nix package is one of the outputs of a flake.\necho \"Hello Nix\" | nix run \"nixpkgs#ponysay\"\n\n# This command has the same effect as the previous one, but it uses the complete flake URI instead of the flake registry id.\necho \"Hello Nix\" | nix run \"github:NixOS/nixpkgs/nixos-unstable#ponysay\"\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\nCommon Use Cases for nix run and nix shell\n​\n\nThese commands are commonly used for running programs temporarily. For example, if I want to clone my configuration repository using Git on a new NixOS host without Git installed, I can use the following command:\n\nbash\nnix run nixpkgs#git clone git@github.com:ryan4yin/nix-config.git\n1\n\n\nAlternatively, I can use nix shell to enter an environment with Git and then run the git clone command:\n\nbash\nnix shell nixpkgs#git \ngit clone git@github.com:ryan4yin/nix-config.git\n1\n2\n"
  },
  {
    "title": "Flake Outputs | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/other-usage-of-flakes/outputs",
    "html": "Flake Outputs\n​\n\nIn flake.nix, the outputs section defines the different outputs that a flake can produce during its build process. A flake can have multiple outputs simultaneously, which can include but are not limited to the following:\n\nNix packages: These are named apps.<system>.<name>, packages.<system>.<name>, or legacyPackages.<system>.<name>. You can build a specific package using the command nix build .#<name>.\nNix helper functions: These are named lib.<name> and serve as libraries for other flakes to use.\nNix development environments: These are named devShells and provide isolated development environments. They can be accessed using the command nix develop.\nNixOS configurations: These are named nixosConfiguration and represent specific NixOS system configurations. You can activate a configuration using the command nixos-rebuild switch --flake .#<name>.\nNix templates: These are named templates and can be used as a starting point for creating new projects. You can generate a project using the command nix flake init --template <reference>.\nOther user-defined outputs: These outputs can be defined by the user and may be used by other Nix-related tools.\n\nHere's an example excerpt from the NixOS Wiki that demonstrates the structure of the outputs section:\n\nnix\n{\n  inputs = {\n    # ......\n  };\n\n  outputs = { self, ... }@inputs: {\n    # Executed by `nix flake check`\n    checks.\"<system>\".\"<name>\" = derivation;\n    # Executed by `nix build .#<name>`\n    packages.\"<system>\".\"<name>\" = derivation;\n    # Executed by `nix build .`\n    packages.\"<system>\".default = derivation;\n    # Executed by `nix run .#<name>`\n    apps.\"<system>\".\"<name>\" = {\n      type = \"app\";\n      program = \"<store-path>\";\n    };\n    # Executed by `nix run . -- <args?>`\n    apps.\"<system>\".default = { type = \"app\"; program = \"...\"; };\n\n    # Formatter (alejandra, nixfmt or nixpkgs-fmt)\n    formatter.\"<system>\" = derivation;\n    # Used for nixpkgs packages, also accessible via `nix build .#<name>`\n    legacyPackages.\"<system>\".\"<name>\" = derivation;\n    # Overlay, consumed by other flakes\n    overlays.\"<name>\" = final: prev: { };\n    # Default overlay\n    overlays.default = {};\n    # Nixos module, consumed by other flakes\n    nixosModules.\"<name>\" = { config }: { options = {}; config = {}; };\n    # Default module\n    nixosModules.default = {};\n    # Used with `nixos-rebuild --flake .#<hostname>`\n    # nixosConfigurations.\"<hostname>\".config.system.build.toplevel must be a derivation\n    nixosConfigurations.\"<hostname>\" = {};\n    # Used by `nix develop .#<name>`\n    devShells.\"<system>\".\"<name>\" = derivation;\n    # Used by `nix develop`\n    devShells.\"<system>\".default = derivation;\n    # Hydra build jobs\n    hydraJobs.\"<attr>\".\"<system>\" = derivation;\n    # Used by `nix flake init -t <flake>#<name>`\n    templates.\"<name>\" = {\n      path = \"<store-path>\";\n      description = \"template description goes here?\";\n    };\n    # Used by `nix flake init -t <flake>`\n    templates.default = { path = \"<store-path>\"; description = \"\"; };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n"
  },
  {
    "title": "Flake Inputs | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/other-usage-of-flakes/inputs",
    "html": "Flake Inputs\n​\n\nThe inputs section in flake.nix is an attribute set used to specify the dependencies of the current flake. There are various types of inputs, as shown in the examples below:\n\nnix\n{\n  inputs = {\n    # GitHub repository as the data source, specifying the master branch.\n    # This is the most common input format.\n    nixpkgs.url = \"github:Mic92/nixpkgs/master\";\n    # Git URL, applicable to any Git repository using the https/ssh protocol.\n    git-example.url = \"git+https://git.somehost.tld/user/path?ref=branch\";\n    # Similar to fetching a Git repository, but using the ssh protocol \n    # with key authentication. Also uses the shallow=1 parameter \n    # to avoid copying the .git directory.\n    ssh-git-example.url = \"git+ssh://git@github.com/ryan4yin/nix-secrets.git?shallow=1\";\n    # It's also possible to directly depend on a local Git repository.\n    git-directory-example.url = \"git+file:/path/to/repo?shallow=1\";\n    # Using the `dir` parameter to specify a subdirectory.\n    nixpkgs.url = \"github:foo/bar?dir=shu\";\n    # Local folder (if using an absolute path, the 'path:' prefix can be omitted).\n    directory-example.url = \"path:/path/to/repo\";\n\n    # If the data source is not a flake, set flake=false.\n    # `flake=false` is usually used to include additional source code,\n    #   configuration files, etc.\n    # In Nix code, you can directly reference files within\n    #   it using \"${inputs.bar}/xxx/xxx\" notation.\n    # For example, import \"${inputs.bar}/xxx/xxx.nix\" to import a specific nix file,\n    # or use \"${inputs.bar}/xx/xx\" as a path parameter for certain options.\n    bar = {\n      url = \"github:foo/bar/branch\";\n      flake = false;\n    };\n\n    sops-nix = {\n      url = \"github:Mic92/sops-nix\";\n      # `follows` is the inheritance syntax within inputs.\n      # Here, it ensures that sops-nix's `inputs.nixpkgs` aligns with \n      # the current flake's inputs.nixpkgs,\n      # avoiding inconsistencies in the dependency's nixpkgs version.\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n\n    # Lock the flake to a specific commit.\n    nix-doom-emacs = {\n      url = \"github:vlaci/nix-doom-emacs?rev=238b18d7b2c8239f676358634bfb32693d3706f3\";\n      flake = false;\n    };\n  };\n\n  outputs = { self, ... }@inputs: { ... };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n"
  },
  {
    "title": "Other Usage of Flakes | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/other-usage-of-flakes/intro",
    "html": "Other Usage of Flakes\n​\n\nSo far, we have extensively used Flakes to manage NixOS configurations. In this section, I will provide a brief introduction to additional features and command-line options commonly used with Flakes."
  },
  {
    "title": "Debugging Derivations and Nix Expressions | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/best-practices/debugging",
    "html": "Debugging Derivations and Nix Expressions\n​\nDebugging with nix repl\n​\n\nWe have frequently used nix repl <nixpkgs> throughout this guide to examine the source code. It is a powerful tool that helps us understand how things work in Nix.\n\nLet's take a closer look at the help message of nix repl:\n\nshell\n› nix repl -f '<nixpkgs>'\nWelcome to Nix 2.13.3. Type :? for help.\n\nLoading installable ''...\nAdded 17755 variables.\nnix-repl> :?\nThe following commands are available:\n\n  <expr>        Evaluate and print expression\n  <x> = <expr>  Bind expression to variable\n  :a <expr>     Add attributes from resulting set to scope\n  :b <expr>     Build a derivation\n  :bl <expr>    Build a derivation, creating GC roots in the working directory\n  :e <expr>     Open package or function in $EDITOR\n  :i <expr>     Build derivation, then install result into current profile\n  :l <path>     Load Nix expression and add it to scope\n  :lf <ref>     Load Nix flake and add it to scope\n  :p <expr>     Evaluate and print expression recursively\n  :q            Exit nix-repl\n  :r            Reload all files\n  :sh <expr>    Build dependencies of derivation, then start nix-shell\n  :t <expr>     Describe result of evaluation\n  :u <expr>     Build derivation, then start nix-shell\n  :doc <expr>   Show documentation of a builtin function\n  :log <expr>   Show logs for a derivation\n  :te [bool]    Enable, disable or toggle showing traces for errors\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nThere are a couple of expressions that I frequently use: :lf <ref> and :e <expr>.\n\nThe :e <expr> command is very intuitive, so I won't go into detail about it. Instead, let's focus on :lf <ref>:\n\nnix\n# cd into my nix-config repo(you should replace it with your own nix-config repo)\n› cd ~/nix-config/\n\n# enter nix repl\n› nix repl\nWelcome to Nix 2.13.3. Type :? for help.\n\n# load my nix flake and add it to scope\nnix-repl> :lf .\nAdded 16 variables.\n\n# press <TAB> to see what we have in scope\nnix-repl><TAB>\n# ......omit some outputs\n__isInt                          nixosConfigurations\n__isList                         null\n__isPath                         outPath\n__isString                       outputs\n__langVersion                    packages\n# ......omit some outputs\n\n\n# check what's in inputs\nnix-repl> inputs.<TAB>\ninputs.agenix            inputs.nixpkgs\ninputs.darwin            inputs.nixpkgs-darwin\ninputs.home-manager      inputs.nixpkgs-unstable\ninputs.hyprland          inputs.nixpkgs-wayland\ninputs.nil\ninputs.nixos-generators\n\n# check what's in inputs.nil\nnix-repl> inputs.nil.packages.\ninputs.nil.packages.aarch64-darwin\ninputs.nil.packages.aarch64-linux\ninputs.nil.packages.x86_64-darwin\ninputs.nil.packages.x86_64-linux\n\n# check the outputs of my nix flake\nnix-repl> outputs.nixosConfigurations.<TAB>\noutputs.nixosConfigurations.ai\noutputs.nixosConfigurations.aquamarine\noutputs.nixosConfigurations.kana\noutputs.nixosConfigurations.ruby\n\nnix-repl> outputs.nixosConfigurations.ai.<TAB>\noutputs.nixosConfigurations.ai._module\noutputs.nixosConfigurations.ai._type\noutputs.nixosConfigurations.ai.class\noutputs.nixosConfigurations.ai.config\noutputs.nixosConfigurations.ai.extendModules\noutputs.nixosConfigurations.ai.extraArgs\noutputs.nixosConfigurations.ai.options\noutputs.nixosConfigurations.ai.pkgs\noutputs.nixosConfigurations.ai.type\n\nnix-repl> outputs.nixosConfigurations.ai.config.\noutputs.nixosConfigurations.ai.config.age\noutputs.nixosConfigurations.ai.config.appstream\noutputs.nixosConfigurations.ai.config.assertions\noutputs.nixosConfigurations.ai.config.boot\noutputs.nixosConfigurations.ai.config.console\noutputs.nixosConfigurations.ai.config.containers\n# ......omit other outputs\n\nnix-repl> outputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.<TAB>\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.activation\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.activationPackage\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.emptyActivationPath\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.enableDebugInfo\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.enableNixpkgsReleaseCheck\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.extraActivationPath\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.extraBuilderCommands\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.extraOutputsToInstall\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.extraProfileCommands\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.file\n# ......omit other outputs\n\n\nnix-repl> outputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.sessionVariables.<TAB>\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.sessionVariables.BROWSER\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.sessionVariables.DELTA_PAGER\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.sessionVariables.EDITOR\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.sessionVariables.TERM\n# ......omit other outputs\n\n# check the value of `TERM`\nnix-repl> outputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.sessionVariables.TERM\n\"xterm-256color\"\n\n\n# check all files defined by `home.file`\nnix-repl> outputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.file.<TAB>\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.file..bash_profile\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.file..bashrc\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.file..config/fcitx5/profile\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.file..config/fcitx5/profile-bak\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.file..config/i3/config\noutputs.nixosConfigurations.ai.config.home-manager.users.ryan.home.file..config/i3/i3blocks.conf\n#......\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n\n\nAs you can see, after loading your Nix flake into the REPL, you can check every attribute of the flake. This capability is very convenient for debugging purposes.\n\nDebugging functions provided by nixpkgs\n​\n\nTODO\n\nDebugging by using NIX_DEBUG in derivation\n​\n\nTODO\n\nReferences\n​\nHow to make nix build display all commands executed by make?\nuse NIX_DEBUG=7 in derivation\nCollection of functions useful for debugging broken nix expressions."
  },
  {
    "title": "Remote Deployment | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/best-practices/remote-deployment",
    "html": "Remote Deployment\n​\n\nNix's inherent design is well-suited for remote deployment, and the Nix community offers several tools tailored for this purpose, such as NixOps and colmena. Additionally, the official tool we've used extensively, nixos-rebuild, possesses some remote deployment capabilities too.\n\nIn addition, within multi-architecture scenarios, remote deployment can optimally leverage Nix's multi-architecture support. For example, you can cross-compile an aarch64/riscv64 NixOS system on an x86_64 host, followed by remote deployment onto the corresponding hosts via SSH.\n\nRecently, I encountered a situation where I cross-compiled a NixOS system image for a RISCV64 SBC on my local machine. Consequently, I already possessed all the compilation caches for building this system locally. However, due to the lack of official binary caches for RISCV64 architecture, executing any uninstalled program directly on the development board (e.g., nix run nixpkgs#cowsay hello) triggered extensive compilations. This process consumed hours, which was quite unacceptable.\n\nBy adopting remote deployment, I could fully harness the computational power of my local high-performance CPU and the extensive compilation caches. This switch vastly improved my experience and significantly mitigated the previously time-consuming compilation issue.\n\nLet me briefly guide you through using colmena or nixos-rebuild for remote deployment.\n\nPrerequisites\n​\n\nBefore embarking on remote deployment, a few preparatory steps are necessary:\n\nTo prevent sudo password verification failures, either deploy as the root user or grant the user sudo permission without password verification.\nConfigure SSH public key authentication for the remote hosts.\n\nIt's advisable to use the root user for deployment as it's more convenient and avoids the complexities of sudo permissions.\n\nAssuming we intend to deploy remotely using the root user, the initial step involves configuring SSH public key authentication for the root user on the remote host. To accomplish this, simply add the following content to any NixOS Module in the remote host's Nix configuration (e.g., configuration.nix), then rebuild the system:\n\nnix\n# configuration.nix\n{\n\n  # ...\n\n  users.users.root.openssh.authorizedKeys.keys = [\n    # TODO Replace with your own SSH public key.\n    \"ssh-ed25519 AAAAC3Nxxxxx ryan@xxx\"\n  ];\n\n  # ...\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nFurthermore, you'll need to add the SSH private key to the SSH agent on your local machine for authentication during remote deployment:\n\nbash\nssh-add ~/.ssh/your-private-key\n1\n\nDeploy through colmena\n​\n\ncolmena doesn't directly use the familiar nixosConfigurations.xxx for remote deployment. Instead, it customizes a flake outputs named colmena. Although its structure is similar to nixosConfigurations.xxx, it's not identical.\n\nIn your system's flake.nix, add a new outputs named colmena. A simple example is shown below:\n\nnix\n{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-23.05\";\n\n    # ...\n  };\n  outputs = { self, nixpkgs }: {\n    # ...\n\n    # Add this output, colmena will read its contents for remote deployment\n    colmena = {\n      meta = {\n        nixpkgs = import nixpkgs { system = \"x86_64-linux\"; };\n\n        # This parameter functions similarly to `sepcialArgs` in `nixosConfigurations.xxx`,\n        # used for passing custom arguments to all submodules.\n        specialArgs = {\n          inherit nixpkgs;\n        };\n      };\n\n      # Host name = \"nixos-test\"\n      \"nixos-test\" = { name, nodes, ... }: {\n        # Parameters related to remote deployment\n        deployment.targetHost = \"192.168.5.42\"; # Remote host's IP address\n        deployment.targetUser = \"root\";  # Remote host's username\n\n        # This parameter functions similarly to `modules` in `nixosConfigurations.xxx`,\n        # used for importing all submodules.\n        imports = [\n          ./configuration.nix\n        ];\n      };\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\nNow you can deploy your configuration to the device:\n\nbash\nnix run nixpkgs#colmena apply\n1\n\n\nFor more advanced usage, refer to colmena's official documentation at https://colmena.cli.rs/unstable/introduction.html\n\nDeploy through nixos-rebuild\n​\n\nUsing nixos-rebuild for remote deployment has the advantage of being similar to deploying to a local host. It only requires a few additional parameters to specify the remote host's IP address, username, and other details.\n\nFor instance, to deploy the configuration defined in the nixosConfigurations.nixos-test of your flake to a remote host, use the following command:\n\nbash\nnixos-rebuild switch --flake .#nixos-text \\\n  --target-host root@192.168.4.1 --build-host localhost --verbose\n1\n2\n\n\nThe above command will build and deploy the configuration of nixos-test to a server with IP 192.168.4.1. The system build process will occur locally.\n\nIf you prefer to build the configuration on the remote host, replace --build-host localhost with --build-host root@192.168.4.1.\n\nTo avoid repeatedly using IP addresses, you can define host aliases in your local machine's ~/.ssh/config or /etc/ssh/ssh_config. For example:\n\nGenerating the SSH configuration entirely through Nix configuration is possible, and this task is left to you.\n\nbash\n› cat ~/.ssh/config\n\n# ......\n\nHost aquamarine\n  HostName 192.168.4.1\n  Port 22\n\n# ......\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nWith this setup, you can use host aliases for deployment:\n\nbash\nnixos-rebuild switch --flake .#nixos-test --target-host root@aquamarine --build-host root@aquamarine --verbose\n1\n\n\nThis offers a more convenient way to deploy using the defined host aliases."
  },
  {
    "title": "Custom NIX_PATH and Flake Registry | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/best-practices/nix-path-and-flake-registry",
    "html": "Custom NIX_PATH and Flake Registry\n​\nIntroduction to NIX_PATH\n​\n\nThe Nix search path is controlled by the environment variable NIX_PATH, which follows the same format as the Linux PATH environment variable, consisting of multiple paths separated by colons.\n\nPaths in Nix expressions that look like <name> are resolved using the path named name from the NIX_PATH.\n\nThis usage pattern is no longer recommended under the Flakes feature because it results in Flake builds depending on a mutable environment variable NIX_PATH, compromising reproducibility.\n\nHowever, in certain scenarios, we still need to use NIX_PATH, such as when we frequently use the command nix repl '<nixpkgs>', which utilizes the Nixpkgs found through NIX_PATH search.\n\nIntroduction to Flakes Registry\n​\n\nThe Flakes Registry is a center for Flake registration that assists us in using shorter IDs instead of lengthy flake repository addresses when using commands like nix run, nix shell, and more.\n\nBy default, Nix looks up the corresponding GitHub repository address for this ID from https://github.com/NixOS/flake-registry/blob/master/flake-registry.json.\n\nFor instance, if we execute nix run nixpkgs#ponysay hello, Nix will automatically retrieve the GitHub repository address for nixpkgs from the aforementioned JSON file. It then downloads the repository, locates the flake.nix within, and runs the corresponding ponysay package.\n\nCustom NIX_PATH and Flake Registry\n​\n\nThe roles of NIX_PATH and the Flake Registry have been explained earlier. In daily use, we typically want the nixpkgs used in commands like nix repl '<nixpkgs>', nix run nixpkgs#ponysay hello to match the system's nixpkgs. This requires us to customize the NIX_PATH and Flake Registry.\n\nIn your NixOS configuration, adding the following module will achieve the mentioned requirements:\n\nnix\n{\n  # Make `nix run nixpkgs#nixpkgs` use the same nixpkgs as the one used by this flake.\n  nix.registry.nixpkgs.flake = nixpkgs;\n\n  # Make `nix repl '<nixpkgs>'` use the same nixpkgs as the one used by this flake.\n  environment.etc.\"nix/inputs/nixpkgs\".source = \"${nixpkgs}\";\n  nix.nixPath = [\"/etc/nix/inputs\"];\n}\n1\n2\n3\n4\n5\n6\n7\n8\n\nReferences\n​\nChapter 15. Nix Search Paths - Nix Pills"
  },
  {
    "title": "Simplifying NixOS-Related Commands | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/best-practices/simplify-nixos-related-commands",
    "html": "Simplifying NixOS-Related Commands\n​\n\nTo simplify NixOS-related commands, I utilize a Makefile, which proves to be very convenient.\n\nAlternatively, you can also use similar tools like just and cargo-make for this purpose. Here, I will provide my approach as a reference.\n\nBelow is an example of how my Makefile looks:\n\nNOTE: The target names in the Makefile should not conflict with any file or directory names in the current directory. Otherwise, the targets will not execute.\n\nmakefile\n############################################################################\n#\n#  Nix commands related to the local machine\n#\n############################################################################\n\ndeploy:\n\tnixos-rebuild switch --flake . --use-remote-sudo\n\ndebug:\n\tnixos-rebuild switch --flake . --use-remote-sudo --show-trace --verbose\n\nupdate:\n\tnix flake update\n\nhistory:\n\tnix profile history --profile /nix/var/nix/profiles/system\n\ngc:\n\t# remove all generations older than 7 days\n\tsudo nix profile wipe-history --profile /nix/var/nix/profiles/system  --older-than 7d\n\n\t# garbage collect all unused nix store entries\n\tsudo nix store gc --debug\n\n############################################################################\n#\n#  Idols: Commands related to my remote distributed building cluster\n#\n############################################################################\n\nadd-idols-ssh-key:\n\tssh-add ~/.ssh/ai-idols\n\naqua: add-idols-ssh-key\n\tnixos-rebuild --flake .#aquamarine --target-host aquamarine --build-host aquamarine switch --use-remote-sudo\n\naqua-debug: add-idols-ssh-key\n\tnixos-rebuild --flake .#aquamarine --target-host aquamarine --build-host aquamarine switch --use-remote-sudo --show-trace --verbose\n\nruby: add-idols-ssh-key\n\tnixos-rebuild --flake .#ruby --target-host ruby --build-host ruby switch --use-remote-sudo\n\nruby-debug: add-idols-ssh-key\n\tnixos-rebuild --flake .#ruby --target-host ruby --build-host ruby switch --use-remote-sudo --show-trace --verbose\n\nidols: aqua ruby\n\nidols-debug: aqua-debug ruby-debug\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\nBy Save the above Makefile to the root directory of your Nix flake. Then, I can use make deploy to deploy the configuration to my local machine, and make idols to deploy the configuration to all my remote servers.\n\nThis approach simplifies the execution of NixOS commands by abstracting them behind target names in the Makefile, providing a more user-friendly and convenient experience."
  },
  {
    "title": "Running Downloaded Binaries on NixOS | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/best-practices/run-downloaded-binaries-on-nixos",
    "html": "Running Downloaded Binaries on NixOS\n​\n\nSince NixOS does not strictly adhere to the Filesystem Hierarchy Standard (FHS), binaries downloaded from the internet may not work directly on NixOS. However, there are various methods available to make them function properly.\n\nFor a comprehensive guide that presents ten different approaches to run downloaded binaries on NixOS, I recommend reading the article Different methods to run a non-nixos executable on Nixos and take a look at nix-alien.\n\nAmong these methods, I personally prefer creating an FHS environment to run the binary, as it proves to be both convenient and easy to use. To set up such an environment, you can add the following code to one of your Nix modules:\n\nnix\n{ config, pkgs, lib, ... }:\n\n{\n  # ......omit many configurations\n\n  environment.systemPackages = with pkgs; [\n    # ......omit many packages\n\n    # Create an FHS environment using the command `fhs`, enabling the execution of non-NixOS packages in NixOS!\n    (let base = pkgs.appimageTools.defaultFhsEnvArgs; in\n      pkgs.buildFHSUserEnv (base // {\n      name = \"fhs\";\n      targetPkgs = pkgs: (\n        # pkgs.buildFHSUserEnv provides only a minimal FHS environment,\n        # lacking many basic packages needed by most software.\n        # Therefore, we need to add them manually.\n        #\n        # pkgs.appimageTools provides basic packages required by most software.\n        (base.targetPkgs pkgs) ++ with pkgs; [\n          pkg-config\n          ncurses\n          # Feel free to add more packages here if needed.\n        ]\n      );\n      profile = \"export FHS=1\";\n      runScript = \"bash\";\n      extraOutputsToInstall = [\"dev\"];\n    }))\n  ];\n\n  # ......omit many configurations\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nAfter applying the updated configuration, you can use the fhs command to enter the FHS environment, and then execute the binary you downloaded, for example:\n\nshell\n# Activating FHS drops me into a shell that resembles a \"normal\" Linux environment.\n$ fhs\n# Check what we have in /usr/bin.\n(fhs) $ ls /usr/bin\n# Try running a non-NixOS binary downloaded from the Internet.\n(fhs) $ ./bin/code\n1\n2\n3\n4\n5\n6\n\nReferences\n​\nTips&Tricks for NixOS Desktop - NixOS Discourse: This resource provides a collection of useful tips and tricks for NixOS desktop users.\nnix-alien: Run unpatched binaries on Nix/NixOS"
  },
  {
    "title": "Overlays | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/nixpkgs/overlays",
    "html": "Overlays\n​\n\nIn the previous section, we learned about overriding derivations using the override keyword. However, this approach only affects the local derivation and doesn't modify the original derivation in pkgs. To globally modify derivations in pkgs, Nix provides a feature called \"overlays\".\n\nIn traditional Nix environments, overlays can be configured globally using the ~/.config/nixpkgs/overlays.nix or ~/.config/nixpkgs/overlays/*.nix files. However, in Flakes, to ensure system reproducibility, overlays cannot rely on configurations outside of the Git repository.\n\nWhen using Flakes to configure NixOS, both Home Manager and NixOS provide the nixpkgs.overlays option to define overlays. You can refer to the following documentation for more details:\n\nHome Manager docs - nixpkgs.overlays\nNixpkgs source code - nixpkgs.overlays\n\nLet's take a look at an example module that loads overlays. This module can be used as a Home Manager module or a NixOS module, as the definitions are the same:\n\nnix\n{ config, pkgs, lib, ... }:\n\n{\n  nixpkgs.overlays = [\n    # Overlay 1: Use `self` and `super` to express\n    # the inheritance relationship\n    (self: super: {\n      google-chrome = super.google-chrome.override {\n        commandLineArgs =\n          \"--proxy-server='https=127.0.0.1:3128;http=127.0.0.1:3128'\";\n      };\n    })\n\n    # Overlay 2: Use `final` and `prev` to express\n    # the relationship between the new and the old\n    (final: prev: {\n      steam = prev.steam.override {\n        extraPkgs = pkgs: with pkgs; [\n          keyutils\n          libkrb5\n          libpng\n          libpulseaudio\n          libvorbis\n          stdenv.cc.cc.lib\n          xorg.libXcursor\n          xorg.libXi\n          xorg.libXinerama\n          xorg.libXScrnSaver\n        ];\n        extraProfile = \"export GDK_SCALE=2\";\n      };\n    })\n\n    # Overlay 3: Define overlays in other files\n    # The content of overlay3.nix is the same as above:\n    # `(final: prev: { xxx = prev.xxx.override { ... }; })`\n    (import ./overlays/overlay3.nix)\n  ];\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\nIn the above example, we define three overlays. Overlay 1 modifies the google-chrome derivation by adding a command-line argument for a proxy server. Overlay 2 modifies the steam derivation by adding extra packages and an environment variable. Overlay 3 is defined in a separate file overlay3.nix.\n\nYou can write your own overlays following this example. Import the configuration as a NixOS module or a Home Manager module, and then deploy it to see the effect.\n\nModular overlays\n​\n\nIn the previous example, all overlays were written in a single Nix file, which can become difficult to maintain over time. To address this, we can manage overlays in a modular way.\n\nStart by creating an overlays folder in your Git repository to store all overlay configurations. Inside this folder, create a default.nix file with the following content:\n\nnix\n# import all nix files in the current folder,\n# and execute them with args as parameters\n# The return value is a list of all execution results, \n# which is the list of overlays\n\nargs:\n# execute and import all overlay files in the current\n# directory with the given args\nbuiltins.map\n  # execute and import the overlay file\n  (f: (import (./. + \"/${f}\") args))\n  # find all overlay files in the current directory\n  (builtins.filter\n    (f: f != \"default.nix\")\n    (builtins.attrNames (builtins.readDir ./.)))\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nThe default.nix file imports and executes all Nix files in the current folder (excluding default.nix) with the provided arguments. It returns a list of all overlay results.\n\nNext, write your overlay configurations in the overlays folder. For example, you can create overlays/fcitx5/default.nix with the following content:\n\nnix\n{ pkgs, config, lib, ... }:\n\n(self: super: {\n  # Customized rime-data package\n  rime-data = ./rime-data-flypy;\n  fcitx5-rime = super.fcitx5-rime.override {\n    rimeDataPkgs = [ ./rime-data-flypy ];\n  };\n})\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nIn the above example, we override the rime-data package with a custom version and modify the fcitx5-rime derivation to use the custom rime-data package.\n\nTo load all overlays returned by overlays/default.nix, add the following parameter to any NixOS module:\n\nnix\n{ config, pkgs, lib, ... } @ args:\n\n{\n  # ...\n\n  nixpkgs.overlays = import /path/to/overlays/dir;\n\n  # ...\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nFor instance, you can add it directly in flake.nix:\n\nnix\n{\n  description = \"NixOS configuration of Ryan Yin\";\n\n  # ...\n\n  inputs = {\n    # ...\n  };\n\n  outputs = inputs@{ self, nixpkgs, ... }:\n    {\n      nixosConfigurations = {\n        nixos-test = nixpkgs.lib.nixosSystem {\n          system = \"x86_64-linux\";\n          specialArgs = inputs;\n          modules = [\n            ./hosts/nixos-test\n\n            # add the following inline module definition\n            #   here, all parameters of modules are passed to overlays\n            (args: { nixpkgs.overlays = import ./overlays args; })\n\n            # ...\n          ];\n        };\n      };\n    };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nBy using this modular approach, you can conveniently organize and manage your overlays. In this example, the structure of the overlays folder would look like this:\n\ntxt\n.\n├── flake.lock\n├── flake.nix\n├── home\n├── hosts\n├── modules\n├── ...\n├── overlays\n│   ├── default.nix            # return a list of all overlays.\n│   └── fcitx5                 # fcitx5 overlay\n│       ├── default.nix\n│       ├── README.md\n│       └── rime-data-flypy    # my custom rime-data\n│           └── share\n│               └── rime-data\n│                   ├── ...\n└── README.md\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nThis modular approach simplifies the management of overlays and allows you to easily add, modify, or remove overlays as needed."
  },
  {
    "title": "The Ingenious Uses of Multiple nixpkgs Instances | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/nixpkgs/multiple-nixpkgs",
    "html": "The Ingenious Uses of Multiple nixpkgs Instances\n​\n\nIn the section Downgrade or Upgrade Packages, we have seen how to instantiate multiple distinct nixpkgs instances using the method import nixpkgs {...}. There are numerous applications for this technique, some common ones include:\n\nInstantiate nixpkgs instances with different commit IDs to install various versions of software packages. This approach was used in the previous section Downgrade or Upgrade Packages.\n\nIf you wish to utilize overlays without affecting the default nixpkgs instance, you can instantiate a new nixpkgs instance and apply overlays to it.\n\nThe nixpkgs.overlays = [...]; mentioned in the previous section on Overlays directly modifies the global nixpkgs instance. If your overlays make changes to fundamental packages, it might impact other modules. One downside is an increase in local compilation (due to cache invalidation), and there might also be functionality issues with the affected packages.\n\nIn cross-system architecture compilation, you can instantiate multiple nixpkgs instances to selectively use QEMU simulation for compilation and cross-compilation in different locations, or to add various GCC compilation parameters.\n\nIn conclusion, instantiating multiple nixpkgs instances is highly advantageous.\n\nInstantiating nixpkgs\n​\n\nLet's first understand how to instantiate a non-global nixpkgs instance. The most common syntax is as follows:\n\nnix\n{\n  # a simple example\n  pkgs-xxx = import nixpkgs {\n    system = \"x86_64-linux\";\n  };\n\n  # a more complex example (cross-compiling)\n  pkgs-yyy = import nixpkgs {\n    localSystem = \"x86_64-linux\";\n    crossSystem = {\n      config = \"riscv64-unknown-linux-gnu\";\n\n      # https://nixos.wiki/wiki/Build_flags\n      # this option equals to adding `-march=rv64gc` to CFLAGS.\n      # CFLAGS will be used as the command line arguments for gcc/clang.\n      gcc.arch = \"rv64gc\";\n      # equivalent to `-mabi=lp64d` in CFLAGS.\n      gcc.abi = \"lp64d\";\n    };\n\n    overlays = [\n      (self: super: {\n        google-chrome = super.google-chrome.override {\n          commandLineArgs =\n            \"--proxy-server='https=127.0.0.1:3128;http=127.0.0.1:3128'\";\n        };\n        # ... other overlays\n      })\n    ];\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\nWe have learned in our study of Nix syntax:\n\nThe import expression takes a path to another Nix file as an argument and returns the execution result of that Nix file. If the argument to import is a folder path, it returns the execution result of the default.nix file within that folder.\n\nnixpkgs is a flake with a default.nix file in its root directory. So, import nixpkgs essentially returns the execution result of nixpkgs/default.nix. Starting from this file, you can find that the implementation of import nixpkgs is in pkgs/top-level/impure.nix, as excerpted below:\n\nnix\n# ... skipping some lines\n\n{ # We put legacy `system` into `localSystem` if `localSystem` was not passed.\n  # If neither is passed, assume we are building packages on the current\n  # (build, in GNU Autotools parlance) platform.\n  localSystem ? { system = args.system or builtins.currentSystem; }\n\n# These are needed only because nix's `--arg` command-line logic doesn't work\n# with unnamed parameters allowed by ...\n, system ? localSystem.system\n, crossSystem ? localSystem\n\n, # Fallback: The contents of the configuration file found at $NIXPKGS_CONFIG or\n  # $HOME/.config/nixpkgs/config.nix.\n  config ? let\n  # ... skipping some lines\n\n, # Overlays are used to extend Nixpkgs collection with additional\n  # collections of packages.  These collection of packages are part of the\n  # fix-point made by Nixpkgs.\n  overlays ? let\n  # ... skipping some lines\n\n, crossOverlays ? []\n\n, ...\n} @ args:\n\n# If `localSystem` was explicitly passed, legacy `system` should\n# not be passed, and vice versa.\nassert args ? localSystem -> !(args ? system);\nassert args ? system -> !(args ? localSystem);\n\nimport ./. (builtins.removeAttrs args [ \"system\" ] // {\n  inherit config overlays localSystem;\n})\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\nTherefore, import nixpkgs {...} effectively calls this function, and the subsequent attribute set becomes the arguments for this function.\n\nConsiderations\n​\n\nWhen creating multiple nixpkgs instances, there are some details to keep in mind. Here are some common issues to consider:\n\nAccording to the article 1000 instances of nixpkgs shared by @fbewivpjsbsby, it's not a good practice to use import to customize nixpkgs in submodules or sub-flakes. This is because each import evaluates separately, creating a new nixpkgs instance each time. As the number of configurations increases, this can lead to longer build times and higher memory usage. Therefore, it's recommended to create all nixpkgs instances in the flake.nix file.\n\nWhen mixing QEMU simulation and cross-compilation, care should be taken to avoid unnecessary duplication of package compilations."
  },
  {
    "title": "Overriding | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/nixpkgs/overriding",
    "html": "Overriding\n​\n\nIn Nix, you can customize Nix packages in pkgs by using the override function, which allows you to define custom build parameters and returns a new derivation with the overridden values. Let's take a look at an example:\n\nnix\npkgs.fcitx5-rime.override { rimeDataPkgs = [ ./rime-data-flypy ]; }\n1\n\n\nIn the above example, we override the rimeDataPkgs parameter of the fcitx5-rime derivation to use a custom package called rime-data-flypy. This creates a new derivation where rimeDataPkgs is overridden, while other parameters remain unchanged.\n\nTo find out which parameters of a specific package can be overridden, there are a couple of approaches you can follow:\n\nCheck the source code of the package in the Nixpkgs repository on GitHub, such as fcitx5-rime.nix. Make sure to select the appropriate branch, such as nixos-unstable, if you are using that branch.\nUse the nix repl '<nixpkgs>' command to open a Nix REPL and then enter :e pkgs.fcitx5-rime. This opens the source code of the package in your default editor, where you can see all the parameters of the package. To learn the basic usage of nix repl, you can type :? to see the help information.\n\nBy using these methods, you can discover the input parameters of a package and determine which ones can be modified using override.\n\nFor example, let's take a look at the source code of pkgs.hello:\n\nnix\n{ callPackage\n, lib\n, stdenv\n, fetchurl\n, nixos\n, testers\n, hello\n}:\n\nstdenv.mkDerivation (finalAttrs: {\n  pname = \"hello\";\n  version = \"2.12.1\";\n\n  src = fetchurl {\n    url = \"mirror://gnu/hello/hello-${finalAttrs.version}.tar.gz\";\n    sha256 = \"sha256-jZkUKv2SV28wsM18tCqNxoCZmLxdYH2Idh9RLibH2yA=\";\n  };\n\n  doCheck = true;\n\n  # ...\n})\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nIn this example, the attributes pname, version, src, and doCheck can all be overridden using overrideAttrs. For instance:\n\nnix\nhelloWithDebug = pkgs.hello.overrideAttrs (finalAttrs: previousAttrs: {\n  doCheck = false;\n});\n1\n2\n3\n\n\nIn the above code, we use overrideAttrs to override the doCheck attribute, while leaving other attributes unchanged.\n\nYou can also override some default attributes defined in stdenv.mkDerivation using overrideAttrs. For example:\n\nnix\nhelloWithDebug = pkgs.hello.overrideAttrs (finalAttrs: previousAttrs: {\n  separateDebugInfo = true;\n});\n1\n2\n3\n\n\nIn this case, we override the separateDebugInfo attribute, which is defined in stdenv.mkDerivation, rather than in the source code of hello.\n\nTo see all the attributes defined in stdenv.mkDerivation, you can check its source code by using nix repl '<nixpkgs>' and entering :e stdenv.mkDerivation.\n\nThis will open the source code in your default editor. If you're new to using nix repl, you can type :? to see the help information."
  },
  {
    "title": "pkgs.callPackage | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/nixpkgs/callpackage",
    "html": "pkgs.callPackage\n​\n\npkgs.callPackage is used to parameterize the construction of Nix Derivation. To understand its purpose, let's first consider how we would define a Nix package (also known as a Derivation) without using pkgs.callPackage.\n\n1. Without pkgs.callPackage\n​\n\nWe can define a Nix package using code like this:\n\nnix\npkgs.writeShellScriptBin \"hello\" ''echo \"hello, ryan!\"''\n1\n\n\nTo verify this, you can use nix repl, and you'll see that the result is indeed a Derivation:\n\nshell\n› nix repl -f '<nixpkgs>'\nWelcome to Nix 2.13.5. Type :? for help.\n\nLoading installable ''...\nAdded 19203 variables.\n\nnix-repl> pkgs.writeShellScriptBin \"hello\" '' echo \"hello, xxx!\" ''\n«derivation /nix/store/zhgar12vfhbajbchj36vbbl3mg6762s8-hello.drv»\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nWhile the definition of this Derivation is quite concise, most Derivations in nixpkgs are much more complex. In previous sections, we introduced and extensively used the import xxx.nix method to import Nix expressions from other Nix files, which can enhance code maintainability.\n\nTo enhance maintainability, you can store the definition of the Derivation in a separate file, e.g., hello.nix.\nHowever, the context within hello.nix itself doesn't include the pkgs variable, so you'll need to modify its content to pass pkgs as a parameter to hello.nix.\nIn places where you need to use this Derivation, you can use import ./hello.nix pkgs to import hello.nix and use pkgs as a parameter to execute the function defined within.\n\nLet's continue to verify this using nix repl, and you'll see that the result is still a Derivation:\n\nshell\n› cat hello.nix          \npkgs:\n  pkgs.writeShellScriptBin \"hello\" '' echo \"hello, xxx!\" ''\n\n› nix repl -f '<nixpkgs>'\nWelcome to Nix 2.13.5. Type :? for help.\n\nwarning: Nix search path entry '/nix/var/nix/profiles/per-user/root/channels' does not exist, ignoring\nLoading installable ''...\nAdded 19203 variables.\n\nnix-repl> import ./hello.nix pkgs\n«derivation /nix/store/zhgar12vfhbajbchj36vbbl3mg6762s8-hello.drv»\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n2. Using pkgs.callPackage\n​\n\nIn the previous example without pkgs.callPackage, we directly passed pkgs as a parameter to hello.nix. However, this approach has some drawbacks:\n\nAll other dependencies of the hello Derivation are tightly coupled with pkgs.\nIf we need custom dependencies, we have to modify either pkgs or the content of hello.nix, which can be cumbersome.\nIn cases where hello.nix becomes complex, it's challenging to determine which Derivations from pkgs it relies on, making it difficult to analyze the dependencies between Derivations.\n\npkgs.callPackage, as a tool for parameterizing the construction of Derivations, addresses these issues. Let's take a look at its source code and comments nixpkgs/lib/customisation.nix#L101-L121:\n\nnix\n  /* Call the package function in the file `fn` with the required\n    arguments automatically.  The function is called with the\n    arguments `args`, but any missing arguments are obtained from\n    `autoArgs`.  This function is intended to be partially\n    parameterised, e.g.,\n\n      callPackage = callPackageWith pkgs;\n      pkgs = {\n        libfoo = callPackage ./foo.nix { };\n        libbar = callPackage ./bar.nix { };\n      };\n\n    If the `libbar` function expects an argument named `libfoo`, it is\n    automatically passed as an argument.  Overrides or missing\n    arguments can be supplied in `args`, e.g.\n\n      libbar = callPackage ./bar.nix {\n        libfoo = null;\n        enableX11 = true;\n      };\n  */\n  callPackageWith = autoArgs: fn: args:\n    let\n      f = if lib.isFunction fn then fn else import fn;\n      fargs = lib.functionArgs f;\n\n      # All arguments that will be passed to the function\n      # This includes automatic ones and ones passed explicitly\n      allArgs = builtins.intersectAttrs fargs autoArgs // args;    \n\n    # ......\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\nIn essence, pkgs.callPackage is used as pkgs.callPackage fn args, where the place holder fn is a Nix file or function, and args is an attribute set. Here's how it works:\n\npkgs.callPackge fn args first checks if fn is a function or a file. If it's a file, it imports the function defined within.\nAfter this step, you have a function, typically with parameters like lib, stdenv, fetchurl, and possibly some custom parameters.\nNext, pkgs.callPackge fn args merges args with the pkgs attribute set. If there are conflicts, the parameters in args will override those in pkgs.\nThen, pkgs.callPackge fn args extracts the parameters of the fn function from the merged attribute set and uses them to execute the function.\nThe result of the function execution is a Derivation, which is a Nix package.\n\nWhat can a Nix file or function, used as an argument to pkgs.callPackge, look like? You can examine examples we've used before in Nixpkgs's Advanced Usage - Introduction: hello.nix, fcitx5-rime.nix, vscode/with-extensions.nix, and firefox/common.nix. All of them can be imported using pkgs.callPackage.\n\nFor instance, if you've defined a custom NixOS kernel configuration in kernel.nix and made the development branch name and kernel source code configurable:\n\nnix\n{\n  lib,\n  stdenv,\n  linuxManualConfig,\n\n  src,\n  boardName,\n  ...\n}:\n(linuxManualConfig {\n  version = \"5.10.113-thead-1520\";\n  modDirVersion = \"5.10.113\";\n\n  inherit src lib stdenv;\n\n  # file path to the generated kernel config file(the `.config` generated by make menuconfig)\n  #\n  # here is a special usage to generate a file path from a string\n  configfile = ./. + \"${boardName}_config\";\n\n  allowImportFromDerivation = true;\n})\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nYou can use pkgs.callPackage ./hello.nix {} in any Nix module to import and use it, replacing any of its parameters as needed:\n\nnix\n{ lib, pkgs, pkgsKernel, kernel-src, ... }:\n\n{\n  # ......\n\n  boot = {\n    # ......\n    kernelPackages = pkgs.linuxPackagesFor (pkgs.callPackage ./pkgs/kernel {\n        src = kernel-src;  # kernel source is passed as a `specialArgs` and injected into this module.\n        boardName = \"licheepi4a\";  # the board name, used to generate the kernel config file path.\n    });\n\n  # ......\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nAs shown above, by using pkgs.callPackage, you can pass different src and boardName to the function defined in kernel.nix, to generate different kernel packages. This allows you to adapt the same kernel.nix to different kernel source code and development boards.\n\nThe advantages of pkgs.callPackage are:\n\nDerivation definitions are parameterized, and all dependencies of the Derivation are the function parameters in its definition. This makes it easy to analyze dependencies between Derivations.\nAll dependencies and other custom parameters of the Derivation can be easily replaced by using the second parameter of pkgs.callPackage, greatly enhancing Derivation reusability.\nWhile achieving the above two functionalities, it does not increase code complexity, as all dependencies in pkgs can be automatically injected.\n\nSo it's always recommended to use pkgs.callPackage to define Derivations.\n\nReferences\n​\nChapter 13. Callpackage Design Pattern - Nix Pills\ncallPackage, a tool for the lazy - The Summer of Nix\nDocument what callPackage does and its preconditions - Nixpkgs Issues"
  },
  {
    "title": "Nixpkgs's Advanced Usage | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/nixpkgs/intro",
    "html": "Nixpkgs's Advanced Usage\n​\n\ncallPackage, Overriding, and Overlays are the techniques occasionally used when using Nix to customize the build method of Nix packages.\n\nWe know that many programs have a large number of build parameters that need to be configured, and different users may want to use different build parameters. This is where Overriding and Overlays come in handy. Let me give you a few examples I have encountered:\n\nfcitx5-rime.nix: By default, fcitx5-rime use rime-data as the value of rimeDataPkgs, but this parameter can be customized by override.\nvscode/with-extensions.nix: This package for VS Code can also be customized by overriding the value of vscodeExtensions, thus we can install some custom plugins into VS Code.\nnix-vscode-extensions: This is a vscode plugin manager implemented by overriding vscodeExtensions.\nfirefox/common.nix: Firefox has many customizable parameters too.\n...\n\nIn short, callPackage, Overriding and Overlays can be used to customize the build parameters of Nix packages."
  },
  {
    "title": "Other Useful Tips | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/nixos-with-flakes/other-useful-tips",
    "html": "Other Useful Tips\n​\nManaging the Configuration with Git\n​\n\nNixOS configuration, being a set of text files, is well-suited for version control with Git. This allows easy rollback to a previous version in case of issues.\n\nOne thing to note: Any changes that are not committed and added to the Git staging area will be ignored by Nix after the configuration is managed using Git! So make sure your changes have been added to the staging area or committed before deploying.\n\nHowever, by default, NixOS places the configuration in /etc/nixos, which requires root permissions for modification, making it inconvenient for daily use. Thankfully, Flakes can help solve this problem by allowing you to place your flake anywhere you prefer.\n\nFor example, you can place your flake in ~/nixos-config and create a symbolic link in /etc/nixos as follows:\n\nshell\nsudo mv /etc/nixos /etc/nixos.bak  # Backup the original configuration\nsudo ln -s ~/nixos-config/ /etc/nixos\n\n# Deploy the flake.nix located at the default location (/etc/nixos)\nsudo nixos-rebuild switch\n1\n2\n3\n4\n5\n\n\nThis way, you can use Git to manage the configuration in ~/nixos-config. The configuration can be modified with regular user-level permissions and does not require root ownership.\n\nAnother approach is to delete /etc/nixos directly and specify the configuration file path each time you deploy it:\n\nshell\nsudo mv /etc/nixos /etc/nixos.bak\ncd ~/nixos-config\n\n# `--flake .#nixos-test` deploys the flake.nix located in\n# the current directory, and the nixosConfiguration's name is `nixos-test`\nsudo nixos-rebuild switch --flake .#nixos-test\n1\n2\n3\n4\n5\n6\n\n\nChoose the method that suits you best. Afterward, system rollback becomes simple. Just switch to the previous commit and deploy it:\n\nshell\ncd ~/nixos-config\n# Switch to the previous commit\ngit checkout HEAD^1\n# Deploy the flake.nix located in the current directory,\n# with the nixosConfiguration's name `nixos-test`\nsudo nixos-rebuild switch --flake .#nixos-test\n1\n2\n3\n4\n5\n6\n\n\nMore advanced Git operations are not covered here, but in general, rollback can be performed directly using Git. Only in cases of complete system crashes would you need to restart into the bootloader and boot the system from a previous historical version.\n\nViewing and Deleting Historical Data\n​\n\nAs mentioned earlier, each NixOS deployment creates a new version, and all versions are added to the system's boot options. In addition to restarting the computer, you can query all available historical versions using the following command:\n\nshell\nnix profile history --profile /nix/var/nix/profiles/system\n1\n\n\nTo clean up historical versions and free up storage space, use the following command:\n\nshell\n# Delete all historical versions older than 7 days\nsudo nix profile wipe-history --older-than 7d --profile /nix/var/nix/profiles/system\n\n# Run garbage collection after wiping history\nsudo nix store gc --debug\n1\n2\n3\n4\n5\n\n\nAnother command that returns all packages installed in the system is:\n\nshell\nnix-env -qa\n1\n\nReducing Disk Usage\n​\n\nThe following configuration can be added to your NixOS configuration to help reduce disk usage:\n\nnix\n{ lib, pkgs, ... }:\n\n{\n  # ...\n\n  # Limit the number of generations to keep\n  boot.loader.systemd-boot.configurationLimit = 10;\n  # boot.loader.grub.configurationLimit = 10;\n\n  # Perform garbage collection weekly to maintain low disk usage\n  nix.gc = {\n    automatic = true;\n    dates = \"weekly\";\n    options = \"--delete-older-than 1w\";\n };\n\n  # Optimize storage\n  # You can also manually optimize the store via:\n  #    nix-store --optimise\n  # Refer to the following link for more details:\n  # https://nixos.org/manual/nix/stable/command-ref/conf-file.html#conf-auto-optimise-store\n  nix.settings.auto-optimise-store = true;\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\nBy incorporating this configuration, you can better manage and optimize the disk usage of your NixOS system."
  },
  {
    "title": "Downgrading or Upgrading Packages | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/nixos-with-flakes/downgrade-or-upgrade-packages",
    "html": "Downgrading or Upgrading Packages\n​\n\nWhen working with Flakes, you may encounter situations where you need to downgrade or upgrade certain packages to address bugs or compatibility issues. In Flakes, package versions and hash values are directly tied to the git commit of their flake input. To modify the package version, you need to lock the git commit of the flake input.\n\nHere's an example of how you can add multiple nixpkgs inputs, each using a different git commit or branch:\n\nnix\n{\n  description = \"NixOS configuration of Ryan Yin\";\n\n  inputs = {\n    # Default to the nixos-unstable branch\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n\n    # Latest stable branch of nixpkgs, used for version rollback\n    # The current latest version is 23.05\n    nixpkgs-stable.url = \"github:nixos/nixpkgs/nixos-23.05\";\n\n    # You can also use a specific git commit hash to lock the version\n    nixpkgs-fd40cef8d.url = \"github:nixos/nixpkgs/fd40cef8d797670e203a27a91e4b8e6decf0b90c\";\n  };\n\n  outputs = inputs@{\n    self,\n    nixpkgs,\n    nixpkgs-stable,\n    nixpkgs-fd40cef8d,\n    ...\n  }: {\n    nixosConfigurations = {\n      nixos-test = nixpkgs.lib.nixosSystem rec {\n        system = \"x86_64-linux\";\n\n        # The `specialArgs` parameter passes the\n        # non-default nixpkgs instances to other nix modules\n        specialArgs = {\n          # To use packages from nixpkgs-stable,\n          # we configure some parameters for it first\n          pkgs-stable = import nixpkgs-stable {\n            # Refer to the `system` parameter from\n            # the outer scope recursively\n            system = system;\n            # To use Chrome, we need to allow the\n            # installation of non-free softwares.\n            config.allowUnfree = true;\n          };\n          pkgs-fd40cef8d = import nixpkgs-fd40cef8d {\n            system = system;\n            config.allowUnfree = true;\n          };\n        };\n\n        modules = [\n          ./hosts/nixos-test\n\n          # Omit other configurations...\n        ];\n      };\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\nIn the above example, we have defined multiple nixpkgs inputs: nixpkgs, nixpkgs-stable, and nixpkgs-fd40cef8d. Each input corresponds to a different git commit or branch.\n\nNext, you can refer to the packages from pkgs-stable or pkgs-fd40cef8d within your submodule. Here's an example of a Home Manager submodule:\n\nnix\n{\n  pkgs,\n  config,\n  # Nix will search for and inject this parameter\n  # from `specialArgs` in `flake.nix`\n  pkgs-stable,\n  # pkgs-fd40cef8d,\n  ...\n}:\n\n{\n  # Use packages from `pkgs-stable` instead of `pkgs`\n  home.packages = with pkgs-stable; [\n    firefox-wayland\n\n    # Chrome Wayland support was broken on the nixos-unstable branch,\n    # so we fallback to the stable branch for now.\n    # Reference: https://github.com/swaywm/sway/issues/7562\n    google-chrome\n  ];\n\n  programs.vscode = {\n    enable = true;\n    # Refer to vscode from `pkgs-stable` instead of `pkgs`\n    package = pkgs-stable.vscode;\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nBy adjusting the configuration as shown above, you can deploy it using sudo nixos-rebuild switch. This will downgrade your Firefox/Chrome/VSCode versions to the ones corresponding to nixpkgs-stable or nixpkgs-fd40cef8d.\n\nAccording to 1000 instances of nixpkgs, it's not a good practice to use import in submodules or subflakes to customize nixpkgs. Each import creates a new instance of nixpkgs, which increases build time and memory usage as the configuration grows. To avoid this problem, we create all nixpkgs instances in flake.nix."
  },
  {
    "title": "Updating the System | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/nixos-with-flakes/update-the-system",
    "html": "Updating the System\n​\n\nWith Flakes, updating the system is straightforward. Simply execute the following commands in /etc/nixos or any other location where you keep the configuration:\n\nshell\n# Update flake.lock\nnix flake update\n\n# Apply the updates\nsudo nixos-rebuild switch --flake .\n1\n2\n3\n4\n5\n\n\nOccasionally, you may encounter a \"sha256 mismatch\" error when running nixos-rebuild switch. This error can be resolved by updating flake.lock using nix flake update."
  },
  {
    "title": "Modularize Your NixOS Configuration | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/nixos-with-flakes/modularize-the-configuration",
    "html": "Modularize Your NixOS Configuration\n​\n\nAt this point, the skeleton of the entire system is configured. The current configuration structure in /etc/nixos should be as follows:\n\n$ tree\n.\n├── flake.lock\n├── flake.nix\n├── home.nix\n└── configuration.nix\n1\n2\n3\n4\n5\n6\n\n\nThe functions of these four files are:\n\nflake.lock: An automatically generated version-lock file that records all input sources, hash values, and version numbers of the entire flake to ensure reproducibility.\nflake.nix: The entry file that will be recognized and deployed when executing sudo nixos-rebuild switch. See Flakes - NixOS Wiki for all options of flake.nix.\nconfiguration.nix: Imported as a Nix module in flake.nix, all system-level configuration is currently written here. See Configuration - NixOS Manual for all options of configuration.nix.\nhome.nix: Imported by Home-Manager as the configuration of the user ryan in flake.nix, containing all of ryan's configuration and managing ryan's home folder. See Appendix A. Configuration Options - Home-Manager for all options of home.nix.\n\nBy modifying these files, you can declaratively change the system and home directory status.\n\nHowever, as the configuration grows, relying solely on configuration.nix and home.nix can lead to bloated and difficult-to-maintain files. A better solution is to use the Nix module system to split the configuration into multiple Nix modules and write them in a classified manner.\n\nThe Nix module system provides a parameter, imports, which accepts a list of .nix files and merges all the configuration defined in these files into the current Nix module. Note that imports will not simply overwrite duplicate configuration but handle it more reasonably. For example, if program.packages = [...] is defined in multiple modules, then imports will merge all program.packages defined in all Nix modules into one list. Attribute sets can also be merged correctly. The specific behavior can be explored by yourself.\n\nI only found a description of imports in Nixpkgs-Unstable Official Manual - evalModules Parameters: A list of modules. These are merged together to form the final configuration. It's a bit ambiguous...\n\nWith the help of imports, we can split home.nix and configuration.nix into multiple Nix modules defined in different .nix files. Lets look at an example module packages.nix:\n\nnix\n{\n  config,\n  pkgs,\n  ...\n}: {\n  imports = [\n    (import ./special-fonts-1.nix {inherit config pkgs}) # (1)\n    ./special-fonts-2.nix # (2)\n  ];\n\n  fontconfig.enable = true;\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nThis modules loads two other modules in the imports section, namely special-fonts-1.nix and special-fonts-2.nix. Both files are modules them self and look similar to this.\n\nnix\n{ config, pkgs, ...}: {\n    # Configuration stuff ...\n}\n1\n2\n3\n\n\nBoth import statements above are equivalent in the parameters they receive:\n\nStatement (1) imports the function in special-fonts-1.nix and calls it by passing {config = config; pkgs = pkgs}. Basically using the return value of the call (another partial configuration [attritbute set]) inside the imports list.\n\nStatement (2) defines a path to a module, whose function Nix will load automatically when assembling the configuration config. It will pass all matching arguments from the function in packages.nix to the loaded function in special-fonts-2.nix which results in import ./special-fonts-2.nix {config = config; pkgs = pkgs}.\n\nHere is a nice starter example of modularizing the configuration, Highly recommended:\n\nMisterio77/nix-starter-configs\n\nA more complicated example, ryan4yin/nix-config/i3-kickstarter is the configuration of my previous NixOS system with the i3 window manager. Its structure is as follows:\n\nshell\n├── flake.lock\n├── flake.nix\n├── home\n│   ├── default.nix         # here we import all submodules by imports = [...]\n│   ├── fcitx5              # fcitx5 input method's configuration\n│   │   ├── default.nix\n│   │   └── rime-data-flypy\n│   ├── i3                  # i3 window manager's configuration\n│   │   ├── config\n│   │   ├── default.nix\n│   │   ├── i3blocks.conf\n│   │   ├── keybindings\n│   │   └── scripts\n│   ├── programs\n│   │   ├── browsers.nix\n│   │   ├── common.nix\n│   │   ├── default.nix   # here we import all modules in programs folder by imports = [...]\n│   │   ├── git.nix\n│   │   ├── media.nix\n│   │   ├── vscode.nix\n│   │   └── xdg.nix\n│   ├── rofi              #  rofi launcher's configuration\n│   │   ├── configs\n│   │   │   ├── arc_dark_colors.rasi\n│   │   │   ├── arc_dark_transparent_colors.rasi\n│   │   │   ├── power-profiles.rasi\n│   │   │   ├── powermenu.rasi\n│   │   │   ├── rofidmenu.rasi\n│   │   │   └── rofikeyhint.rasi\n│   │   └── default.nix\n│   └── shell             # shell/terminal related configuration\n│       ├── common.nix\n│       ├── default.nix\n│       ├── nushell\n│       │   ├── config.nu\n│       │   ├── default.nix\n│       │   └── env.nu\n│       ├── starship.nix\n│       └── terminals.nix\n├── hosts\n│   ├── msi-rtx4090      # My main machine's configuration\n│   │   ├── default.nix  # This is the old configuration.nix, but most of the content has been split out to modules.\n│   │   └── hardware-configuration.nix  # hardware & disk related configuration, autogenerated by nixos\n│   └── nixos-test       # my test machine's configuration\n│       ├── default.nix\n│       └── hardware-configuration.nix\n├── modules          # some common NixOS modules that can be reused\n│   ├── i3.nix\n│   └── system.nix\n└── wallpaper.jpg    # wallpaper\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\nThere is no need to follow the above structure, you can organize your configuration in any way you like. The key is to use imports to import all the submodules into the main module.\n\nlib.mkOverride, lib.mkDefault, and lib.mkForce\n​\n\nIn Nix, some people use lib.mkDefault and lib.mkForce to define values. These functions are designed to set default values or force values of options.\n\nYou can explore the source code of lib.mkDefault and lib.mkForce by running nix repl -f '<nixpkgs>' and then entering :e lib.mkDefault. To learn more about nix repl, type :? for the help information.\n\nHere's the source code:\n\nnix\n  # ......\n\n  mkOverride = priority: content:\n    { _type = \"override\";\n      inherit priority content;\n    };\n\n  mkOptionDefault = mkOverride 1500; # priority of option defaults\n  mkDefault = mkOverride 1000; # used in config sections of non-user modules to set a default\n  mkImageMediaOverride = mkOverride 60; # image media profiles can be derived by inclusion into host config, hence needing to override host config, but do allow user to mkForce\n  mkForce = mkOverride 50;\n  mkVMOverride = mkOverride 10; # used by ‘nixos-rebuild build-vm’\n\n  # ......\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nIn summary, lib.mkDefault is used to set default values of options with a priority of 1000 internally, and lib.mkForce is used to force values of options with a priority of 50 internally. If you set a value of an option directly, it will be set with a default priority of 1000, the same as lib.mkDefault.\n\nThe lower the priority value, the higher the actual priority. As a result, lib.mkForce has a higher priority than lib.mkDefault. If you define multiple values with the same priority, Nix will throw an error.\n\nUsing these functions can be very helpful for modularizing the configuration. You can set default values in a low-level module (base module) and force values in a high-level module.\n\nFor example, in my configuration at ryan4yin/nix-config/blob/c515ea9/modules/nixos/core-server.nix, I define default values like this:\n\nnix\n{ lib, pkgs, ... }:\n\n{\n  # ......\n\n  nixpkgs.config.allowUnfree = lib.mkDefault false;\n\n  # ......\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nThen, for my desktop machine, I override the value in ryan4yin/nix-config/blob/c515ea9/modules/nixos/core-desktop.nix like this:\n\nnix\n{ lib, pkgs, ... }:\n\n{\n  # import the base module\n  imports = [\n    ./core-server.nix\n  ];\n\n  # override the default value defined in the base module\n  nixpkgs.config.allowUnfree = lib.mkForce true;\n\n  # ......\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\nlib.mkOrder, lib.mkBefore, and lib.mkAfter\n​\n\nIn addition to lib.mkDefault and lib.mkForce, there are also lib.mkBefore and lib.mkAfter, which are used to set the merge order of list-type options. These functions further contribute to the modularization of the configuration.\n\nAs mentioned earlier, when you define multiple values with the same override priority, Nix will throw an error. However, by using lib.mkOrder, lib.mkBefore, or lib.mkAfter, you can define multiple values with the same override priority, and they will be merged in the order you specify.\n\nTo examine the source code of lib.mkBefore, you can run nix repl -f '<nixpkgs>' and then enter :e lib.mkBefore. To learn more about nix repl, type :? for the help information:\n\nnix\n  # ......\n\n  mkOrder = priority: content:\n    { _type = \"order\";\n      inherit priority content;\n    };\n\n  mkBefore = mkOrder 500;\n  mkAfter = mkOrder 1500;\n\n  # The default priority for things that don't have a priority specified.\n  defaultPriority = 100;\n\n  # ......\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nTherefore, lib.mkBefore is a shorthand for lib.mkOrder 500, and lib.mkAfter is a shorthand for lib.mkOrder 1500.\n\nTo test the usage of lib.mkBefore and lib.mkAfter, let's create a simple Flake project:\n\nshell\n# Create flake.nix with the following content\n› cat <<EOF | sudo tee flake.nix\n{\n  description = \"Ryan's NixOS Flake\";\n\n  inputs = {\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-23.05\";\n  };\n\n  outputs = { self, nixpkgs, ... }@inputs: {\n    nixosConfigurations = {\n      \"nixos-test\" = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n\n        modules = [\n          # Demo module 1: insert 'git' at the head of the list\n          ({lib, pkgs, ...}: {\n            environment.systemPackages = lib.mkBefore [pkgs.git];\n          })\n\n          # Demo module 2: insert 'vim' at the tail of the list\n          ({lib, pkgs, ...}: {\n            environment.systemPackages = lib.mkAfter [pkgs.vim];\n          })\n\n          # Demo module 3: simply add 'curl' to the list\n          ({lib, pkgs, ...}: {\n            environment.systemPackages = with pkgs; [curl];\n          })\n        ];\n      };\n    };\n  };\n}\nEOF\n\n# Create flake.lock\n› nix flake update\n\n# Enter the nix repl environment\n› nix repl\nWelcome to Nix 2.13.3. Type :? for help.\n\n# Load the flake we just created\nnix-repl> :lf .\nAdded 9 variables.\n\n# Check the order of systemPackages\nnix-repl> outputs.nixosConfigurations.nixos-test.config.environment.systemPackages\n[ «derivation /nix/store/0xvn7ssrwa0ax646gl4hwn8cpi05zl9j-git-2.40.1.drv»\n  «derivation /nix/store/7x8qmbvfai68sf73zq9szs5q78mc0kny-curl-8.1.1.drv»\n  «derivation /nix/store/bly81l03kh0dfly9ix2ysps6kyn1hrjl-nixos-container.drv»\n  ......\n  ......\n  «derivation /nix/store/qpmpv\n\nq5azka70lvamsca4g4sf55j8994-vim-9.0.1441.drv» ]\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\nAs you can see, the order of systemPackages is git -> curl -> default packages -> vim, which matches the order we defined in flake.nix.\n\nAlthough adjusting the order of systemPackages may not be useful in practice, it can be helpful in other scenarios.\n\nReferences\n​\nNix modules: Improving Nix's discoverability and usability\nModule System - Nixpkgs"
  },
  {
    "title": "Getting Started with Home Manager | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/nixos-with-flakes/start-using-home-manager",
    "html": "Getting Started with Home Manager\n​\n\nAs I mentioned earlier, NixOS can only manage system-level configuration. To manage user-level configuration in the Home directory, we need to install Home Manager.\n\nAccording to the official Home Manager Manual, to install Home Manager as a module of NixOS, we first need to create /etc/nixos/home.nix. Here's an example of its contents:\n\nnix\n{ config, pkgs, ... }:\n\n{\n  # TODO please change the username & home direcotry to your own\n  home.username = \"ryan\";\n  home.homeDirectory = \"/home/ryan\";\n\n  # link the configuration file in current directory to the specified location in home directory\n  # home.file.\".config/i3/wallpaper.jpg\".source = ./wallpaper.jpg;\n\n  # link all files in `./scripts` to `~/.config/i3/scripts`\n  # home.file.\".config/i3/scripts\" = {\n  #   source = ./scripts;\n  #   recursive = true;   # link recursively\n  #   executable = true;  # make all files executable\n  # };\n\n  # encode the file content in nix configuration file directly\n  # home.file.\".xxx\".text = ''\n  #     xxx\n  # '';\n\n  # set cursor size and dpi for 4k monitor\n  xresources.properties = {\n    \"Xcursor.size\" = 16;\n    \"Xft.dpi\" = 172;\n  };\n\n  # basic configuration of git, please change to your own\n  programs.git = {\n    enable = true;\n    userName = \"Ryan Yin\";\n    userEmail = \"xiaoyin_c@qq.com\";\n  };\n\n  # Packages that should be installed to the user profile.\n  home.packages = with pkgs; [\n    # here is some command line tools I use frequently\n    # feel free to add your own or remove some of them\n\n    neofetch\n    nnn # terminal file manager\n\n    # archives\n    zip\n    xz\n    unzip\n    p7zip\n\n    # utils\n    ripgrep # recursively searches directories for a regex pattern\n    jq # A lightweight and flexible command-line JSON processor\n    yq-go # yaml processer https://github.com/mikefarah/yq\n    exa # A modern replacement for ‘ls’\n    fzf # A command-line fuzzy finder\n\n    # networking tools\n    mtr # A network diagnostic tool\n    iperf3\n    dnsutils  # `dig` + `nslookup`\n    ldns # replacement of `dig`, it provide the command `drill`\n    aria2 # A lightweight multi-protocol & multi-source command-line download utility\n    socat # replacement of openbsd-netcat\n    nmap # A utility for network discovery and security auditing\n    ipcalc  # it is a calculator for the IPv4/v6 addresses\n\n    # misc\n    cowsay\n    file\n    which\n    tree\n    gnused\n    gnutar\n    gawk\n    zstd\n    gnupg\n\n    # nix related\n    #\n    # it provides the command `nom` works just like `nix`\n    # with more details log output\n    nix-output-monitor\n\n    # productivity\n    hugo # static site generator\n    glow # markdown previewer in terminal\n\n    btop  # replacement of htop/nmon\n    iotop # io monitoring\n    iftop # network monitoring\n\n    # system call monitoring\n    strace # system call monitoring\n    ltrace # library call monitoring\n    lsof # list open files\n\n    # system tools\n    sysstat\n    lm_sensors # for `sensors` command\n    ethtool\n    pciutils # lspci\n    usbutils # lsusb\n  ];\n\n  # starship - an customizable prompt for any shell\n  programs.starship = {\n    enable = true;\n    # custom settings\n    settings = {\n      add_newline = false;\n      aws.disabled = true;\n      gcloud.disabled = true;\n      line_break.disabled = true;\n    };\n  };\n\n  # alacritty - a cross-platform, GPU-accelerated terminal emulator\n  programs.alacritty = {\n    enable = true;\n    # custom settings\n    settings = {\n      env.TERM = \"xterm-256color\";\n      font = {\n        size = 12;\n        draw_bold_text_with_bright_colors = true;\n      };\n      scrolling.multiplier = 5;\n      selection.save_to_clipboard = true;\n    };\n  };\n\n  programs.bash = {\n    enable = true;\n    enableCompletion = true;\n    # TODO add your cusotm bashrc here\n    bashrcExtra = ''\n      export PATH=\"$PATH:$HOME/bin:$HOME/.local/bin:$HOME/go/bin\"\n    '';\n\n    # set some aliases, feel free to add more or remove some\n    shellAliases = {\n      k = \"kubectl\";\n      urldecode = \"python3 -c 'import sys, urllib.parse as ul; print(ul.unquote_plus(sys.stdin.read()))'\";\n      urlencode = \"python3 -c 'import sys, urllib.parse as ul; print(ul.quote_plus(sys.stdin.read()))'\";\n    };\n  };\n\n  # This value determines the home Manager release that your\n  # configuration is compatible with. This helps avoid breakage\n  # when a new home Manager release introduces backwards\n  # incompatible changes.\n  #\n  # You can update home Manager without changing this value. See\n  # the home Manager release notes for a list of state version\n  # changes in each release.\n  home.stateVersion = \"23.05\";\n\n  # Let home Manager install and manage itself.\n  programs.home-manager.enable = true;\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n\n\nAfter adding /etc/nixos/home.nix, you need to import this new configuration file in /etc/nixos/flake.nix to make use of it, use the following command to generate an example in the current folder for reference:\n\nshell\nnix flake new example -t github:nix-community/home-manager#nixos\n1\n\n\nAfter adjusting the parameters, the content of /etc/nixos/flake.nix is as follows:\n\nnix\n{\n  description = \"NixOS configuration\";\n\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs/nixos-unstable\";\n    home-manager.url = \"github:nix-community/home-manager\";\n    home-manager.inputs.nixpkgs.follows = \"nixpkgs\";\n  };\n\n  outputs = inputs@{ nixpkgs, home-manager, ... }: {\n    nixosConfigurations = {\n      # TODO please change the hostname to your own\n      nixos-test = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n        modules = [\n          ./configuration.nix\n\n          # make home-manager as a module of nixos\n          # so that home-manager configuration will be deployed automatically when executing `nixos-rebuild switch`\n          home-manager.nixosModules.home-manager\n          {\n            home-manager.useGlobalPkgs = true;\n            home-manager.useUserPackages = true;\n\n            # TODO replace ryan with your own username\n            home-manager.users.ryan = import ./home.nix;\n\n            # Optionally, use home-manager.extraSpecialArgs to pass arguments to home.nix\n          }\n        ];\n      };\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\nThen run sudo nixos-rebuild switch to apply the configuration, and home-manager will be installed automatically.\n\nAfter the installation, all user-level packages and configuration can be managed through /etc/nixos/home.nix. When running sudo nixos-rebuild switch, the configuration of home-manager will be applied automatically. (It's not necessary to run home-manager switch manually!)\n\nTo find the options we can use in home.nix, referring to the following documents:\n\nHome Manager - Appendix A. Configuration Options: A list of all options, it is recommended to search for keywords in it.\nHome Manager Option Search is another option search tool with better UI.\nhome-manager: Some options are not listed in the official documentation, or the documentation is not clear enough, you can directly search and read the corresponding source code in this home-manager repo.\nHome Manager vs NixOS\n​\n\nWhen it comes to managing software packages and configurations, you often have the choice of using either NixOS modules (configuration.nix) or Home Manager (home.nix). This poses a dilemma: What are the differences between putting packages or configuration in NixOS modules vs Home Manager modules, and how should you decide?\n\nFirst, let's understand the differences. Packages and configuration installed through NixOS modules are global to the entire system. Global configurations are typically stored in /etc, and globally installed packages are linked accordingly. Regardless of the user you switch to, you can access and use these packages and configurations.\n\nOn the other hand, everything installed through Home Manager is specific to the corresponding user. Once you switch to another user, those configurations and packages become unavailable.\n\nBased on these characteristics, here is a general recommended approach:\n\nNixOS modules: Install core system components and other software packages/configurations required by all users.\nFor example, if you want a package to be accessible even when you switch to the root user, or if you want a configuration to take effect globally on the system, you should install it through a NixOS module.\nHome Manager: Use Home Manager to install all other configurations and software specific to individual users.\nHow to use packages installed by Home Manager with privileged access?\n​\n\nThe first thing that comes to mind is to switch to root, but then any packages installed by the current user through home.nix will be unavailable. let's take kubectl as an example(it's pre-installed via home.nix):\n\nsh\n# 1. kubectl is available\n› kubectl | head\nkubectl controls the Kubernetes cluster manager.\n\n Find more information at: https://kubernetes.io/docs/reference/kubectl/\n......\n\n# 2. switch user to `root`\n› sudo su\n\n# 3. kubectl is no longer available\n> kubectl\nError: nu::shell::external_command\n\n  × External command failed\n   ╭─[entry #1:1:1]\n 1 │ kubectl\n   · ───┬───\n   ·    ╰── executable was not found\n   ╰────\n  help: No such file or directory (os error 2)\n\n\n/home/ryan/nix-config> exit\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\nBut it's possible to run those packages with privileged access without switching to root, by using sudo, we temporarily grant the current user privileged access to system resources:\n\nsh\n› sudo kubectl\nkubectl controls the Kubernetes cluster manager.\n...\n1\n2\n3\n"
  },
  {
    "title": "Enabling NixOS with Flakes | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/nixos-with-flakes/nixos-with-flakes-enabled",
    "html": "Enabling NixOS with Flakes\n​\nEnabling Flakes Support\n​\n\nFlakes provide improved reproducibility and a more organized package structure, making it easier to maintain NixOS configurations compared to the traditional approach. Therefore, it is recommended to manage NixOS using Flakes.\n\nHowever, as Flakes is still an experimental feature, it is not enabled by default. To enable Flakes, you need to modify the /etc/nixos/configuration.nix file as follows:\n\nnix\n# Edit this configuration file to define what should be installed on\n# your system. Help is available in the configuration.nix(5) man page\n# and in the NixOS manual (accessible by running 'nixos-help').\n{ config, pkgs, ... }:\n\n{\n  imports =\n    [ # Include the results of the hardware scan.\n      ./hardware-configuration.nix\n    ];\n\n  # Omit the previous configuration...\n\n  # Enable Flakes and the new command-line tool\n  nix.settings.experimental-features = [ \"nix-command\" \"flakes\" ];\n\n  environment.systemPackages = with pkgs; [\n    # Flakes use Git to pull dependencies from data sources \n    git\n    vim\n    wget\n    curl\n  ];\n  # Set default editor to vim\n  environment.variables.EDITOR = \"vim\";\n\n  # Omit the rest of the configuration...\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nTo apply the changes, run sudo nixos-rebuild switch. After that, you can start writing the configuration for NixOS using Flakes.\n\nSwitching to flake.nix for System Configuration\n​\n\nAfter enabling flakes, whenever you run sudo nixos-rebuild switch, it will first attempt to read the /etc/nixos/flake.nix file. If the file is not found, it will fallback to /etc/nixos/configuration.nix.\n\nTo learn how to write a Flakes configuration, you can refer to the official Flakes templates provided by Nix. To check the available templates, run the following command:\n\nbash\nnix flake show templates\n1\n\n\nThe templates#full template contains examples covering various use cases. Let's take a look at them:\n\nbash\nnix flake init -t templates#full\ncat flake.nix\n1\n2\n\n\nAfter reviewing the example, create a file named /etc/nixos/flake.nix and copy the content of the example into it. From now on, all system modifications will be managed by Flakes using /etc/nixos/flake.nix.\n\nNote that the copied template cannot be used directly. You need to modify it to make it work. Here's an example of /etc/nixos/flake.nix:\n\nnix\n{\n  description = \"Ryan's NixOS Flake\";\n\n  # This is the standard format for flake.nix.\n  # `inputs` are the dependencies of the flake,\n  # and `outputs` function will return all the build results of the flake.\n  # Each item in `inputs` will be passed as a parameter to\n  # the `outputs` function after being pulled and built.\n  inputs = {\n    # There are many ways to reference flake inputs.\n    # The most widely used is `github:owner/name/reference`,\n    # which represents the GitHub repository URL + branch/commit-id/tag.\n\n    # Official NixOS package source, using nixos-unstable branch here\n    nixpkgs.url = \"github:NixOS/nixpkgs/nixos-unstable\";\n    # home-manager, used for managing user configuration\n    home-manager = {\n      url = \"github:nix-community/home-manager/release-23.05\";\n      # The `follows` keyword in inputs is used for inheritance.\n      # Here, `inputs.nixpkgs` of home-manager is kept consistent with\n      # the `inputs.nixpkgs` of the current flake,\n      # to avoid problems caused by different versions of nixpkgs.\n      inputs.nixpkgs.follows = \"nixpkgs\";\n    };\n  };\n\n  # `outputs` are all the build result of the flake.\n  #\n  # A flake can have many use cases and different types of outputs.\n  # \n  # parameters in function `outputs` are defined in `inputs` and\n  # can be referenced by their names. However, `self` is an exception,\n  # this special parameter points to the `outputs` itself(self-reference)\n  # \n  # The `@` syntax here is used to alias the attribute set of the\n  # inputs's parameter, making it convenient to use inside the function.\n  outputs = { self, nixpkgs, ... }@inputs: {\n    nixosConfigurations = {\n      # By default, NixOS will try to refer the nixosConfiguration with\n      # its hostname, so the system named `nixos-test` will use this one.\n      # However, the configuration name can also be specified using:\n      #   sudo nixos-rebuild switch --flake /path/to/flakes/directory#<name>\n      #\n      # The `nixpkgs.lib.nixosSystem` function is used to build this\n      # configuration, the following attribute set is its parameter.\n      #\n      # Run the following command in the flake's directory to\n      # deploy this configuration on any NixOS system:\n      #   sudo nixos-rebuild switch --flake .#nixos-test\n      \"nixos-test\" = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n\n        # The Nix module system can modularize configuration,\n        # improving the maintainability of configuration.\n        #\n        # Each parameter in the `modules` is a Nix Module, and\n        # there is a partial introduction to it in the nixpkgs manual:\n        #    <https://nixos.org/manual/nixpkgs/unstable/#module-system-introduction>\n        # It is said to be partial because the documentation is not\n        # complete, only some simple introductions.\n        # such is the current state of Nix documentation...\n        #\n        # A Nix Module can be an attribute set, or a function that\n        # returns an attribute set. By default, if a Nix Module is a\n        # function, this function have the following default parameters:\n        #\n        #  lib:     the nixpkgs function library, which provides many\n        #             useful functions for operating Nix expressions:\n        #             https://nixos.org/manual/nixpkgs/stable/#id-1.4\n        #  config:  all config options of the current flake, very useful\n        #  options: all options defined in all NixOS Modules\n        #             in the current flake\n        #  pkgs:   a collection of all packages defined in nixpkgs,\n        #            plus a set of functions related to packaging.\n        #            you can assume its default value is\n        #            `nixpkgs.legacyPackages.\"${system}\"` for now.\n        #            can be customed by `nixpkgs.pkgs` option\n        #  modulesPath: the default path of nixpkgs's modules folder,\n        #               used to import some extra modules from nixpkgs.\n        #               this parameter is rarely used,\n        #               you can ignore it for now.\n        #\n        # The default parameters mentioned above are automatically\n        # generated by Nixpkgs. \n        # However, if you need to pass other non-default parameters\n        # to the submodules, \n        # you'll have to manually configure these parameters using\n        # `specialArgs`. \n        # you must use `specialArgs` by uncomment the following line:\n        #\n        # specialArgs = {...};  # pass custom arguments into all sub module.\n        modules = [\n          # Import the configuration.nix here, so that the\n          # old configuration file can still take effect.\n          # Note: configuration.nix itself is also a Nix Module,\n          ./configuration.nix\n        ];\n      };\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n\n\nWe defined a NixOS system called nixos-test with a configuration file at ./configuration.nix, which is the classic configuration we modified before. Therefore, we can still make use of it.\n\nTo apply the configuration to a system with hostname nixos-test, run sudo nixos-rebuild switch --flake /etc/nixos#nixos-test. No changes will be made to the system because we imported the old configuration file in /etc/nixos/flake.nix, so the actual state we declared remains unchanged.\n\nThe comments in the above code are already quite detailed, but let's emphasize a few points here:\n\nDefault parameters like lib, pkgs, config, and others are automatically generated by Nixpkgs and can be automatically injected into submodules without the need for additional declarations here.\n\nIn specialArgs = {...};, the content of the attribute set is omitted here. Its contents are automatically injected into submodules through name matching.\n\nA common usage, for instance, is to directly write specialArgs = inputs;, enabling all data sources from the inputs attribute set to be used in the submodules.\nManaging System Packages with Flakes\n​\n\nAfter the switch, we can manage the system using Flakes. One common requirement is installing packages. We have previously seen how to install packages using environment.systemPackages from the official nixpkgs repository.\n\nNow let's learn how to install packages from other sources using Flakes. This provides greater flexibility, particularly when it comes to specifying software versions. Let's use Helix editor as an example.\n\nFirst, we need to add Helix as an input in flake.nix:\n\nnix\n{\n  description = \"NixOS configuration of Ryan Yin\";\n\n  # ...\n\n  inputs = {\n    # ...\n\n    # Helix editor, using version 23.05\n    helix.url = \"github:helix-editor/helix/23.05\";\n  };\n\n  outputs = inputs@{ self, nixpkgs, ... }: {\n    nixosConfigurations = {\n      nixos-test = nixpkgs.lib.nixosSystem {\n        system = \"x86_64-linux\";\n\n        # Set all input parameters as specialArgs of all sub-modules\n        # so that we can use the `helix`(an attribute in inputs) in\n        # sub-modules directly.\n        specialArgs = inputs;\n        modules = [\n          ./configuration.nix\n        ];\n      };\n    };\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nNext, update configuration.nix to install helix from the helix input:\n\nnix\n# Nix will automatically inject `helix` from specialArgs\n# into the third parameter of this function through name matching\n{ config, pkgs, helix, ... }:\n\n{\n  # Omit other configurations...\n\n  environment.systemPackages = with pkgs; [\n    git\n    vim\n    wget\n    curl\n\n    # Install Helix from the `helix` input\n    helix.packages.\"${pkgs.system}\".helix\n  ];\n\n  # Omit other configurations...\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nTo deploy the changes, run sudo nixos-rebuild switch. After that, you can start the Helix editor by running the hx command.\n\nIf your system's hostname is not nixos-test, you need to modify the name of nixosConfigurations in flake.nix, or use --flake /etc/nixos#nixos-test to specify the configuration name.\n\nAdding Custom Cache Mirrors\n​\n\nIf you don't need to customize the cache mirror, you can safely skip this section.\n\nTo accelerate package building, Nix provides https://cache.nixos.org to cache build results and avoid rebuilding packages locally.\n\nWith the classic configuration method in NixOS, additional cache sources can be added using nix-channel. However, Nix Flakes strives to avoid using any system-level configurations or environment variables as much as possible, ensuring that its build results are not affected by the environment. Therefore, after switching to Flakes, the nix-channel command becomes ineffective.\n\nTo customize the cache source, we must add the related configuration in flake.nix using the nixConfig parameter. Here's an example:\n\nnix\n{\n  description = \"NixOS configuration of Ryan Yin\";\n\n  nixConfig = {\n    experimental-features = [ \"nix-command\" \"flakes\" ];\n    substituters = [\n      # Replace the official cache with a mirror located in China\n      \"https://mirrors.ustc.edu.cn/nix-channels/store\"\n      \"https://cache.nixos.org/\"\n    ];\n\n    extra-substituters = [\n      # Nix community's cache server\n      \"https://nix-community.cachix.org\"\n    ];\n    extra-trusted-public-keys = [\n      \"nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs=\"\n    ];\n  };\n\n  inputs = {\n    # Omit some configurations...\n  };\n\n  outputs = {\n    # Omit some configurations...\n  };\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nAfter adding the new substituters, it still won't take effect. In this case, when directly deploying the configuration, you'll encounter the following warnings:\n\n...\nwarning: ignoring untrusted substituter 'https://mirrors.ustc.edu.cn/nix-channels/store', you are not a trusted user.\n...\n1\n2\n3\n\n\nThis is a security limitation of Nix, where only trusted users can properly use the set substituters. Therefore, we need to add our own user to the trusted list. Add the following configuration to any NixOS module:\n\nnix\n{\n  # ... (other configurations omitted)\n\n  # Add your own username to the trusted list\n  nix.settings.trusted-users = [ \"ryan\" ];\n\n  # ... (other configurations omitted)\n}\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nNow, to apply the configuration and make it effective, use sudo nixos-rebuild switch. Nix will prioritize searching for cached packages from the domestic mirror source after the switch.\n\nIf your system's hostname is not nixos-test, you need to modify the name of nixosConfigurations in flake.nix, or use --flake /etc/nixos#nixos-test to specify the configuration name."
  },
  {
    "title": "Introduction to Flakes | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/nixos-with-flakes/introduction-to-flakes",
    "html": "Introduction to Flakes\n​\n\nThe flakes experimental feature is a major development for Nix, it introduces a policy for managing dependencies between Nix expressions, it improves reproducibility, composability and usability in the Nix ecosystem. Although it's still an experimental feature, flakes have been widely used by the Nix community.[1]\n\nFlakes is one of the most significant changes the nix project has ever seen.[2]\n\nIn simple terms, if you've worked with some JavaScript/Go/Rust/Python, you should be familiar with files like package.json/go.mod/Cargo.toml/pyproject.toml. In these programming languages, these files are used to describe the dependencies between software packages and how to build projects.\n\nSimilarly, the package managers in these programming languages also use files like package-lock.json/go.sum/Cargo.lock/poetry.lock to lock the versions of dependencies, ensuring the reproducibility of projects.\n\nFlakes borrow ideas from these package managers to enhance the reproducibility, composability, and usability of the Nix ecosystem. Flakes introduce flake.nix, similar to package.json, to describe the dependencies between Nix packages and how to build projects. Additionally, it provides flake.lock, akin to package-lock.json, to lock the versions of dependencies, ensuring project reproducibility.\n\nA Word of Caution about Flakes caution\n​\n\nThe benefits of Flakes are evident, and the entire NixOS community has embraced it wholeheartedly. Currently, more than half of the users utilize Flakes[3], providing assurance that Flakes will not be deprecated.\n\n⚠️ However, it's important to note that Flakes is still an experimental feature. Some issues persist, and there is a possibility of introducing breaking changes during the stabilization process. The extent of these breaking changes remains uncertain.\n\nOverall, I strongly recommend everyone to use Flakes, especially since this book revolves around NixOS and Flakes. However, it's crucial to be prepared for potential problems that may arise due to forthcoming breaking changes.\n\nNix Flakes and Classic Nix\n​\n\nSince the nix-command and flakes features are still experimental, the official documentation lacks detailed coverage, and the community's documentation on them is also scattered. From the perspective of reproducibility, ease of management, and maintenance, the classic Nix package structure and CLI are no longer recommended. Therefore, I will not delve into the usage of classic Nix. Beginners are advised to start with nix-command and flakes while disregarding any content related to classic Nix.\n\nThe following are classic Nix commands and associated concepts that are no longer necessary after enabling nix-command and flakes. When searching for information, you can safely ignore them:\n\nnix-channel: nix-channel manages software package versions through stable/unstable/test channels, similar to other package management tools such as apt/yum/pacman.\nIn Flakes, the functionality of nix-channel is entirely replaced by the inputs section in flake.nix.\nnix-env: nix-env is a core command-line tool for classic Nix used to manage software packages in the user environment.\nIt installs packages from the data sources added by nix-channel, causing the installed package's version to be influenced by the channel. Packages installed with nix-env are not automatically recorded in Nix's declarative configuration and are completely independent of its control, making them challenging to reproduce on other machines. Therefore, it is not recommended to use this tool.\nThe corresponding command in Flakes is nix profile. Personally, I don't recommend it either.\nnix-shell: nix-shell creates a temporary shell environment, which is useful for development and testing.\nIn Flakes, this tool is divided into three sub-commands: nix develop, nix shell, and nix run. We will discuss these three commands in detail in the \"Development\" chapter.\nnix-build: nix-build builds Nix packages and places the build results in /nix/store, but it does not record them in Nix's declarative configuration.\nIn Flakes, nix-build is replaced by nix build.\nnix-collect-garbage: Garbage collection command used to clean up unused Store Objects in /nix/store.\nIn Nix Flakes, the corresponding command is nix store gc --debug.\nAnd other less commonly used commands are not listed here.\nYou can refer to the detailed command comparison list in Try to explain nix commands.\n\nNOTE: nix-env -qa may still be useful in some cases, as it returns all packages installed in the system.\n\nWhen Will Flakes Be Stabilized?\n​\n\nI delved into some details regarding Flakes:\n\n[RFC 0136] A Plan to Stabilize Flakes and the New CLI Incrementally: A plan to incrementally stabilize Flakes and the new CLI, still a work in progress.\nWhy Are Flakes Still Experimental? - NixOS Discourse: A post discussing why Flakes are still considered experimental.\nFlakes Are Such an Obviously Good Thing - Graham Christensen: An article emphasizing the advantages of Flakes while suggesting areas for improvement in its design and development process.\nteaching Nix 3 CLI and Flakes #281 - nix.dev: An issue about \"Teaching Nix 3 CLI and Flakes\" in nix.dev, and the conclusion is that we should not promote unstable features in nix.dev.\nDraft: 1-year Roadmap - NixOS Foundation: A roadmap provided by the NixOS Foundation, which includes plans regarding the stabilization of Flakes.\n\nAfter reviewing these resources, it seems likely that Flakes will be stabilized within one or two years, possibly accompanied by some breaking changes.\n\nFlakes - NixOS Wiki ↩︎\n\nFlakes are such an obviously good thing ↩︎\n\nDraft: 1 year roadmap - NixOS Foundation ↩︎"
  },
  {
    "title": "Get Started with NixOS | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/nixos-with-flakes/get-started-with-nixos",
    "html": "Get Started with NixOS\n​\n\nNow that we have learned the basics of the Nix language, we can start using it to configure our NixOS system. The default configuration file for NixOS is located at /etc/nixos/configuration.nix. This file contains all the declarative configuration for the system, including settings for the time zone, language, keyboard layout, network, users, file system, and boot options.\n\nTo modify the system state in a reproducible manner (which is highly recommended), we need to manually edit the /etc/nixos/configuration.nix file and then execute sudo nixos-rebuild switch to apply the modified configuration. This command generates a new system environment based on the modified configuration file, sets the new environment as the default one, and preserves the previous environment in the boot options of grub/systemd-boot. This ensures that we can always roll back to the old environment if the new one fails to start.\n\nWhile /etc/nixos/configuration.nix is the classic method for configuring NixOS, it relies on data sources configured by nix-channel and lacks a version-locking mechanism, making it challenging to ensure the reproducibility of the system. A better approach is to use Flakes, which provides reproducibility and facilitates configuration management.\n\nIn this section, we will first learn how to manage NixOS using the classic method (/etc/nixos/configuration.nix), and then we will explore the more advanced Flakes.\n\nConfiguring the System using /etc/nixos/configuration.nix\n​\n\nThe /etc/nixos/configuration.nix file is the default and classic method for configuring NixOS. While it lacks some of the advanced features of Flakes, it is still widely used and provides flexibility in system configuration.\n\nTo illustrate how to use /etc/nixos/configuration.nix, let's consider an example where we enable SSH and add a user named ryan to the system. We can achieve this by adding the following content to /etc/nixos/configuration.nix:\n\nnix\n# Edit this configuration file to define what should be installed on\n# your system.  Help is available in the configuration.nix(5) man page\n# and in the NixOS manual (accessible by running ‘nixos-help’).\n{ config, pkgs, ... }:\n\n{\n  imports =\n    [ # Include the results of the hardware scan.\n      ./hardware-configuration.nix\n    ];\n\n  # Omit previous configuration settings...\n\n  # Add user 'ryan'\n  users.users.ryan = {\n    isNormalUser = true;\n    description = \"ryan\";\n    extraGroups = [ \"networkmanager\" \"wheel\" ];\n    openssh.authorizedKeys.keys = [\n        # Replace with your own public key\n        \"ssh-ed25519 <some-public-key> ryan@ryan-pc\"\n    ];\n    packages = with pkgs; [\n      firefox\n    #  thunderbird\n    ];\n  };\n\n  # Enable the OpenSSH daemon.\n  services.openssh = {\n    enable = true;\n    settings = {\n      X11Forwarding = true;\n      PermitRootLogin = \"no\"; # disable root login\n      PasswordAuthentication = false; # disable password login\n    };\n    openFirewall = true;\n  };\n\n  # Omit the rest of the configuration...\n}\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\nIn this configuration, we declare our intention to enable the openssh service, add an SSH public key for the user 'ryan', and disable password login.\n\nTo deploy the modified configuration, run sudo nixos-rebuild switch. This command will apply the changes, generate a new system environment, and set it as the default. You can now log in to the system using SSH with the configured SSH keys.\n\nRemember that any reproducible changes to the system can be made by modifying the /etc/nixos/configuration.nix file and deploying the changes with sudo nixos-rebuild switch.\n\nTo find configuration options and documentation:\n\nUse search engines like Google, e.g., search for Chrome NixOS to find NixOS-related information about Chrome. The NixOS Wiki and the source code of Nixpkgs are usually among the top results.\nUtilize the NixOS Options Search to search for keywords.\nRefer to the Configuration section in the NixOS Manual for system-level configuration documentation.\nSearch for keywords directly in the source code of nixpkgs on GitHub.\nReferences\n​\nOverview of the NixOS Linux distribution"
  },
  {
    "title": "Basics of the Nix Language | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/the-nix-language/",
    "html": "Basics of the Nix Language\n​\n\nThe Nix language is essential for declaring configurations to be built by Nix. To fully enjoy the benefits of NixOS and Flakes, it is necessary to grasp the fundamentals of this language.\n\nThe Nix language is a straightforward functional language. If you have some programming experience, it should take you less than 2 hours to grasp its basics.\n\nTo get started, I recommend reading the following resources for a solid introduction to the Nix language:\n\nNix Language Basics - nix.dev: This tutorial provides a comprehensive overview of the basics of the Nix language.\nNix - A One Pager: A one page introduction to the Nix language.\nYou can safely skip the section on callPackage/Overriding/Overlays for now. We will cover it in the next chapter.\nNix Language: The official documentation of the Nix language.\nnix.dev & nix-1p are suitable for starter reading only, and neither of them fully introduces the full syntax of Nix. If you encounter a new syntax that you have not come across before, please refer to this official document.\n\nBy going through these materials, you will develop a solid foundation in the Nix language, allowing you to effectively utilize NixOS and Flakes."
  },
  {
    "title": "Installation | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/introduction/installation",
    "html": "Installation\n​\n\nNix can be installed in various ways:\n\nAs a package manager on macOS, Linux, or WSL.\nAs the system environment manager on NixOS, a Linux distribution that utilizes Nix for system management.\n\nThis book primarily focuses on the usage of NixOS and Flakes. Therefore, we will skip content that pertains solely to Nix(such as installation on macOS, Linux, or WSL).\n\nThe installation process of NixOS is straightforward, but we won't delve into the specifics here. For more information, please visit the official download site at https://nixos.org/download.html.\n\nIf you're using macOS, ryan4yin/nix-darwin-kickstarter may be a good starting point for you, you can learn how to use Nix with this book and take nix-darwin-kickstarter as a start point to build your own Nix configuration."
  },
  {
    "title": "前言 | NixOS 与 Flakes",
    "url": "https://nixos-and-flakes.thiscute.world/zh/preface",
    "html": "前言\n​\nNixOS 初学者之痛 - 文档与 Flakes\n​\n\nNixOS 是个非常特殊的 Linux 发行版，它构建在 Nix 包管理器之上，设计哲学也跟传统的 Ubuntu, CentOS, Arch Linux 等发行版大相径庭。\n\nNixOS 相比其他发行版最大的优势，是它的可复现能力（即在多台机器上复现出一致的系统环境的能力）以及声明式配置。\n\nNixOS 很强大，但它的强大也带来了系统复杂度的提升，提高了使用门槛。 一方面你在 Linux 发行版上积累很多经验很难在 NixOS 上复用，另一方面 NixOS 又一直因为官方文档与社区文档的散乱陈旧而饱受诟病。 这些问题都困扰着许多 NixOS 新手。\n\n再说到 Nix 包管理器的实验特性 Flakes，它借鉴了 npm/cargo 等包管理器的设计思路，使用 flake.nix 记录所有外部依赖项，使用 flake.lock 锁定所有依赖的版本，极大地增强了 Nix 包管理器及 NixOS 的可复现能力跟配置可组合能力。 因为 Flakes 的好处很大，社区非常喜欢它。据官方调查，目前 GitHub 新建的 nix 仓库超过半数都使用了 Flakes，传统的 Nix 配置方式已经不再是主流。\n\n但是另一方面 Flakes 作为一个实验性能力存在不确定性，官方文档为了保持稳定性，几乎未包含任何 Flakes 相关的内容。 这使许多 Nix/NixOS 用户感到相当困惑——他们看到大家都在用 Flakes，也想学习下它，但却发现无处学起，只能到处拼凑零散的资料、翻 Nixpkgs 源码，或者找前辈高人请教。\n\n本书的由来\n​\n\n本书最初源于我入坑 NixOS 时的一份零散学习笔记。\n\n我在今年（2023） 4 月份入坑 NixOS 时就深深地爱上了它的设计哲学，同时在朋友的推荐下我了解到了 Nix 的 Flakes 实验特性。 在对比了 Flakes 与传统的 NixOS 配置方式后，我意识到只有带上了 Flakes 的 NixOS 才符合我对它的期待。 于是我完全忽略掉了传统的 Nix 配置方式，在入门阶段就直接学习使用 Flakes 来配置我的 NixOS 系统。\n\n在学习的过程中，我发现适合新手的 Flakes 文档几乎没有，大量的文档都是传统的 Nix 配置方法，我需要从 NixOS Wiki、Zero to Nix、Nixpkgs Manual、 Nixpkgs 源码等各种资料中提取出我需要的信息，同时还要忽略掉所有非 Flakes 的内容。 这个学习过程非常曲折痛苦。 为了避免后面再次踩坑，我在学习过程中记录了大量的零散笔记。\n\n在拥有了一定使用经验后，今年 5 月初的时候我将自己的主力 PC 切换到了 NixOS，然后将这份写了大半个月的 NixOS 新手笔记整理润色后发布到了我的博客[1] ，并分享到了 NixOS 中文社区。 中文社区的朋友们表示写得很棒，在他们的建议下，我又将这篇文章翻译成了英文并分享到了 Reddit，收到了非常强烈的正反馈[2]。\n\n这份笔记分享出来后好评不断，这让我备感振奋，继续完善它的热情也高涨。 在我的持续更新下这份笔记的内容不断增多，逐渐扩充到了 2 万多字，有读者反馈阅读体验不太好，于是在他的建议下[3]， 我将文章内容迁移到了一个 GitHub 仓库，搭建了一个专门的文档站点，方便大家阅读与贡献。 同时也调整了内容的表述，去掉了一些过于个人化的内容，使其更贴近一本新手指南的风格，而不是一份随性而为的个人笔记。\n\n至此，一本中英双语的开源书籍诞生了，我给它取名叫 <NixOS & Flakes Book>，中文名叫《NixOS 与 Flakes 新手指南》。\n\n这本开源书籍的内容是我在使用 NixOS 的过程中，以及与读者的沟通中一步步优化的，读者的好评带来的成就感是我更新的最大动力，一些读者的反馈也对它的「进化」产生了很大的帮助。 我最初只是想分享一下自己的 NixOS 折腾心得，内容也写得比较随意，没想到最后却成了一本开源书籍，国外的阅读量甚至是国内的两倍，而且还得到了许多 stars ，这真是完全没预料到的。\n\n感谢所有对本书做出过贡献、提出过建议的朋友们，感谢所有读者的支持与鼓励，没有你们，这本书的内容可能会一直停留在我个人的博客上，也不会有今天的样子。\n\n我希望这本书能够帮助到更多的人，让更多的人能够享受到 NixOS 带来的乐趣，也希望这本书能够帮助到 NixOS 社区，让更多的人加入到 NixOS 社区的建设中来。\n\n本书内容仍在持续更新，还有许多内容有待完善，欢迎大家在 GitHub 上提出建议与贡献。\n\n本书的特点\n​\n以 NixOS 与 Flakes 为核心进行讲解，摈弃了传统的 Nix 配置方式\n新手友好，内容尽可能地从拥有一定 Linux 使用经验与编程经验的 NixOS 初学者角度出发进行讲解\nstep-by-step，渐进式地学习\n内容连贯，组织良好，比较成体系。读者既可以渐进式地阅读本书，也可以快速定位自己需要的信息\n捐赠\n​\n\n如果你觉得这本书对你有帮助，请考虑捐赠以支持它的开发。\n\nPatreon: https://patreon.com/ryan4yin\nBuy me a coffee: https://buymeacoffee.com/ryan4yin\n爱发电: https://afdian.net/a/ryan4yin\nEthereum: 0xB74Aa43C280cDc8d8236952400bF6427E4390855\n本书的历史反馈与相关讨论\n​\n\n英文反馈与相关讨论：\n\n[2023-05-11] NixOS & Nix Flakes - A Guide for Beginners - Reddit\n[2023-06-22] Updates: NixOS & Nix Flakes - A Guide for Beginners - Reddit\n[2023-06-24] An unofficial NixOS & Flakes book for beginners - Discourse\n[2023-07-06] This isn't an issue but it has to be said: - Discussions\n\n中文反馈与相关讨论：\n\n[2023-05-09] NixOS 与 Nix Flakes 新手入门 - v2ex 社区\n[2023-06-24] NixOS 与 Flakes | 一份非官方的新手指南 - v2ex 社区\n[2023-06-24] NixOS 与 Flakes | 一份非官方的新手指南 - 0xffff 社区\n\nNixOS 与 Nix Flakes 新手入门 ↩︎\n\nNixOS & Nix Flakes - A Guide for Beginners - Reddit ↩︎\n\nUpdates: NixOS & Nix Flakes - A Guide for Beginners - Reddit ↩︎"
  },
  {
    "title": "Advantages & Disadvantages of NixOS | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/introduction/advantages-and-disadvantages",
    "html": "Advantages & Disadvantages of NixOS\n​\nAdvantages of NixOS\n​\nDeclarative Configuration, OS as Code\nNixOS uses declarative configuration to manage the entire system environment. These configurations can be managed directly with Git, allowing the system to be restored to any historical state as long as the configuration files are preserved (provided the desired states are declared in the Nix configuration).\nNix Flakes further enhance reproducibility by utilizing a flake.lock version lock file, which records the data source addresses, hash values, and other relevant information for all dependencies. This design greatly improves Nix's reproducibility and ensures consistent build results. It draws inspiration from package management designs in programming languages like Cargo and npm.\nHighly Convenient System Customization Capability\nWith just a few configuration changes, various components of the system can be easily replaced. Nix encapsulates all the underlying complex operations within Nix packages, providing users with a concise set of declarative parameters.\nModifications are safe and switching between different desktop environments (such as GNOME, KDE, i3, and sway) is straightforward, with minimal pitfalls.\nRollback Capability\nIt is possible to roll back to any previous system state, and NixOS even includes all old versions in the boot options by default, ensuring the ability to easily revert changes. Consequently, Nix is regarded as one of the most stable package management approaches.\nNo Dependency Conflict Issues\nEach software package in Nix has a unique hash, which is incorporated into its installation path, allowing multiple versions to coexist.\nThe community is active, with a diverse range of third-party projects\nThe official package repository, nixpkgs, has numerous contributors, and many people share their Nix configurations. Exploring the NixOS ecosystem is an exciting experience, akin to discovering a new continent.\nAll historical versions are listed in the boot options of NixOS.\nImage from NixOS Discourse - 10074\nDisadvantages of NixOS\n​\nHigh Learning Curve:\nAchieving complete reproducibility and avoiding pitfalls associated with improper usage requires learning about Nix's entire design and managing the system declaratively, rather than blindly using commands like nix-env -i (similar to apt-get install).\nDisorganized Documentation:\nCurrently, Nix Flakes remains an experimental feature, and there is limited documentation specifically focused on it. Most Nix community documentation primarily covers the older nix-env/nix-channel approach. If you want to start learning directly from Nix Flakes, you need to refer to a significant amount of outdated documentation and extract the relevant information. Additionally, some core features of Nix, such as imports and the Nix Module System, lack detailed official documentation, requiring resorting to source code analysis.\nIncreased Disk Space Usage:\nTo ensure the ability to roll back the system at any time, Nix retains all historical environments by default, resulting in increased disk space usage.\nWhile this additional space usage may not be a concern on desktop computers, it can become problematic on resource-constrained cloud servers.\nObscure Error Messages:\nIn general, error messages are usually clear. However, in some cases, the error messages may not provide specific reasons, and using --show-trace can produce a lengthy internal stack trace, making it time-consuming to identify the root cause.\nTwo potential reasons for this problem are: (1) Nix is a dynamically-typed language, and various parameters are determined at runtime, and (2) error handling logic in the used flake packages may be inadequate, resulting in unclear error messages. Some obscure errors may not even be traceable through error stacks.\nMore Complex Underlying Implementation:\nNix's declarative abstraction introduces additional complexity in the underlying code compared to similar code in traditional imperative tools.\nThis complexity increases implementation difficulty and makes it more challenging to make custom modifications at the lower level. However, this burden primarily falls on Nix package maintainers, as regular users have limited exposure to the underlying complexities, reducing their burden.\nSummary\n​\n\nOverall, I believe that NixOS is suitable for developers with a certain level of Linux usage experience and programming knowledge who desire greater control over their systems.\n\nI do not recommend newcomers without any Linux usage experience to dive directly into NixOS, as it may lead to a frustrating journey.\n\nIf you have more questions about NixOS, you can refer to the last chapter of this book, FAQ."
  },
  {
    "title": "Best Practices | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/best-practices/intro",
    "html": "Best Practices\n​\n\nNix is a powerful and flexible tool that offers various approaches to accomplish tasks, which can sometimes make it challenging to determine the most suitable method for a particular job. To assist you in navigating through this vast ecosystem, I have compiled some best practices that I've learned from the community. I hope these practices prove helpful to you.\n\nReferences\n​\nTips&Tricks for NixOS Desktop - NixOS Discourse"
  },
  {
    "title": "NixOS 与 Flakes | 主页",
    "url": "https://nixos-and-flakes.thiscute.world/zh/",
    "html": "NixOS 与 Flakes\n\n一份非官方的新手指南\n\n想要学习使用 NixOS 与 Flakes 吗？在寻找一份新手友好的教程？那你可来对地方了！\n\n前言\n开始学习\n前往 GitHub 仓库"
  },
  {
    "title": "Introduction to Nix & NixOS | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/introduction",
    "html": "Introduction to Nix & NixOS\n​\n\nNix is a declarative package manager that enables users to declare the desired system state in configuration files (declarative configuration), and it takes responsibility for achieving that state.\n\nIn simple terms, \"declarative configuration\" means that users only need to declare the desired outcome. For instance, if you declare that you want to replace the i3 window manager with sway, Nix will assist you in achieving that goal. You don't have to worry about the underlying details, such as which packages sway requires for installation, which i3-related packages need to be uninstalled, or the necessary adjustments to system configuration and environment variables for sway. Nix automatically handles these details for the user (provided that the Nix packages related to sway and i3 are properly designed).\n\nNixOS, a Linux distribution built on top of the Nix package manager, can be described as \"OS as Code.\" It employs declarative Nix configuration files to describe the entire state of the operating system.\n\nAn operating system consists of various software packages, configuration files, and text/binary data, all of which represent the current state of the system. Declarative configuration can manage only the static portion of this state. Dynamic data, such as PostgreSQL, MySQL, or MongoDB data, cannot be effectively managed through declarative configuration (it is not feasible to delete all new PostgreSQL data that is not declared in the configuration during each deployment). Therefore, NixOS primarily focuses on managing the static portion of the system state in a declarative manner. Dynamic data, along with the contents in the user's home directory, remain unaffected by NixOS when rolling back to a previous generation.\n\nAlthough we cannot achieve complete system reproducibility, the /home directory, being an important user directory, contains many necessary configuration files. A significant community project called home-manager is designed to manage user-level packages and configuration files within the user's home directory.\n\nDue to Nix's features, such as being declarative and reproducible, Nix is not limited to managing desktop environments but is also extensively used for managing development environments, compilation environments, cloud virtual machines, and container image construction. NixOps (an official Nix project) and colmena (a community project) are both operational tools based on Nix.\n\nWhy NixOS?\n​\n\nI first learned about the Nix package manager several years ago. It utilizes the Nix language to describe system configuration. NixOS, the Linux distribution built on top of it, allows for rolling back the system to any previous state (although only the state declared in Nix configuration files can be rolled back). While it sounded impressive, I found it troublesome to learn a new language and write code to install packages, so I didn't pursue it at the time.\n\nHowever, I recently encountered numerous environmental issues while using EndeavourOS, and resolving them consumed a significant amount of my energy, leaving me exhausted. Upon careful consideration, I realized that the lack of version control and rollback mechanisms in EndeavourOS prevented me from restoring the system when problems arose.\n\nThat's when I decided to switch to NixOS.\n\nTo my delight, NixOS has exceeded my expectations. The most astonishing aspect is that I can now restore my entire i3 environment and all my commonly used packages on a fresh NixOS host with just one command sudo nixos-rebuild switch --flake .. It's truly fantastic!\n\nThe rollback capability and reproducibility of NixOS has instilled a great deal of confidence in me—I no longer fear breaking the system. I've even ventured into experimenting with new things on NixOS, such as the hyprland compositor. Previously, on EndeavourOS, I wouldn't have dared to tinker with such novel compositors, as any system mishaps would have entailed significant manual troubleshooting using various workarounds.\n\nThis is why I chose NixOS."
  },
  {
    "title": "Preface | NixOS & Flakes Book",
    "url": "https://nixos-and-flakes.thiscute.world/preface",
    "html": "Preface\n​\nThe Pain of NixOS Beginners - Documentation and Flakes\n​\n\nNixOS is a highly distinctive Linux distribution built upon the Nix package manager, with a design philosophy that sets it apart from traditional distributions like Ubuntu, CentOS, Arch Linux and others.\n\nOne of NixOS's major advantages over other distributions lies in its reproducibility and declarative configuration, allowing users to replicate consistent system environments across multiple machines.\n\nWhile NixOS is powerful, its strength also comes with increased system complexity. This makes it more challenging for newcomers. One major challenge is that the knowledge accumulated on other Linux distributions is not easily transferable to NixOS. Another is that official and community documentation is often scattered and outdated. These issues have troubled many NixOS beginners.\n\nOne can observe these issues with the experimental feature of the Nix package manager called Flakes. Inspired by package managers like npm and Cargo, Flakes uses flake.nix to record all external dependencies and flake.lock to lock their versions. This significantly enhances the reproducibility and composability of the Nix package manager and NixOS configurations. Flakes' advantages have made it widely popular within the community: according to official surveys, over half of the new Nix repositories created on GitHub now utilize Flakes. However, to maintain stability, the official documentation covers barely any Flakes-related content. This has left many Nix/NixOS users feeling confused. They see everyone using Flakes and want to learn it too, but find nowhere to start, often having to piece together scattered information, search through Nixpkgs source code, or seek help from more experienced users.\n\nThe Origin of This Book\n​\n\nThis book originated from my scattered notes when I first started with NixOS.\n\nIn April of this year (2023), when I got into NixOS, I fell in love with its design philosophy. At the recommendation of a friend, I learned about Nix's Flakes experimental feature. After comparing Flakes with the traditional NixOS configuration method, I realized that only a Flakes-enabled NixOS met my expectations. Consequently, I completely ignored the traditional Nix configuration approach and directly learned to configure my NixOS system using Flakes during my initial steps.\n\nThroughout my learning process, I found that there were very few beginner-friendly Flakes resources. The vast majority of documentation focused on the traditional Nix configuration approach, forcing me to extract the information I needed from various sources such as the NixOS Wiki, Zero to Nix, Nixpkgs Manual, and Nixpkgs source code while disregarding any non-Flakes-related content. This learning journey was quite convoluted and painful. To prevent future stumbling, I diligently documented numerous scattered notes as I progressed.\n\nWith some experience under my belt, in early May of this year, I switched my main PC to NixOS. After organizing and refining my NixOS newcomer notes, I published them on my blog[1] and shared them in the NixOS Chinese community. The Chinese community responded positively, and based on their advice, I translated the article into English and shared it on Reddit, receiving strong feedback[2].\n\nThe positive reception of this shared document encouraged me and drove me to continue improving it. Through continuous updates, the content of this document expanded to over 20,000 words. Some readers suggested that the reading experience could be improved, leading me to their suggestions[3]. As a result, I migrated the article's content to a GitHub repository, established a dedicated documentation site, and adjusted the presentation to make it more aligned with a beginner's guide rather than a personal notebook.\n\nAnd so, a bilingual open-source book was born, which I named \"<NixOS & Flakes Book>\" with the Chinese title \"NixOS & Flakes 新手指南\" (\"NixOS & Flakes Beginner's Guide\").\n\nThis open-source book's content evolved step by step as I used NixOS and engaged with readers. The sense of accomplishment from readers' positive feedback has been my greatest motivation for updates. Some readers' feedback has been immensely helpful in its \"evolution.\" Initially, I only wanted to share my experiences with NixOS in a somewhat casual manner, but it unexpectedly turned into an open-source book. Its readership abroad even surpassed that within my own country, and it garnered many stars - a result I never anticipated.\n\nI am grateful to all friends who have contributed to this book and offered suggestions, and I appreciate all the support and encouragement from the readers. Without all of you, this book's content might have remained confined to my personal blog, and it wouldn't have reached its current form.\n\nMy hope is that this book can help more people, enabling them to experience the joys of NixOS. I also wish for this book to benefit the NixOS community by encouraging more people to contribute to its development.\n\nThe content of this book is continually being updated, with much room for improvement. Any suggestions are welcome, and contributions to the content on GitHub are also highly encouraged.\n\nThe Features of This Book\n​\nFocused on NixOS and Flakes, disregarding the traditional Nix configuration approach.\nBeginner-friendly, with explanations from the perspective of NixOS newcomers who have some experience with Linux usage and programming.\nStep-by-step, progressive learning.\nCoherent content, well-organized, and structured. Readers can either read the book gradually or quickly find the information they need.\nDonation\n​\n\nIf you find this book helpful, please consider donating to support its development.\n\nPatreon: https://patreon.com/ryan4yin\nBuy me a coffee: https://buymeacoffee.com/ryan4yin\n爱发电: https://afdian.net/a/ryan4yin\nEthereum: 0xB74Aa43C280cDc8d8236952400bF6427E4390855\nHistorical Feedback and Discussions on This Book\n​\n\nEnglish feedback and related discussions:\n\n[2023-05-11] NixOS & Nix Flakes - A Guide for Beginners - Reddit\n[2023-06-22] Updates: NixOS & Nix Flakes - A Guide for Beginners - Reddit\n[2023-06-24] An unofficial NixOS & Flakes book for beginners - Discourse\n[2023-07-06] This isn't an issue but it has to be said: - Discussions\n\nChinese feedback and discussions:\n\n[2023-05-09] NixOS 与 Nix Flakes 新手入门 - v2ex 社区\n[2023-06-24] NixOS 与 Flakes | 一份非官方的新手指南 - v2ex 社区\n[2023-06-24] NixOS 与 Flakes | 一份非官方的新手指南 - 0xffff 社区\n\nNixOS & Nix Flakes - A Guide for Beginners - This Cute World ↩︎\n\nNixOS & Nix Flakes - A Guide for Beginners - Reddit ↩︎\n\nUpdates: NixOS & Nix Flakes - A Guide for Beginners - Reddit ↩︎"
  },
  {
    "title": "NixOS & Flakes Book | Home Page",
    "url": "https://nixos-and-flakes.thiscute.world/",
    "html": "NixOS & Flakes Book\n\nAn unofficial book for beginners\n\nWant to know NixOS & Flakes in detail? Looking for a beginner-friendly tutorial? Then you've come to the right place!\n\nPreface\nGet Started\nView on GitHub"
  }
]